[{"title":"Git使用","url":"%2F2017%2F08%2F12%2Fgit%2FGit%2F","content":"\n## Git\n\n>掌握git的常用命令操作\n>能够使用代码托管平台\n\n### 版本控制系统\n\n##### 本地版本控制系统\n借助软件我们可以记录下文件的每一次修改，如下图所示，文件被修改后，记录下了3个版本，\n这样我们通过版本控制系统（软件）便可以非常方便的恢复到任意版本。如下图所示:\n ![](/images/git/01.jpg)\n这种类型的版本控制系统，功能比较单一，比如很难实现多人协同开发，所以现在几乎很少使用了。\n##### 集中式版本控制系统\n实际开发环境，一个项目通常是由多人协作共同完成的，如何让在不同终端上的开发者协同工作成了亟待解决的问题，\n集中式版本控制系统便应运而生了。它通过单一的集中管理的服务器，保存所有文件的修订版本，\n协同工作的开发者都通过客户端连到这台服务器，取出最新的文件或者提交更新。其代表为SVN，如下图所示:\n![](/images/git/02.jpg)\n这种方式很好解决了多人协同开发的问题，但是也有一个弊端，如果集中管理的服务器出现故障，将会导致数据（版本）丢失的风险，\n另外协同开发者从集中服务器中更新数据时，严重依赖网络，如果网络不佳，也给开发带来诸多不便。\n\n##### 分布式版本控制系统\n分布式版本控制系统，则不需要中央服务器，每个协同开发者都拥有一个完整的版本库，\n这么一来，任何协同开发者用的服务器发生故障，事后都可以用其它协同开发者本地仓库恢复。\n由于版本库在本地计算机，也便不再受网络影响了。如果要将本地的修改，推送给其它协同开发者，\n还需要一台共享服务器，所有开发者通过这台共享服务器同步和更新数据。如下图所示:\n![](/images/git/03.jpg)\n分布式版本控制系统弥补了前面两种版本控制系统的缺陷，成为了版本控制的首选方案。其代表就是Git。\n\n### git准备工作\n##### git简介\n\n Git最初是在2005年由Linux之父Linus TorvaLinus领导开发的一套为Linux内核维护的版本管理系统；\n Git日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标，它的速度飞快，极其适合管理大项目；\n 它还有着令人难以置信的非线性分支管理系统，可以应付各 种复杂的项目开发需求。\n\n##### git与svn的区别\n\n- SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，\n  用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，\n  需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，\n  如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。\n\n- Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，\n  这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，\n  那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，\n  你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n\n##### git安装\n\n- Window安装\n    + http://git-scm.com/download/win 下载Git客户端软件，和普通软件安装方式一样。\n- Linux安装\n    + CentOS发行版：sudo yum install git\n    + Ubuntu发行版：sudo apt-get install git\n- Mac安装\n    + 打开Terminal直接输入git命令，会自动提示，按提示引导安装即可。\n\n##### git工作原理\n为了更好的学习Git，我们们必须了解Git管理我们文件的3种状态，\n分别是已提交（committed）、已修改（modified）和已暂存（staged），\n由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。\n![](/images/git/04.jpg)\n基本的Git工作流程如下：\n1、在工作目录中修改文件。\n2、暂存文件，将文件的快照放入暂存区域。\n3、提交文件，找到暂存区域的文件，将快照永久性存储到Git仓库目录。\n\n### git常见操作\n\n##### 1.配置用户\n```text\n    git config --global user.name \"zzzzzzzzz\"\n    git config --global user.email \"zzzzzzzzz@zzzz.cn\"\n```\n配置用户的意义在于记录开发者信息，以便在版本控制记录开发者的操作行为。\n\n##### 2.初始化仓库\n\n**a)**需要将现有项目初始化为一个仓库：\n```text\n    git init\n```\ngit init只是创建了一个名为.git的隐藏目录，这个目录就是存储我们历史版本的仓库。\n\n**b)**已用git进行版本控制的仓库克隆到本地：\n```text\n    git clone git@gitee.com:zzzzzzzzz/meituan.git\n```\n假如公司已有项目用了git，那我们就利用克隆，执行完这个命令，\n会在当前目录下生成一个meituan目录（默认和仓库名称相同），这个便是已经使用git管理的项目。\n\n##### 3.查看文件状态\n新建文件后：已修改状态\n```text\n    git status\n```\n检测当前仓库文件的状态，注：git会忽略空的目录。\n\n##### 4.添加文件到暂存区\n```text\n    //提交单个文件\n    git add test.txt\n    //提交单个目录文件\n    git add css\n    //提交所有文件\n    git add .|*|-A\n```\n执行命令后：已暂存状态\n修改文件后：已修改状态\n```text\n    git checkout test.txt\n```\n执行命令后：已暂存状态\n\n##### 5.提交文件\n将暂存区文件，全部提交到本地仓库存储。\n```text\n    // message 提交的备注信息\n    git commit -m \"message\";\n```\n执行命令后：已提交状态\n\n##### 6.查看提交历史\n经过多次提交，查看提交历史。\n```text\n    git log\n```\n\n##### 7.恢复上一次提交\n```text\n    git reset --hard 242a\n```\n\n### git分支\n\n在我们的现实开发中，需求往往是五花八门的，同时开发多个需求的情况十分常见，\n比如当你正在专注开发一个功能时，突然有一个紧急的BUG需要你来修复，\n这个时候我们当然是希望在能够保存当前任务进度，再去修改这个BUG，\n等这个BUG修复完成后再继续我们的任务。如何实现呢？\n**通过Git创建分支来解决实际开发中类似的问题。**\n\n在Git的使用过程中一次提交称为历史记录（版本），并且会生成一个唯一的字符串，如下图：\n![](/images/git/05.jpg)\n当我们在初始化仓库的时候（实际上是产生第1次提交时），Git会默认帮我们创建了一个master的分支，并且有指针（HEAD）指到了末端。\n指针（HEAD）用来标明当前处于哪个分支的哪个版本，如上图指的处于master分支的最后1个版本。\n\n##### 1.创建分支 hotfix\n```text\n    git branch hotfix\n```\n新的分支会在当前分支原有历史版本的结点上进行创建，新建的子分支会继承父分支的所有提交历史，如下图:\n![](/images/git/06.jpg)\n\n##### 2.切换 hotfix 分支\n```text\n    git checkout hotfix\n```\n我们发现HEAD现在又指向了hotfix的末端，如下图:\n![](/images/git/07.jpg)\n\n##### 3.在 hotfix 修改bug\n```text\n    git add .\n    git commit -m 'update bug'\n```\n这次的提交历史版本就会记录在hotfix这个分支上了，并且HEAD伴随hotfix在移动，如下图:\n![](/images/git/08.jpg)\n\n##### 4.切换 master 分支\n```text\n    git checkout master\n```\n当我们切换回master后，HEAD指向了master分支的末端，并且我们观察发现我们的文件内容还是原来的\"模样\"，如下图:\n![](/images/git/09.jpg)\n\n##### 5.在 master 继续开发\n```text\n        git add .\n        git commit -m 'go on dev'\n```\n总结：当我们 'git checkout 分支名称'，HEAD会自动指向对应分支的末端，工作目录中的源码也会随之发生改变。\n这个时候我们就在hotfix这个分支上修复了这个BUG，而我们原来在master分支上的操作并未受到影响。\n但是这时的master分支并没有包含有hotfix的修复，如下图:\n![](/images/git/10.jpg)\n\n##### 6.合并 hotfix 分支\n```text\n    git merge hotfix\n```\n这时master会有两个父结点了，master便包含了hotfix里的修复了，如下图:\n![](/images/git/11.jpg)\n\n##### 6.删除 hotfix 分支\n```text\n    git branch -d hotfix\n```\n这时用来修复BUG创建的hotfix分支已经没有用处了，我们可以将它删除，如下图:\n![](/images/git/12.jpg)\n\n\n### git远程（共享）仓库\n通过上面学习我们可以很好的管理本地版本控制了。\n- 一种情形，可是如果我们下班回到家里突然来了灵感觉得有部分代码可以优化，\n  如果能接着公司电脑上的代码继续写该有多好呀！！！\n- 一种情形，假设项目比较大，不同的功能模块由不同的开发人员完成，不同模块儿之间又难免会依赖关系，\n  这时如果我们的代码互相合并（融合）该有多好呀！！！\n\n##### 1.创建共享仓库\n\nGit要求共享仓库是一个以.git结尾的目录。\n\nmkdir repo.git 创建以.git结尾目录\n\ncd repo.git 进入这个目录\n\ngit init --bare 初始化一个共享仓库，也叫裸仓库 注意选项--bare\n\n这样我们就建好了一个共享的仓库，但这时这个仓库是一个空的仓库，并且不允在这个仓库中进行任何修改。\n\n##### 2.向共享仓库共享（同步）内容\n\n将自已开发的项目同步到这个目录中，其它开发者就可以共享你开发的项目了。\n\n1、进入到test目录\n\n2、git push ../repo.git master\n\n这样便把test中的项目同步进了repo.git中。\n\n##### 3.从共享仓库里取出内容\n\n1、新创建一个目录（模拟另一个开发者）\n\n2、git clone ./repo.git demo\n\n通过repo.git共享仓库，我们轻松得到了一个test的副本\n\n##### 4.通过demo仓库向repo.git共享内容\n\n进入到demo里，我们做一些修改\n\ncd demo\n\ngit push ../repo.git master\n\n##### 5.在仓库从repo.git获取共享的内容\n\ncd test\n\ngit pull ../repo.git master\n\n- 奇迹似乎发生了，我们轻松的将demo仓库里的内容，通过repo.git共享给了test仓库。\n- 惊喜不断，问题也总是不断，我们发现我们这个共享的仓库只是放到了本地的，其它人是没有办法从我们这个共享仓库共享内容的！！！\n- 然而现实是，办法总是有的，我们把这个共享的仓库放到一台远程服务器上，问题不就解决了吗？\n\n##### 6.gitHub、gitLab和gitee(码云)\n\n如果我们熟悉服务器的话，我们完全可以将上述的步骤在我们的远程服务器上进行操作，\n然后再做一些登录权限的设置，就可非常完美的搭建一个共享服务器了。\n其实为了更好的管理我们的仓库，一些第三方机构开发出了Web版仓库管理程序，通过Web界面形式管理仓库。\n\n- ssh\n- 简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。\n- 配置步骤：\n+ 使用git bash 执行 `ssh-keygen -t rsa `\n\n","tags":["Git"]},{"title":"13- swiper","url":"%2F2017%2F06%2F26%2FMWEB%2F13-swiper%2F","content":"\n##  swiper\n\n### 介绍\n\n**Swiper**是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。\n\n**Swiper**能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。\n\n**Swiper**开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！\n\n### 使用\n\n# Swiper4.x使用方法\n\n1.首先加载插件，需要用到的文件有swiper.min.js和swiper.min.css文件。可下载[Swiper文件](http://www.swiper.com.cn/download/index.html#file1)或使用[CDN](http://www.swiper.com.cn/cdn/index.html)。\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    ...\n    <link rel=\"stylesheet\" href=\"path/to/swiper.min.css\">\n</head>\n<body>\n    ...\n    <script src=\"path/to/swiper.min.js\"></script>\n</body>\n</html>\n```\n\n2.HTML内容。\n\n```\n<div class=\"swiper-container\">\n    <div class=\"swiper-wrapper\">\n        <div class=\"swiper-slide\">Slide 1</div>\n        <div class=\"swiper-slide\">Slide 2</div>\n        <div class=\"swiper-slide\">Slide 3</div>\n    </div>\n    <!-- 如果需要分页器 -->\n    <div class=\"swiper-pagination\"></div>\n    \n    <!-- 如果需要导航按钮 -->\n    <div class=\"swiper-button-prev\"></div>\n    <div class=\"swiper-button-next\"></div>\n    \n    <!-- 如果需要滚动条 -->\n    <div class=\"swiper-scrollbar\"></div>\n</div>\n导航等组件可以放在container之外\n```\n\n3.你可能想要给Swiper定义一个大小，当然不要也行。\n\n```\n.swiper-container {\n    width: 600px;\n    height: 300px;\n}  \n```\n\n4.初始化Swiper：最好是挨着</body>标签\n\n```\n<script>        \n  var mySwiper = new Swiper ('.swiper-container', {\n    direction: 'vertical',\n    loop: true,\n    \n    // 如果需要分页器\n    pagination: {\n      el: '.swiper-pagination',\n    },\n    \n    // 如果需要前进后退按钮\n    navigation: {\n      nextEl: '.swiper-button-next',\n      prevEl: '.swiper-button-prev',\n    },\n    \n    // 如果需要滚动条\n    scrollbar: {\n      el: '.swiper-scrollbar',\n    },\n  })        \n  </script>\n</body>\n```\n\n如果不能写在HTML内容的后面，则需要在页面加载完成后再初始化。\n\n```\n<script type=\"text/javascript\">\nwindow.onload = function() {\n  ...\n}\n</script>\n```\n\n或者这样（Jquery和Zepto）\n\n```\n<script type=\"text/javascript\">\n$(document).ready(function () {\n ...\n})\n</script>\n```\n\n5.完成。恭喜你，现在你的Swiper应该已经能正常切换了。\n\n6.参考地址 http://www.swiper.com.cn/api/index.html\n\n## 总结\n\n移动端轮播图需求使用swiper来解决是一个好的选择。","tags":["MWEB"]},{"title":"12-zepto.js","url":"%2F2017%2F06%2F25%2FMWEB%2F12-zepto%2F","content":"\n## zepto.js\n\n### zepto介绍\n\n- Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 如果你会用jquery，那么你也会用zepto。\n- Zepto模块\n\n| module     | default | description                              |\n| ---------- | ------- | ---------------------------------------- |\n| zepto      | ✔       | 核心模块；包含许多方法                              |\n| event      | ✔       | 通过on()& off()处理事件                        |\n| ajax       | ✔       | XMLHttpRequest 和 JSONP 实用功能              |\n| form       | ✔       | 序列化 & 提交web表单                            |\n| ie         | ✔       | 增加支持桌面的Internet Explorer 10+和Windows Phone 8。 |\n| detect     |         | 提供 $.os和 $.browser消息                     |\n| fx         |         | The animate()方法                          |\n| fx_methods |         | 以动画形式的 show, hide, toggle, 和 fade*()方法.  |\n| assets     |         | 实验性支持从DOM中移除image元素后清理iOS的内存。            |\n| data       |         | 一个全面的 data()方法, 能够在内存中存储任意对象。            |\n| deferred   |         | 提供 $.Deferredpromises API. 依赖\"callbacks\" 模块. 当包含这个模块时候, $.ajax() 支持promise接口链式的回调。 |\n| callbacks  |         | 为\"deferred\"模块提供 $.Callbacks。             |\n| selector   |         | 实验性的支持 jQuery CSS 表达式 实用功能，比如 $('div:first')和 el.is(':visible')。 |\n| touch      |         | 在触摸设备上触发tap– 和 swipe– 相关事件。这适用于所有的`touch`(iOS, Android)和`pointer`事件(Windows Phone)。 |\n| gesture    |         | 在触摸设备上触发 pinch 手势事件。                     |\n| stack      |         | 提供 andSelf& end()链式调用方法                  |\n| ios3       |         | String.prototype.trim 和 Array.prototype.reduce 方法 (如果他们不存在) ，以兼容 iOS 3.x. |\n\n### 自定义打包\n\n```text\n1、首先在自己的电脑上要安装Node.js和npm包管理工具；\n2、从github上下载zepto.js的源文件包到本地磁盘（例如：E:\\Learning\\JS）；地址：https://github.com/madrobby/zepto\n3、将下载的zepto压缩包解压，进入，找到make文件，打开，找到第42行的位置，添加需要的模块名称（这里增加了fx_methods 和 fx 模块），以空格做分隔；  \nmodules = (env['MODULES'] || 'zepto event ajax form ie').split(' ')\n4、运行中，cmd打开命令窗口，并进入zepto文件目录；\n5、执行 npm install 命令；\n6、输入npm run-script dist 命令，进行构建；\n```\n## 总结\n\nzepto就是jquery的轻量版，功能差不多，但是不完全覆盖。","tags":["MWEB"]},{"title":"11-rem适配方案","url":"%2F2017%2F06%2F24%2FMWEB%2F11-rem%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%2F","content":"\n## rem适配方案\n\n### rem的适配原理\n\n- rem 是相对于页面根源素html的字体大小的一个尺寸单位\n- 页面内容可以使用rem为单位，那么html的字体大小就是一个控制尺寸的开关\n- 当设备改变的时候可以根据设备的宽度和原本设计稿的尺寸比例关系设置html的字体大小\n- 这样凡是以rem为单位的内容会根据设备做等比适配\n\n```text\n    1.假设设计稿是750px\n    2.假设这个时候html字体大小为100px\n    3.那么在320px设备的时候  字体大小为 100/750*320\n    4.只要根据这个比例在不同设备设置rem基准值(html字体大小)即可\n    5.改变rem基准值有两种方式：媒体查询或javascript\n```\n### rem+媒体查询\n\n```css\n/*假设的设备  320px 414px 640px */\n@media (min-width: 320px) {\n    html{\n        font-size: 50px;\n    }\n}\n@media (min-width: 414px) {\n    html{\n        font-size: 64.6875px;\n    }\n}\n@media (min-width: 640px) {\n    html{\n        font-size: 100px;\n    }\n}\n```\n### rem+flexible.js\n\n- flexible.js 是手机淘宝团队做移动端适配的库\n- 我们使有它的目的只有一个根据设备设置rem基准值\n\n```html\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=.0\">\n<script src=\"flexible.js\"></script>\n```\n### 基于less的rem可维护方案\n\n```less\n//适配主流设备十几种\n@adapterDeviceList:750px,720px,640px,540px,480px,424px,414px,400px,384px,375px,360px,320px;\n//设计稿尺寸\n@psdWidth:750px;\n//预设基准值\n@baseFontSize:100px;\n//设备的种类\n@len:length(@adapterDeviceList);\n//适配函数\n.adapterMixin(@index) when ( @index > 0){\n  @media (min-width: extract(@adapterDeviceList,@index)){\n    html{\n      font-size: @baseFontSize / @psdWidth * extract(@adapterDeviceList,@index);\n    }\n  }\n  .adapterMixin( @index - 1);\n}\n```\n## 总结\n\n使用rem完成页面的适配，注意不一定全部都是rem,大布局的适配还是可以使用流失布局或者伸缩布局。\n\n","tags":["MWEB"]},{"title":"10-less","url":"%2F2017%2F06%2F24%2FMWEB%2F10-less%2F","content":"\n## less\n\n### 什么是less\n\n作为一门标记性语言，CSS 的语法相对简单，对使用者的要求较低，但同时也带来一些问题：CSS需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码，造成这些困难的很大原因源于 CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。LESS 为 Web 开发者带来了福音，它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，LESS 可以让我们用更少的代码做更多的事情。\n\n### less的安装\n\n1. 安装nodejs https://nodejs.org/dist/ 可选择版本(6.0)。\n2. 检查是否安装成功，使用cmd命令 node -v 查看版本即可。\n3. 基于nodejs安装less:\n    + 在线安装：使用cmd命令 npm install -g less\n\n    + 离线安装:   \n      a.找到C盘根目录下的用户或User文件夹打开  \n      b.找到当前计算机使用的用户文件夹打开  \n      c.找到隐藏文件夹AppData打开  \n      d.找到Roaming文件夹打开  \n      e.找到npm文件夹打开，该文件夹为基于nodejs程序目录  \n      f.把npm.zip文件解压到该目录 \n\n      g.可以在命令符中查看版本  lessc  -v\n\n      ​\n4. 基于koala软件也可以编译LESS;\n\n### less编译\n\n本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。\n\n- **如果使用viscode 可下载EASY LESS  插件。**直接创建新文件   xxx.less 即可生成 对应的 xxx.css文件\n\n```text\n    lessc 目标文件地址 生成文件地址\n```\n在开发过程当中如果要预览less，每次都要执行编译命令，为了方便可以使用部分编辑器中less自动编译功能。\n1. 点击文件打开菜单，选择设置选项\n2. 选择工具当中的文件监听选项\n3. 点击右上角加号按钮，选择less后弹出对话框，点击确定即可。less的语法\n\n### less基本语法\n\n- 变量\n```less\n    @mainColor:#e92323;\n    @className:box;\n    \n    div{\n      background: @mainColor;\n    }\n    a:hover{\n      color: @mainColor;\n    }\n    //变量用于字符拼接使用方法\n    .@{className}{\n      color: @mainColor;\n    }\n```\n- 混入(mixin)\n```less\n    .borderRadius(@width:100px){\n      border-radius: @width;\n      -webkit-border-radius:@width;\n      -moz-border-radius:@width;\n      -o-border-radius:@width;\n      -ms-border-radius:@width;\n    }\n```\n- 嵌套\n```less\n    .wjs_app{\n      display: block;\n      img{\n        display: none;\n      }\n      /*需要连接的情况：&*/\n      &:hover{\n        img{\n          display: block;\n          position: absolute;\n          left: 50%;\n          margin-left:-60px;\n          border: 1px solid #ccc;\n          border-top: none;\n          top:40px;\n          z-index: 100000;\n        }\n      }\n      > div{\n        display: block;\n      }\n    }\n```\n- 导入\n```text\n@import \"variables\";\n```\n- 运算&内置函数\n\napi地址：http://lesscss.cn/functions/#functions-overview\n\n中文：http://www.css88.com/doc/less/functions/#color-operations\n\n```less\n   /*运算*/\n   @num:5;\n   ul{\n     width: 100%*@num;\n     li{\n       width: 100%/@num;\n       color: red+yellow+blue;\n       background: gray*0.3;\n       /*内置函数*/\n       border-color: darken(red,20%);\n     }\n   } \n```\n### less预览\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <link rel=\"stylesheet\" type=\"text/less\" href=\"index.less\">\n    <script src=\"less.min.js\"></script>\n    <script>\n        less.watch();\n    </script>\n</head>\n<body>\n    <!--1.在浏览器端直接使用less文件预览 type=\"text/less\" -->\n    <!--2.浏览器无法直接使用less类型的文件，无法解析-->\n    <!--3.转换成css,需要js插件支持-->\n    <!--4.下载插件 https://github.com/less/less.js/tree/master/dist -->\n    <!--5.less.js会异步加载less文件的内容，再去解析成css,然后追加到style-->\n    <!--6.必须使用HTTP形式打开页面，不要以file形式打开-->\n    <!--7.更改完成之后每次要刷新，可以配置less监听，自动刷新页面预览-->\n    <!--8.需要js配置 less.watch() -->\n    <div class=\"box2\">test</div>\n</body>\n</html>\n```\n## 总结\n\nless是一门预编译脚本语法，使用它用来提高css的可维护性。\n\n","tags":["MWEB"]},{"title":"09-bootstrap","url":"%2F2017%2F06%2F23%2FMWEB%2F09-bootstrapUI%E6%A1%86%E6%9E%B6%2F","content":"## bootstrap\n\n\n### 什么是UI框架\n\nuser interface 用户界面，指的是有预制样式库，组件，插件，有一套比较完整的网页功能解决方案，称为UI框架\n\n### bootstrap是什么\n\n- 简介：  \n    + 作者：Twitter  公司两位前端工程师（mark otto && jacob thornton）在2011发起开发完成的。\n    + 特点：组件简洁大方，代码规范精简，界面自定义性强。\n    + 目的：提高web开发效率。  \n- 文档：  \n    + 中文官网  http://www.bootcss.com/\n    + 官网 http://getbootstrap.com/\n    + 学习文档 http://bootstrap.css88.com/  \n- 优点：  \n    + 有自己的生态圈，不断的更新迭代。\n    + 提供了一套简洁、直观、强悍的组件。\n    + 标准化的html+css编码规范。\n    + 让开发更简单，提高了开发的效率。\n    + **注意：虽然界面组件样式已经定义好了，但是扩展性相对较强，也就是说我们还可以自定义，修改默认样式。**\n- 版本:  \n    + 2.x.x  停止维护,兼容性好,代码不够简洁，功能不够完善。\n    + 3.x.x  目前使用最多,稳定,但是放弃了IE6-IE7。对IE8支持但是界面效果不好,偏向用于开发响应式布局、移动设备优先的 WEB 项目。\n\n### bootstrap基本模板\n\n````html\n<!--h5文档申明-->\n<!DOCTYPE html>\n<!--文档语言申明  en zh-CN zh-tw -->\n<html lang=\"zh-CN\">\n<head>\n    <!--文档编码申明-->\n    <meta charset=\"utf-8\">\n    <!--要求当前网页使用浏览器最高版本的内核来渲染-->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <!--视口的设置：视口的宽度和设备一致，默认的缩放比例和PC端一致，用户不能自行缩放-->\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=0\">\n    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\n    <!-- 优先加载和浏览器解释 -->\n\n    <title>title</title>\n\n    <!-- Bootstrap 核心样式-->\n    <link href=\"../lib/bootstrap/css/bootstrap.css\" rel=\"stylesheet\">\n    <!-- html5shiv 和  respond 分别用来解决IE8版本浏览器不支持 H5标签和媒体查询的  不兼容问题-->\n    <!-- HTML5 shiv and Respond.js for IE8 support of HTML5 elements and media queries -->\n    <!-- 警告：不能以file形式打开，本地打开。最好http://打开 -->\n    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->\n    <!-- 在 IE 9 一下引入-->\n    <!--[if lt IE 9]>\n    <script src=\"../lib/html5shiv/html5shiv.min.js\"></script>\n    <script src=\"../lib/respond/respond.min.js\"></script>\n    <![endif]-->\n</head>\n<body>\n<!--TODO-->\n<!-- bootstrap依赖jquery-->\n<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->\n<script src=\"../lib/jquery/jquery.min.js\"></script>\n<!-- bootstrap js 核心文件-->\n<!-- Include all compiled plugins (below), or include individual files as needed -->\n<script src=\"../lib/bootstrap/js/bootstrap.min.js\"></script>\n</body>\n</html>\n````\n### bootstrap常用类\n\n- container\n- container-fluid\n- row\n- col-\\*-\\*\n- col-\\*-offset-\\*\n- col-\\*-pull-\\*\n- col-\\*-push-\\*\n- pull-left\n- pull-right\n- text-center\n- text-left\n- text-right\n\n### 怎么使用组件\n\n查询官方文档\n\n- 组件的HTML模板代码结构分析\n- 写一份和组件一致的样式选择器修改预制样式为产品需求样式\n- 检查响应式是否符合产品需求，不满足自行修改\n\n## 总结\n\nbootstrap是一个完整的组件库，包含html,css,js的框架，能够快速的搭建响应式站点。","tags":["MWEB"]},{"title":"08-响应式布局","url":"%2F2017%2F06%2F22%2FMWEB%2F08-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F","content":"\n## 响应式布局\n\n### 响应式布局概念\n\n- 在移动互联日益成熟的时候，我们在桌面浏览器上开发的网页已经无法满足移动设备的阅读。\n- 通常的做法是针对移动端单独做一套特定的版本。\n- 但是如果终端越来越多那么你需要开发的版本就会越来越多（大屏移动设备普及）。\n- 那么Ethan Marcotte在2010年5月份提出的一个概念，简而言之，**就是一个网站能够兼容多个终端**。\n\n### 响应式布局原理\n\nCSS3中的Media Query（媒体查询）  \n**通过查询screen的宽度来指定某个宽度区间的网页布局。**\n\n| 划分设备     | 尺寸区间         |\n| -------- | ------------ |\n| 超小屏幕（手机） | 768px以下      |\n| 小屏设备     | 768px-992px  |\n| 中等屏幕     | 992px-1200px |\n| 宽屏设备     | 1200px以上     |\n\n```css\n@media screen and (max-width: 768px){\n  .container{\n    width: 100%;\n  }\n}\n@media screen and (min-width: 768px) and (max-width: 992px){\n  .container{\n    width: 750px;\n  }\n}\n@media screen and (min-width: 992px) and (max-width: 1200px){\n  .container{\n    width: 970px;\n  }\n}\n@media screen and (min-width: 1200px){\n  .container{\n    width: 1170px;\n  }\n}\n```\n\n\n\n### 对比针对移动端开发区别\n\n| 开发方式 | 移动web开发+PC开发                    | 响应式开发                                 |\n| ---- | ------------------------------- | ------------------------------------- |\n| 应用场景 | 一般在已经有PC端的网站，开发移动站的时候，只需单独开发移动端 | 针对新建站的一些网站，现在要求适配移动端，所以就一套页面兼容各种终端，灵活 |\n| 开发   | 针对性强，开发效率高                      | 兼容各种终端，效率低                            |\n| 适配   | 只适配 移动设备，pad上体验相对较差             | 可以适配各种终端                              |\n| 效率   | 代码简洁，加载快                        | 代码相对复杂，加载慢                            |\n\n## 总结\n\n移动web开发和响应式开发都是现在主流的开发模式。  \n使用的都是流式布局，来适配不同设备。  \n由于终端设备的多样化，新建站的站点会优先用响应式来开发。\n\n","tags":["MWEB"]},{"title":"07-手势事件","url":"%2F2017%2F06%2F22%2FMWEB%2F07-%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6%2F","content":"\n## 手势事件\n\n\n### 轻触事件 tap\n\n出现的原因：由于早期移动端页面双击可以缩放，为了检测双击操作，延长了click的响应时间，200-300ms。\n\n第一种解决方案：\n```javascript\n        /*模拟tap事件（tap在移动端库zepto.js有使用）*/\n        /*1. 响应的速度比click要快   150ms */\n        /*2. 不能滑动*/\n        var bindTapEvent = function (dom, callback) {\n            var startTime = 0;\n            var isMove = false;\n            dom.addEventListener('touchstart', function () {\n                startTime = Date.now();\n            });\n            dom.addEventListener('touchmove', function () {\n                isMove = true;\n            });\n            dom.addEventListener('touchend', function (e) {\n                if ((Date.now() - startTime) < 150 && !isMove) {\n                    callback && callback.call(this, e);\n                }\n                startTime = 0;\n                isMove = false;\n            });\n        }\n```\n第二种解决方案：\n```html\n<!--\n1 使用一个叫：fastclick.js 提供移动端click响应速度的\n2 下载：https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js\n3 使用：\n-->\n<script src=\"../js/fastclick.min.js\"></script>\n<script>\n    /*当页面的dom元素加载完成 如果使用jquery $(function(){});*/\n    document.addEventListener('DOMContentLoaded', function() {\n        /*初始化方法*/\n        FastClick.attach(document.body);\n    }, false);\n    /*正常使用click事件就可以了*/\n</script>\n```\n\n\n### 滑动手势事件 swipe\n\n手势事件：滑动，左滑，右滑，上滑，下滑 （swipe在移动端库zepto.js有使）\n\n```javascript\n        /*1. 理解移动端的手势事件*/\n        /*2. swipe swipeLeft swipeRight swipeUp swipeDown */\n        /*3. 左滑和右滑手势怎么实现*/\n        var bindSwipeEvent = function (dom,leftCallback,rightCallback) {\n            /*手势的条件*/\n            /*1.必须滑动过*/\n            /*2.滑动的距离50px*/\n            var isMove = false;\n            var startX = 0;\n            var distanceX = 0;\n            dom.addEventListener('touchstart',function (e) {\n                startX = e.touches[0].clientX;\n            });\n            dom.addEventListener('touchmove',function (e) {\n                isMove = true;\n                var moveX = e.touches[0].clientX;\n                distanceX = moveX - startX;\n            });\n            dom.addEventListener('touchend',function (e) {\n                /*滑动结束*/\n                if(isMove && Math.abs(distanceX) > 50){\n                    if(distanceX > 0){\n                        rightCallback && rightCallback.call(this,e);\n                    }else{\n                        leftCallback && leftCallback.call(this,e);\n                    }\n                }\n                /*重置参数*/\n                isMove = false;\n                startX = 0;\n                distanceX = 0;\n            });\n        }\n        bindSwipeEvent(document.querySelector('.box'),function (e) {\n            console.log('左滑手势');\n        },function (e) {\n            console.log('右滑手势');\n        });\n```\n\n\n## 总结\n\n移动端的一些手势事件都是由touch事件封装得来的，在一些移动端框架中会使用。","tags":["MWEB"]},{"title":"06-区域滚动","url":"%2F2017%2F06%2F21%2FMWEB%2F06-%E5%8C%BA%E5%9F%9F%E6%BB%9A%E5%8A%A8%E6%8F%92%E4%BB%B6%2F","content":"\n## 区域滚动\n\n### 插件介绍\n\n区域滚动插件，对于移动端的页面滚动效果表现不一致，和需要上拉刷新上拉加载等效果的页面，可以帮助快速的实现滚动效果。\n\n### 插件使用\n\n**IScroll是一个类，每个需要使用滚动功能的区域均要进行初始化**。每个页面上的iScroll实例数目在设备的CPU和内存能承受的范围内是没有限制的。\n\n尽可能保持DOM结构的简洁。iScroll使用硬件合成层但是有一个限制硬件可以处理的元素。\n最佳的HTML结构如下：\n\n```html\n<div id=\"wrapper\">\n    <ul>\n        <li>...</li>\n        <li>...</li>\n        ...\n    </ul>\n</div>\n```\n\niScroll作用于滚动区域的外层。在上面的例子中，UL元素能进行滚动。只有容器元素的第一个子元素能进行滚动，其他子元素完全被忽略。\n\n最基本的脚本初始化的方式如下：\n\n```html\n<script type=\"text/javascript\">\n    var myScroll = new IScroll('#wrapper');\n</script>\n```\n\n**第一个参数可以是滚动容器元素的DOM选择器字符串**，也可以是滚动容器元素的引用对象。下面是一个有效的语法：\n\n```js\nvar wrapper = document.getElementById('wrapper');\nvar myScroll = new IScroll(wrapper);\n```\n\n所以基本上你要么直接传递元素，要么传递一个querySelector字符串。因此可以使用css名称代替ID去选择一个滚动器容器,如下:\n\n```js\nvar myScroll = new IScroll('.wrapper');\n```\n\n> 注意，iScroll使用的是querySelector 而不是 querySelectorAll，所以iScroll只会作用到选择器选中元素的第一个。如果你需要对多个对象使用iScroll，你需要构建自己的循环机制。\n\n\n\n### 参数配置\n\n参考 http://www.mamicode.com/info-detail-331827.html\n\n## 总结\n\n在移动端的上拉刷新，下拉加载，区域滑动，可使用区域滚动插件快速实现。","tags":["MWEB"]},{"title":"05-触摸事件","url":"%2F2017%2F06%2F19%2FMWEB%2F05-touch%E4%BA%8B%E4%BB%B6%2F","content":"\n### 触摸事件\n\n| 事件          | 说明                    |\n| ----------- | --------------------- |\n| touchstart  | 当手指触碰屏幕时候触发该事件        |\n| touchmove   | 当手指在屏幕上滑动时候触发该事件      |\n| touchend    | 当手指离开屏幕时触发该事件         |\n| touchcancel | 当系统停止跟踪（被迫终止）触摸时候会触发。 |\n\n| 触摸点集合          | 说明              |\n| -------------- | --------------- |\n| targetTouches  | 目标元素的所有当前触摸点集合  |\n| changedTouches | 目标元素的最新更改的触摸点集合 |\n| touches        | 页面上的所有触摸点集合     |\n注意：在touchend事件的时候event只会记录changedtouches\n\n| 点坐标             | 说明        |\n| --------------- | --------- |\n| pageX/pageY     | 基于页面大小的坐标 |\n| clientX/clientY | 基于视口大小的坐标 |\n| screenX/screenY | 基于屏幕大小的坐标 |\n\n### 滑动效果原理\n\n```js\nimageBox.addEventListener('touchmove', function (e) {\n        var moveX = e.touches[0].clientX;\n        distanceX = moveX - startX;\n        /*计算将要给图片盒子的定位*/\n        /*基于当前的定位去计算*/\n        var translateX = -index * width + distanceX;\n});\n```\n\n\n\n## 总结\n\n移动端滑动效果，就是使用touch事件，拖动元素。","tags":["MWEB"]},{"title":"04-移动端二倍图","url":"%2F2017%2F06%2F17%2FMWEB%2F04-%E4%BA%8C%E5%80%8D%E5%9B%BE%2F","content":"\n\n## 移动端二倍图\n\n\n### 移动端设备屏幕清晰度\n\n- 物理像素点指的是屏幕显示的最小颗，是物理真实存在的。\n- 所谓Retina是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。\n- 而一个px的绝对（在开发中认为是绝对）长度能显示的物理像素点的个数，称为物理像素比，屏幕像素比。\n\n![img](data:image/jpeg;base64,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Mrf/AOLrvfgP+yF8T/A3xg8K6/rGi29vplheCa4lW/hcquCM7QxJ69qVLD1lUi3B7roXmOd5ZUwVeEMTBtxkkuZb2fmfMHjr/kd/EP8A2Ebj/wBGtWHX0n4q/Yl+LeqeKNYvbfQbV7e4vJpo2OowDKs5IOC/HBrK/wCGFvjD/wBC/a/+DK3/APi6iWGrXfuP7jro57lapRTxMNl9pf5nD/s5f8l68Af9hq1/9GCsP4r/APJUvGP/AGGbz/0e9fQ/wZ/Y6+KXg74seEtc1TRLaDTtP1KC5uJFv4XKorgkgBsnjsKy/H/7FnxY17x34k1Oy0K2ks73Urm5hc6hApZHlZlOC2RwRxWv1et7JLke/byPOWdZZ/aLqfWYcvIlfmVr8z03PmKvVP2WP+ThfAn/AGEV/wDQWrqv+GFvjD/0L9r/AODK3/8Ai6734D/shfE/wN8YPCuv6xotvb6ZYXgmuJVv4XKrgjO0MSevappYesqkW4PddDbMc7yypgq8IYmDbjJJcy3s/M/QiiiivsD+XwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//2Q==)\n\n### 二倍图的使用\n\n在标准的viewport设置中，使用二倍图来提高图片质量，解决在高清设备模糊问题。\n\n```css\n    .box{\n        /*原始图片100*100px*/\n        background-size: 50px 50px;\n    }\n    img{\n        /*原始图片100*100px*/\n        width: 50px;\n        height: 50px;\n    }\n```\n\n## 总结\n\n在移动端屏幕的清晰度由物理像素比决定的，但是如果对于现实的图片质量不够，会造成图片模糊发虚现象，二倍图是决定这个问题的简单做法。\n\n","tags":["MWEB"]},{"title":"03-标准视口","url":"%2F2017%2F06%2F15%2FMWEB%2F03-%E6%A0%87%E5%87%86%E8%A7%86%E5%8F%A3%2F","content":"\n### 视口概念\n\n- 这是一个虚拟的区域，用来承载网页的区域，在浏览器可视窗口和网页之间。\n- 有一些设备viewport的默认宽度是980px,网页内容显示在里面，为了能在320px屏幕内显示，会自动缩放。\n\n在移动端有特殊的功能：可以设置宽度和高度，可以设置缩放比例，控制缩放的比例，控制用户是否可以自行缩放。\n\n### 视口属性详解\n\n| 属性            | 解释                                   |\n| ------------- | ------------------------------------ |\n| width         | 宽度设置的是viewport宽度，可以设置device-width特殊值 |\n| initial-scale | 初始缩放比，大于0的数字                         |\n| maximum-scale | 最大缩放比，大于0的数字                         |\n| minimum-scale | 最小缩放比，大于0的数字                         |\n| user-scalable | 用户是否可以缩放，yes或no（1或0）                 |\n\n### 视口的具体应用\n\n- 适配有三点事情需要去做：\n  - 页面的宽度和设备样宽\n  -  默认的缩放比例是1.0\n  -  不允许用户去缩放页面\n- 标准的viewport设置：\n  - 视口宽度和设备保持一致\n  - 视口的默认缩放比例1.0\n  - 不允许用户自行缩放\n  - 最大允许的缩放比例1.0\n  - 最小允许的缩放比例1.0\n\n```html\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n```\n\n\n\n## 总结\n\n移动端适配视口的标准设置是前提，虽然是标准设置，那其他设置是否也可以达到适配目的呢?","tags":["MWEB"]},{"title":"02-流失布局","url":"%2F2017%2F06%2F15%2FMWEB%2F02-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%2F","content":"\n## 流式布局\n\n- **流式布局**,就是百分比布局,也称**非固定像素布局**。\n- 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。\n- 这样的布局方式,是移动web开发使用的最常用布局方式。\n\n### 伸缩布局\n\n- CSS3引入了一种新的布局模式——**Flexbox布局**，即**伸缩布局盒模型**（Flexible Box），用来提供一个更加有效的方式制定、调整和分布一个容器里项目布局，即使它们的大小是未知或者动态的，这里简称为**Flex**。\n- Flexbox布局常用于设计比较复杂的页面，可以轻松的实现屏幕和浏览器窗口大小发生变化时保持元素的相对位置和大小不变，同时减少了依赖于浮动布局实现元素位置的定义以及重置元素的大小。\n\n## 总结\n\n在屏幕设备尺寸不一致的情况下，使用非固定像素布局可以达到适配的目的，但是在移动端仅仅使用流失布局或者伸缩布局，还不够，因为受 **视口（viewport）** 影响。","tags":["MWEB"]},{"title":"01-移动端现状","url":"%2F2017%2F06%2F14%2FMWEB%2F01-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%8E%B0%E7%8A%B6%2F","content":"\n## 浏览器问题\n\n```\n   UC浏览器，QQ浏览器，欧朋浏览器，百度手机浏览器，360安全浏览器，谷歌浏览器，搜狗手机浏览器，猎豹浏览器，其他杂牌浏览器\n    国内的UC和QQ，百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自助研发的内核，就像国内的手机操作系统都是基于Android修改的\n```\n\n## 设备屏幕问题\n\n```\n   大家都知道移动端设备屏幕尺寸非常多，碎片化严重。\n   尤其是Android，你会听到很多种分辨率：480x800, 480x854, 540x960, 720x1280, 1080x1920，而且还有传说中的2K,4k屏。\n   近年来iPhone的碎片化也加剧了：640x960, 640x1136, 750x1334, 1242x2208。\n```\n\n## 使用技术问题\n\n```\n移动web开发指的是需要适配移动设备的页面开发\n移动web和桌面web没有本质的区别都使用css、html与js\n```\n\n## 主流设备尺寸\n\n| 设备                    | 尺寸(英寸) | 开发尺寸(px) | 物理像素比(dpr) |\n| --------------------- | ------ | -------- | ---------- |\n| iphone3G              | 3.5    | 320*480  | 1.0        |\n| iphone4/4s            | 3.5    | 320*480  | 2.0        |\n| iphone5/5s/5c         | 4.0    | 320*568  | 2.0        |\n| HTC One M8            | 4.5    | 360*640  | 3.0        |\n| iphone6               | 4.7    | 375*667  | 2.0        |\n| Nexus 4               | 4.7    | 384*640  | 2.0        |\n| Nexus 5x              | 5.2    | 411*731  | 2.6        |\n| iphone6 Plus          | 5.5    | 414*736  | 3.0        |\n| Samsung Galaxy Note 4 | 5.7    | 480*853  | 3.0        |\n| Sony Xperia Z Ultra   | 6.4    | 540*960  | 2.0        |\n| Nexus 7 ('12)         | 7.0    | 600*960  | 1.3        |\n| iPad Mini             | 7.9    | 768*1024 | 1.0        |\n\n注：以上数据均参考 https://material.io/devices/ ,一个设备尺寸统计网站。  \n注：作为前端开发不建议大家去纠结dp,dpi,pt,ppi等单位,因为它们有复杂的转换关系。\n\n## 总结\n\n移动web开发，也称之为H5开发，要迫切解决的问题不是技术，而是怎么去适配。","tags":["MWEB"]},{"title":"13-视差滚动","url":"%2F2017%2F05%2F22%2FH5C3%2F13-%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8%2F","content":"\n# 视差滚动\n\n## 目标\n\n- 掌握stellar插件的使用\n- 理解什么是视差滚动效果\n\n## 知识内容 \n\n### 视差滚动\n\n- 描述\n    + 视差滚动（Parallax Scrolling）指网页滚动过程中，\n      多层次的元素进行不同程度的移动，视觉上形成立体运动效果的网页展示技术\n      主要核心就是前景和背景以不同的速度移动，从而创造出3D效果。 \n      这种效果可以给网站一个很好的补充。\n\n- 特性\n    + 视差滚动效果酷炫，适合于个性展示的场合。\n    + 视差滚动徐徐展开，适合于娓娓道来，讲故事的场合。\n    + 视差滚动容易迷航，需要具备较强的导航功能。\n\n- 原理\n    + 传统的网页的文字、图片、背景都是一起按照相同方向相同速度滚动的，\n      而视差滚动则是在滚动的时候，内容和多层次的背景实现或不同速度，或不同方向的运动。\n      有的时候也可以加上一些透明度、大小的动画来优化显示。利用background-attachment属性实现。 \n\n    ### 使用步骤\n\n    + 引用文件\n    ~~~html\n        <script src=\"jquery/jquery.min.js\"></script>\n        <script src=\"jquery.stellar.min.js\"></script>\n    ~~~\n    + html结构\n    ```html\n        <div class=\"content\" id=\"content1\">\n            <p>TEXT HERE</p>\n        </div>\n        <div class=\"content\" id=\"content2\">\n            <p>TEXT HERE</p>\n        </div>\n        <div class=\"content\" id=\"content3\" data-stellar-background-ratio=\"0.5\">\n            <p>TEXT HERE</p>\n        </div>\n        <div class=\"content\" id=\"content4\" data-stellar-background-ratio=\"0.5\">\n            <p>TEXT HERE</p>\n        </div>\n        <div class=\"content\" id=\"content5\" data-stellar-background-ratio=\"0.5\">\n            <p>TEXT HERE</p>\n        </div>\n        <div class=\"content\" id=\"content6\" data-stellar-background-ratio=\"0.5\">\n            <p>TEXT HERE</p>\n        </div> \n    ```\n    + 基本样式\n    ~~~css\n        .content {\n            background-attachment: fixed;\n            height: 400px;\n        }\n        #content1 {\n            background-image: url(\"..\");\n        }\n        #content2 {\n            background-image: url(\"..\");\n        }\n        #content3 {\n            background-image: url(\"..\");\n        }\n        #content4 {\n            background-image: url(\"..\");\n        }\n        #content5 {\n            background-image: url(\"..\");\n        }\n        #content6 {\n            background-image: url(\"..\");\n        }\n    ~~~\n    + js初始化\n    ~~~javascript\n        $.stellar({\n            horizontalScrolling: false,\n            responsive: true\n        });\n    ~~~\n    ### 参数解释\n\n| 名称                                      | 说明                                       |\n| --------------------------------------- | ---------------------------------------- |\n| horizontalScrolling 和 verticalScrolling | 该配置项用来设置视差效果的方向。horizontalScrolling设置水平方向，verticalScro设置垂直方向， 为布尔值，默认为true |\n| responsive                              | 该配置项用来制定load或者resize时间触发时是否刷新页面，其值为布尔值，默认为false |\n| hideDistantElements                     | 该配置项用来设置移出视线的元素是否隐藏，其值为布尔值，若不想隐藏则设置为false |\n| data-stellar-ratio=\"2\"                  | 定义了此元素针对页面滚动的速度比率，比如，0.5为页面滚动的50%，2为页面滚动的200%，所以数值越大，你可以看到页面元素滚动速度越快。 |\n| data-stellar-background-ratio           | 该配置项用在单个元素中，其值为一个正数，用来改变被设置元素的影响速度。 例如 值为0.3时，则表示背景的滚动速度为正常滚动速度的0.3倍。如果值为小数时最好在样式表中设置 |\n\n## 总结\n\n多层次的元素进行不同程度的移动，视觉上形成立体运动效果的网页展示技术","tags":["H5C3"]},{"title":"12-拖拽上传","url":"%2F2017%2F05%2F21%2FH5C3%2F12-%E6%8B%96%E6%8B%BD%E4%B8%8A%E4%BC%A0%2F","content":"# 拖拽上传\n\n## 目标\n\n- 掌握并使用拖拽事件\n- 结合拖拽事件完成拖拽上传\n\n## 知识内容\n\n### 拖拽事件\n+ 拖拽元素\n   - ondrag \t应用于拖拽元素，整个拖拽过程都会调用\n    - ondragstart应用于拖拽元素，当拖拽开始时调用\n    - ondragleave应用于拖拽元素，当鼠标离开拖拽元素时调用\n    - ondragend应用于拖拽元素，当拖拽结束时调用\n+ 目标元素\n   - ondragenter应用于目标元素，当拖拽元素进入时调用\n    - ondragover应用于目标元素，当停留在目标元素上时调用\n    - ondrop应用于目标元素，当在目标元素上松开鼠标时调用\n    - ondragleave应用于目标元素，当鼠标离开目标元素时调用\n\n### 拖拽上传\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        .box {\n            width: 200px;\n            height: 200px;\n            border: 1px dashed #ccc;\n            line-height: 200px;\n            text-align: center;\n            color: #ccc;\n        }\n    </style>\n</head>\n<body>\n<div class=\"box\">拖放图片到该区域</div>\n<script>\n    var box = document.querySelector('.box');\n    box.addEventListener('dragenter', function (e) {\n        /*禁用浏览器默认预览文件或下载文件操作*/\n        e.preventDefault();\n    });\n    box.addEventListener('dragover', function (e) {\n        /*禁用浏览器默认预览文件或下载文件操作*/\n        e.preventDefault();\n    });\n    box.addEventListener('drop', function (e) {\n        e.preventDefault();\n        /*第一个文件数据*/\n        var file = e.dataTransfer.files[0];\n        //console.log(file);\n        /*把数据设置到表单数据中*/\n        var formData = new FormData();\n        formData.append('dragImage', file);\n        /*通过ajax异步提交*/\n        var xhr = new XMLHttpRequest();\n        xhr.open('post','upload.php');\n        xhr.send(formData);\n        xhr.onreadystatechange = function () {\n            if(xhr.readyState == 4 && xhr.status == 200){\n                /*上传成功*/\n                console.log('ok');\n                var img = new Image();\n                img.src = xhr.responseText;\n                document.querySelector('body').appendChild(img);\n            }\n        }\n    });\n</script>\n</body>\n</html>\n```\n\n\n\n## 总结\n\n在支持H5的浏览器中可使用拖拽上传","tags":["H5C3"]},{"title":"11-离线缓存","url":"%2F2017%2F05%2F20%2FH5C3%2F11-%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%2F","content":"# 离线缓存\n\n## 目标\n- 理解构建离线应用\n\n## 知识内容\n\n### 离线缓存使用  \n- 关联缓存清单\n    ```html\n      <html manifest=\"demo.appcache\"></html>\n    ```\n- 配置缓存清单\n    ```\n    CACHE MANIFEST\n\n    CACHE:\n\n    #此部分写需要缓存的资源 （#是注释的意思）\n\n    ./images/img1.jpg\n    ./images/img2.jpg\n    ./images/img3.jpg\n    ./images/img4.jpg\n    ./images/img5.jpg\n\n    NETWORK:\n\n    #此部分要写需要有网络才可访问的资源，无网络刚不访问\n\n    ./js/main.js\n\n    *\n\n    FALLBACK:\n\n    #当访问不到某个资源的情况下，自动由另一个资源替换\n\n    ./css/online.css ./css/offline.css\n\n    ./online.html ./offline.html\n    ```\n\n\n    ​```\n### 优势\n- 1、可配置需要缓存的资源\n- 2、网络无连接应用仍可用\n- 3、本地读取缓存资源，提升访问速度，增强用户体验\n- 4、减少请求，缓解服务器负担\n\n### 缓存清单\n- 一个普通文本文件，其中列出了浏览器应缓存以供离线访问的资源，推荐使用.appcache为后缀名\n- 例如我们创建了一个名为demo.appcache的文件，然后在需要应用缓存在页面的根元素(html)添加属性manifest=\"demo.appcache\"，路径要保证正确。\n\n### manifest文件格式\n- 1、顶行写CACHE MANIFEST\n- 2、CACHE: 换行 指定我们需要缓存的静态资源，如.css、image、js等\n- 3、NETWORK: 换行 指定需要在线访问的资源，可使用通配符\n- 4、FALLBACK: 换行 当被缓存的文件找不到时的备用资源\n\n### 其它\n- 1、CACHE: 可以省略，这种情况下将需要缓存的资源写在CACHE MANIFEST\n- 2、可以指定多个CACHE: NETWORK: FALLBACK:，无顺序限制\n- 3、#表示注释，只有当demo.appcache文件内容发生改变时或者手动清除缓存后，才会重新缓存。\n- 4、chrome 可以通过chrome://appcache-internals/工具和离线（offline）模式来调试管理应用缓存\n\n## 总结\n\nHTML5中我们可以轻松的构建一个离线（无网络状态）应用，只需要创建一个manifest文件。","tags":["H5C3"]},{"title":"10-本地存储","url":"%2F2017%2F05%2F19%2FH5C3%2F10-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F","content":"\n# 本地存储\n\n## 目标\n\n- 掌握客户端存储技术\n- 应用本地存储在开发中\n\n## 知识内容\n\n### document.cookie\n\n使用：\n~~~\n1. 设置cookie数据：document.cookie = '键=值;Expires=日期'\n2. 获取cookie数据：document.cookie\n~~~\n\n1、如果没有设置有效期，会话结束就失效\n2、如果设置有效期，依据有效期时间失效\n3、在会话过程中，每次请求在报文的头部会携带cookie信息\n\n###  window.sessionStorage\n\n使用：\n~~~\n1.获取sessionStorage的长度：window.sessionStorage.length\n2.根据对应的索引去获取对应sessionStorage的key的值：window.sessionStorage.key(索引);\n3.添加/编辑sessionStorage的内容：window.sessionStorage.setItem(键,值);\n4.根据对应的key获取对应的的value：window.sessionStorage.getItem(键);\n5.根据对应的key删除记录：window.sessionStorage.removeItem(键);\n6.清空存储：window.sessionStorage.clear();\n~~~\n\n1、生命周期为关闭浏览器窗口  \n2、在同一个窗口(页面)下数据可以共享\n\n###  window.localStorage\n\n使用：\n~~~\n1.获取localStorage的长度：window.localStorage.length\n2.根据对应的索引去获取对应localStorage的key的值：window.localStorage.key(索引);\n3.添加/编辑localStorage的内容：window.localStorage.setItem(键,值);\n4.根据对应的key获取对应的的value：window.localStorage.getItem(键);\n5.根据对应的key删除记录：window.localStorage.removeItem(键);\n6.清空存储：window.localStorage.clear();\n~~~\n\n1、永久生效，除非手动删除 关闭页面也会存在  \n2、可以多窗口（页面）共享（同一浏览器可以共享）\n\n## 总结\n\n| 特性     | cookie                                   | sessionStorage                          | localStorage   |\n| ------ | ---------------------------------------- | --------------------------------------- | -------------- |\n| 数据生命期  | 默认关闭浏览器失效                                | 页面会话期间可用                                | 除非数据被清除，否则一直存在 |\n| 存放数据大小 | 4K左右（因为每次http请求都会携带cookie）               | 一般5M或更大                                 | 约20M           |\n| 与服务器通信 | 由对服务器的请求来传递，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 数据不是由每个服务器请求传递的，而是只有在请求时使用数据，不参与和服务器的通信 |                |\n| 易用性    | cookie需要自己封装setCookie，getCookie          | 可以用源生接口                                 |                |\n| 共同点    | 都是保存在浏览器端，和服务器端的session机制不同              |                                         |                |","tags":["H5C3"]},{"title":"09-历史浏览记录","url":"%2F2017%2F05%2F19%2FH5C3%2F09-%E5%8E%86%E5%8F%B2%E6%B5%8F%E8%A7%88%E8%AE%B0%E5%BD%95%2F","content":"# history\n\n## 目标\n\n- 掌握新增API的使用\n- 理解在单页面应用程序的使用\n\n## 知识内容\n\n### 解释API\n\n- `pushState(data, title, url)` 追加一条历史记录  \n    + data用于存储自定义数据，通常设为null\n\n      + title历史记录标题，基本上没有被支持，一般设为空\n\n      ​+ url 以当前域为基础增加一条历史记录，不可跨域设置\n\n- `replaceState(data, title, url)` 与pushState()基本相同，\n  不同之处在于replaceState()，只是替换当前url，不会增加/减少历史记录。\n\n- `popstate`事件，当前进或后退时则触发  \n\n### 应用场景\n\n- 在单页面应用程序中，改变地址栏，不发生跳转，使用异步更新网页局部内容\n- 在单页面应用程序中，回退前进历史的时候，更新网页局部内容\n- 常用在对用户体验性能要求较高，有需要去满足SEO的网站\n\n\n\n## 总结\n\n在淘宝的搜索页使用这个技术 ，很好的提高了用户体验","tags":["H5C3"]},{"title":"08-自定义播放器","url":"%2F2017%2F05%2F19%2FH5C3%2F08-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%92%AD%E6%94%BE%E5%99%A8%2F","content":"\n# 自定义播放器\n\n## 目标\n\n- 独立完成自定义播放器处理浏览器表现不一致问题\n- 独立查找API完成自定义播放器功能\n\n## 知识内容\n\n### api\n\n> 音频和视频API一致\n\n方法\n\n| 方法             | 描述                   |\n| -------------- | -------------------- |\n| addTextTrack() | 向音频/视频添加新的文本轨道       |\n| canPlayType()  | 检测浏览器是否能播放指定的音频/视频类型 |\n| load()         | 重新加载音频/视频元素          |\n| play()         | 开始播放音频/视频            |\n| pause()        | 暂停当前播放的音频/视频         |\n\n\n属性\n\n\n| 属性                  | 描述                                   |\n| ------------------- | ------------------------------------ |\n| audioTracks         | 返回表示可用音轨的 AudioTrackList 对象          |\n| autoplay            | 设置或返回是否在加载完成后随即播放音频/视频               |\n| buffered            | 返回表示音频/视频已缓冲部分的 TimeRanges 对象        |\n| controller          | 返回表示音频/视频当前媒体控制器的 MediaController 对象 |\n| controls            | 设置或返回音频/视频是否显示控件（比如播放/暂停等）           |\n| crossOrigin         | 设置或返回音频/视频的 CORS 设置                  |\n| currentSrc          | 返回当前音频/视频的 URL                       |\n| currentTime         | 设置或返回音频/视频中的当前播放位置（以秒计）              |\n| defaultMuted        | 设置或返回音频/视频默认是否静音                     |\n| defaultPlaybackRate | 设置或返回音频/视频的默认播放速度                    |\n| duration            | 返回当前音频/视频的长度（以秒计）                    |\n| ended               | 返回音频/视频的播放是否已结束                      |\n| error               | 返回表示音频/视频错误状态的 MediaError 对象         |\n| loop                | 设置或返回音频/视频是否应在结束时重新播放                |\n| mediaGroup          | 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素）       |\n| muted               | 设置或返回音频/视频是否静音                       |\n| networkState        | 返回音频/视频的当前网络状态                       |\n| paused              | 设置或返回音频/视频是否暂停                       |\n| playbackRate        | 设置或返回音频/视频播放的速度                      |\n| played              | 返回表示音频/视频已播放部分的 TimeRanges 对象        |\n| preload             | 设置或返回音频/视频是否应该在页面加载后进行加载             |\n| readyState          | 返回音频/视频当前的就绪状态                       |\n| seekable            | 返回表示音频/视频可寻址部分的 TimeRanges 对象        |\n| seeking             | 返回用户是否正在音频/视频中进行查找                   |\n| src                 | 设置或返回音频/视频元素的当前来源                    |\n| startDate           | 返回表示当前时间偏移的 Date 对象                  |\n| textTracks          | 返回表示可用文本轨道的 TextTrackList 对象         |\n| videoTracks         | 返回表示可用视频轨道的 VideoTrackList 对象        |\n| volume              | 设置或返回音频/视频的音量                        |\n\n事件\n\n| 事件             | 描述                     |\n| -------------- | ---------------------- |\n| abort          | 当音频/视频的加载已放弃时          |\n| canplay        | 当浏览器可以播放音频/视频时         |\n| canplaythrough | 当浏览器可在不因缓冲而停顿的情况下进行播放时 |\n| durationchange | 当音频/视频的时长已更改时          |\n| emptied        | 当目前的播放列表为空时            |\n| ended          | 当目前的播放列表已结束时           |\n| error          | 当在音频/视频加载期间发生错误时       |\n| loadeddata     | 当浏览器已加载音频/视频的当前帧时      |\n| loadedmetadata | 当浏览器已加载音频/视频的元数据时      |\n| loadstart      | 当浏览器开始查找音频/视频时         |\n| pause          | 当音频/视频已暂停时             |\n| play           | 当音频/视频已开始或不再暂停时        |\n| playing        | 当音频/视频在已因缓冲而暂停或停止后已就绪时 |\n| progress       | 当浏览器正在下载音频/视频时         |\n| ratechange     | 当音频/视频的播放速度已更改时        |\n| seeked         | 当用户已移动/跳跃到音频/视频中的新位置时  |\n| seeking        | 当用户开始移动/跳跃到音频/视频中的新位置时 |\n| stalled        | 当浏览器尝试获取媒体数据，但数据不可用时   |\n| suspend        | 当浏览器刻意不获取媒体数据时         |\n| timeupdate     | 当目前的播放位置已更改时           |\n| volumechange   | 当音量已更改时                |\n| waiting        | 当视频由于需要缓冲下一帧而停止        |\n\n\n\n### 细节注意\n\n```css\n/*全屏操作后  自带的控制栏会显示  在显示的时候隐藏*/\nvideo::-webkit-media-controls {\n    display: none !important;\n}\n.controls {\n    width: 700px;\n    height: 40px;\n    background-color: rgba(255, 255, 255, 0.2);\n    border-radius: 4px;\n    position: absolute;\n    left: 50%;\n    margin-left: -350px;\n    bottom: 5px;\n    /*比全屏的状态下的视频元素高*/\n    z-index: 100000000000;\n    opacity: 1;\n}\n```\n\n\n\n## 总结\n\n需求驱动开发者使用什么API","tags":["H5C3"]},{"title":"07-全屏操作","url":"%2F2017%2F05%2F18%2FH5C3%2F07-%E5%85%A8%E5%B1%8F%E6%93%8D%E4%BD%9C%2F","content":"# 全屏操作\n\n## 目标\n\n- 完成元素的全屏和取消全屏操作\n- 理解私有前缀处理兼容问题\n\n## 知识内容\n\n### 全屏操作API\n\n- `Node.requestFullScreen()` 开启全屏显示\n- `Node.cancelFullScreen()` 关闭全屏显示\n\n> 注意：`cancelFullScreen()` 的调用时`document`\n\n### h5的api兼容问题\n\n- 由于其兼容性原因，不同浏览器需要添加前缀如：\n  webkit内核浏览器：webkitRequestFullScreen、webkitCancelFullScreen，如chrome浏览器。\n  Gecko内核浏览器：mozRequestFullScreen、mozCancelFullScreen，如火狐浏览器。\n- document.isFullScreen检测当前是否处于全屏\n  不同浏览器需要添加前缀\n  document.webkitIsFullScreen、document.mozIsFullScreen\n\n\n\n## 总结\n\n能够使用全屏操作  但是要注意 浏览器兼容问题\n\n","tags":["H5C3"]},{"title":"06-dom扩展","url":"%2F2017%2F05%2F18%2FH5C3%2F06-dom%E6%89%A9%E5%B1%95%2F","content":"# dom扩展\n\n## 目标\n\n- 能够使用H5扩展API完成页面效果\n\n## 扩展内容\n\n### 获取元素\n\n~~~javascript\ndocument.getElementsByClassName ('class'); \n//通过类名获取元素，以伪数组形式存在。\n\ndocument.querySelector('selector');\n//通过CSS选择器获取元素，符合匹配条件的第1个元素。\n\ndocument.querySelectorAll('selector'); \n//通过CSS选择器获取元素，以伪数组形式存在。\n~~~\n\n### 类名操作\n\n~~~javascript\nNode.classList.add('class'); \n//添加class\n\nNode.classList.remove('class'); \n//移除class\n\nNode.classList.toggle('class'); \n//切换class，有则移除，无则添加\n\nNode.classList.contains('class'); \n//检测是否存在class\n~~~\n\n### 自定义属性\n\n> 在HTML5中我们可以自定义属性，其格式如下data-*=\"\"\n\n~~~html\n\n<div id=\"demo\" data-my-name=\"itcast\" data-age=\"10\">\n<!--1. 大家理解的自定义属性：自己定义的属性-->\n<!--2. 非标准属性：就是自定义属性-->\n<!--3. 像：name class id title alt 标准属性  反之 非标准-->\n\n<!--H5规范 用来存储数据的属性 -->\n<!--4. 以 data- 开始的属性认为是自定义属性 -->\n<!--5. 操作自定义属性注意些：-->\n<!--6. dataset对象 指定的是当前dom元素上的自定义属性的集合 -->\n<!--7. 获取自定义属性：dataset.属性名称 dataset[属性名称] -->\n<!--8. 设置自定义属性： dataset.属性名称 = 属性值   dataset[属性名称] = 属性值 -->\n<!--9. 自定义属性的名称遵从驼峰命名 -->\n<!--10. dom上的属性的定义 不支持大写 写了也转换成小写-->\n<script>\n/*\n  Node.dataset是以对象形式存在的，当我们为同一个DOM节点指定了多个自定义属性时，\n  Node.dataset则存储了所有的自定义属性的值。\n  */\nvar demo = document.querySelector(反馈);\n//获取\n//注：当我们如下格式设置时，则需要以驼峰格式才能正确获取\nvar name = demo.dataset['myName'];\nvar age = demo.dataset['age'];\n//设置\ndemo.dataset['name'] = 'web developer';\n<script/>\n~~~\n## 总结\n\n在不使用第三方库的情况下，使用最便捷的方式操作DOM，完成页面效果","tags":["H5C3"]},{"title":"05-fullpage","url":"%2F2017%2F05%2F17%2FH5C3%2F05-fullpage%2F","content":"\n# 全屏切换\n\n## 目标\n\n- 掌握fullpage的使用完成全屏切换效果\n\n## fullpage插件\n\n### 简单介绍\n\n+ 基于 jQuery 的插件，它能够帮你很方便、很轻松的制作出全屏网站。\n+ 支持鼠标滚动，支持前进后退和键盘控制，多个回调函数，\n  支持手机、平板触摸事件，支持 CSS3 动画，支持窗口缩放，窗口缩放时自动调整，\n  可设置滚动宽度、背景颜色、滚动速度、循环选项、回调、文本对齐方式等等。\n+ 参考文档：http://www.dowebok.com/demo/2014/77/\n\n### 使用步骤\n\n+ 引用文件\n    ~~~html\n        <link rel=\"stylesheet\" href=\"css/jquery.fullPage.css\">\n        <script src=\"js/jquery.min.js\"></script>\n        <script src=\"js/jquery.fullPage.js\"></script>\n    ~~~\n    + html结构\n    ~~~html\n    <div id=\"fullpage\">\n        <div class=\"section\">第一屏</div>\n        <div class=\"section\">第二屏</div>\n        <div class=\"section\">\n            <div class=\"slide\">第三屏的第一屏</div>\n            <div class=\"slide\">第三屏的第二屏</div>\n            <div class=\"slide\">第三屏的第三屏</div>\n            <div class=\"slide\">第三屏的第四屏</div>\n        </div>\n        <div class=\"section\">第四屏</div>\n    </div>\n    ~~~\n    + js初始化\n    ~~~javascript\n    $(function(){\n        $('#fullpage').fullpage();\n    });\n    ~~~\n\n### 参考api\n\n- 配置\n\n| 选项                                | 类型   | 默认值         | 说明                                   |\n| --------------------------------- | ---- | ----------- | ------------------------------------ |\n| verticalCentered                  | 字符串  | true        | 内容是否垂直居中                             |\n| resize                            | 布尔值  | false       | 字体是否随着窗口缩放而缩放                        |\n| slidesColor                       | 数组   | 无           | 设置背景颜色                               |\n| sectionsColor                     | 数组   | 无           | 设置背景颜色                               |\n| anchors                           | 数组   | 无           | 定义锚链接                                |\n| scrollingSpeed                    | 整数   | 700         | 滚动速度，单位为毫秒                           |\n| easing                            | 字符串  | easeInQuart | 滚动动画方式                               |\n| menu                              | 布尔值  | false       | 绑定菜单，设定的相关属性与 anchors 的值对应后，菜单可以控制滚动 |\n| navigation                        | 布尔值  | false       | 是否显示项目导航                             |\n| navigationPosition                | 字符串  | right       | 项目导航的位置，可选 left 或 right              |\n| navigationColor                   | 字符串  | #000        | 项目导航的颜色                              |\n| navigationTooltips                | 数组   | 空           | 项目导航的 tip                            |\n| slidesNavigation                  | 布尔值  | false       | 是否显示左右滑块的项目导航                        |\n| slidesNavPosition                 | 字符串  | bottom      | 左右滑块的项目导航的位置，可选 top 或 bottom         |\n| controlArrowColor                 | 字符串  | #fff        | 左右滑块的箭头的背景颜色                         |\n| loopBottom                        | 布尔值  | false       | 滚动到最底部后是否滚回顶部                        |\n| loopTop                           | 布尔值  | false       | 滚动到最顶部后是否滚底部                         |\n| loopHorizontal                    | 布尔值  | true        | 左右滑块是否循环滑动                           |\n| autoScrolling                     | 布尔值  | true        | 是否使用插件的滚动方式，如果选择 false，则会出现浏览器自带的滚动条 |\n| scrollOverflow                    | 布尔值  | false       | 内容超过满屏后是否显示滚动条                       |\n| css3                              | 布尔值  | false       | 是否使用 CSS3 transforms 滚动              |\n| paddingTop                        | 字符串  | 0           | 与顶部的距离                               |\n| paddingBottom                     | 字符串  | 0           | 与底部距离                                |\n| fixedElements                     | 字符串  | 无           |                                      |\n| normalScrollElements              |      | 无           |                                      |\n| keyboardScrolling                 | 布尔值  | true        | 是否使用键盘方向键导航                          |\n| touchSensitivity                  | 整数   | 5           |                                      |\n| continuousVertical                | 布尔值  | false       | 是否循环滚动，与 loopTop 及 loopBottom 不兼容    |\n| animateAnchor                     | 布尔值  | true        |                                      |\n| normalScrollElementTouchThreshold | 整数   | 5           | -                                    |\n\n- 方法\n\n| 名称                     | 说明                      |\n| ---------------------- | ----------------------- |\n| moveSectionUp()        | 向上滚动                    |\n| moveSectionDown()      | 向下滚动                    |\n| moveTo(section, slide) | 滚动到                     |\n| moveSlideRight()       | slide 向右滚动              |\n| moveSlideLeft()        | slide 向左滚动              |\n| setAutoScrolling()     | 设置页面滚动方式，设置为 true 时自动滚动 |\n| setAllowScrolling()    | 添加或删除鼠标滚轮/触控板控制         |\n| setKeyboardScrolling() | 添加或删除键盘方向键控制            |\n| setScrollingSpeed()    | 定义以毫秒为单位的滚动速度           |\n\n- 回调函数\n\n| 名称             | 说明                                       |\n| -------------- | ---------------------------------------- |\n| afterLoad      | 滚动到某一屏后的回调函数，接收 anchorLink 和 index 两个参数，anchorLink 是锚链接的名称，index 是序号，从1开始计算 |\n| onLeave        | 滚动前的回调函数，接收 index、nextIndex 和 direction 3个参数：index 是离开的“页面”的序号，从1开始计算；nextIndex 是滚动到的“页面”的序号，从1开始计算；direction 判断往上滚动还是往下滚动，值是 up 或 down。 |\n| afterRender    | 页面结构生成后的回调函数，或者说页面初始化完成后的回调函数            |\n| afterSlideLoad | 滚动到某一水平滑块后的回调函数，与 afterLoad 类似，接收 anchorLink、index、slideIndex、direction 4个参数 |\n| onSlideLeave   | 某一水平滑块滚动前的回调函数，与 onLeave 类似，接收 anchorLink、index、slideIndex、direction 4个参数 |\n\n\n\n","tags":["H5C3"]},{"title":"04-边框图片","url":"%2F2017%2F05%2F16%2FH5C3%2F04-%E8%BE%B9%E6%A1%86%E5%9B%BE%E7%89%87%2F","content":"\n# 边框图片\n\n## 目标\n\n- 扩展知识增加一下知识面\n\n\n### 原理\n\nborder-image\n\n设置的图片将会被“切割”成九宫格形式，然后进行设置。如下图\n\n![img](/images/H5C3/4.png)\n\n“切割”完成后生成虚拟的9块图形，然后按对应位置设置背景，\n\n其中四个角位置、形状保持不变，中心位置水平垂直两个方向平铺。如下图\n\n![img](/images/H5C3/6.png) \n\n**1、round和repeat之间的区别******\n\nround 会自动调整尺寸，完整显示边框图片。\n\n![img](/images/H5C3/7.png) \n\nrepeat 单纯平铺多余部分，会被“裁切”而不能完整显示。\n\n![img](/images/H5C3/8.png) \n\n**2、更改裁切尺寸******\n\nborder-image-slice: 34 36 27 27 分别设置裁切如下图\n\n![img](/images/H5C3/9.png) \n\n![img](/images/H5C3/10.png) \n\n## 属性\n\n- `border-image-source`  图片地址\n- `border-image-slice` 图片裁剪尺寸\n- `border-image-width` 边框的宽度\n- `border-image-repeat` 平铺方式  `stretch` `round` `repeat`\n\n\n\n## 总结\n\n 关于边框图片重点理解9宫格的裁切及平铺方式，实际开发中应用不广泛，但是如能灵活动用会给我们带来不少便利。","tags":["H5C3"]},{"title":"03-3D转换","url":"%2F2017%2F05%2F16%2FH5C3%2F03-3d%E8%BD%AC%E6%8D%A2%2F","content":"\n\n# 3D转换\n\n## 目标\n\n- 掌握使用CSS完成一些3d效果\n- 理解在网页平面内的3d效果\n\n## 怎么在网页平面产生3d效果 \n\n- 我们生活的环境是3d的，照片就是3d物体在2d平面呈现的例子\n- 有什么特点：\n  + 近大远小\n  + 物体后面遮挡不可见\n- 当我们在网页上构建3d效果的时候参考这些特点就能产出3d效果\n- 在现实生活当中 我们通过肉眼去物体的时候和照片的成像是相同的\n- 如果想要在网页产生3d效果需要透视（理解成3d物体投影在2d平面内）\n\n## 透视和视距\n\n\n\n- 透视（perspective）\n    + 在2d平面产生近大远小视觉立体，但是只是效果二维的\n\n    + 原理：  \n     ![](/images/H5C3/01.png)\n\n      a. 模拟人类的视觉位置，可认为安排一只眼睛去看  \n      b. 距离电脑平面的距离为视距  \n      c. 距离视觉点越近的在电脑平面成像越大，越远成像越远  \n\n    + 特点：只是显示3d图像的近大远小效果，无法呈现3d的三维成像的特点，如遮挡\n\n    + 使用场景：只是辅助性的帮助开发者检查3d效果\n\n    ​\n\n\n## 3d转换\n\n- `translateX`  x轴方向的位移\n- `translateY`  y轴方向的位移\n- `translateZ ` z轴方向的位移\n- `rotateX` 绕x轴旋转\n- `rotateY` 绕y轴旋转\n- `rotateZ` 绕z轴旋转 \n\n## 3d呈现\n\n+ 3d呈现（transfrom-style）\n  + 在2d平面产生近大远小视觉立体，但是只是效果二维的\n  + 原理：  \n    <img src=\"media/02.png\"></img> <img src=\"media/03.png\"></img>   \n    a. 第一张图是没有使用3d呈现的  无3d效果\n    b. 第二张图是使用了3d呈现的  出现遮挡三维立体效果\n  + 特点：真正意义的3d呈现，三维立体,有遮挡\n  + 使用场景：在3d立体图形的构建使用\n\n## 综合案例\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        .box{\n            width: 200px;\n            height: 200px;\n            position: relative;\n            margin: 100px auto;\n            /*辅助3d效果开发  视觉效果 */\n            /*透视：理解成在屏幕外面安排一只眼睛帮我们开3d效果*/\n            /* 形成近大远小 效果  */\n            /*perspective: 300px;*/\n\n            /*真正意义的3D呈现 */\n            transform-style: preserve-3d;\n\n            transform: rotateX(30deg) rotateY(-30deg);\n\n            animation: rotate 4s linear infinite;\n\n        }\n        .box > div{\n            width: 100%;\n            height: 100%;\n            position: absolute;\n            left: 0;\n            top: 0;\n            text-align: center;\n            line-height: 200px;\n            font-size: 20px;\n            opacity: 0.4;\n        }\n        .box .front{\n            background: red;\n            transform: translateZ(100px);\n        }\n        .box .back{\n            background: blue;\n            transform: rotateY(-180deg) translateZ(100px);\n        }\n        .box .left{\n            background: green;\n            transform: rotateY(-90deg) translateZ(100px);\n        }\n        .box .right{\n            background: yellow;\n            transform: rotateY(-270deg) translateZ(100px);\n        }\n        .box .top{\n            background: pink;\n            transform: rotateX(90deg) translateZ(100px);\n        }\n        .box .bottom{\n            background: hotpink;\n            transform: rotateX(-90deg) translateZ(100px);\n        }\n        /* 立方体的中心在电脑平面上  */\n        /* 当你选择过后正面朝外 Z正方向也是朝外 */\n\n        @keyframes rotate {\n            from{\n\n            }\n            to{\n                transform: rotateX(30deg) rotateY(-390deg);\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"box\">\n        <div class=\"front\">front</div>\n        <div class=\"back\">back</div>\n        <div class=\"left\">left</div>\n        <div class=\"right\">right</div>\n        <div class=\"top\">top</div>\n        <div class=\"bottom\">bottom</div>\n    </div>\n</body>\n</html>\n```\n\n\n\n## 总结\n\n- 怎么在2d的网页体现3d效果\n  - 拍照片  物体 呈现 近大远小\n  - 在网页 也可以安排一只虚拟的眼睛  帮我们去观察 立体的物体\n- 透视\n  - perspective:100px;\n  - 视距  距离越近 近大远小的效果 越明显\n  - 作用：辅助观察3d效果，不能真正的呈现3d\n- 3d转换\n  - rotateX\n  - rotateY\n  - rotateZ\n  - translateX\n  - translateY\n  - translateZ","tags":["H5C3"]},{"title":"02-选择器","url":"%2F2017%2F05%2F15%2FH5C3%2F02-%E9%80%89%E6%8B%A9%E5%99%A8%2F","content":"\n# 选择器\n\n### 属性选择器 \n\n- `E[attr=value]` 选中E元素中属性有attr的且属性值为value的元素 \n- `E[attr^=value]` 选中E元素中属性有attr的且属性值以value开头的元素 \n- `E[attr$=value]` 选中E元素中属性有attr的且属性值以value结尾的元素 \n- `E[attr*=value]` 选中E元素中属性有attr的且属性值包含value的元素 \n\n### 伪类选择器\n\n- `E:first-child` 选中E元素的父元素下所有的子元素的第一个元素，如果类型为E选中否则无效\n- `E:last-child` 选中E元素的父元素下所有的子元素的最后一个元素，如果类型为E选中否则无效\n- `E:nth-child(n)` 选中E元素的父元素下所有的子元素的第n个元素，如果类型为E选中否则无效\n- `E:nth-last-child(n)` 选中E元素的父元素下所有的子元素的倒数第n个元素，如果类型为E选中否则无效\n\n### 伪元素选择器\n\n- `E::before` 选中E元素的内容前伪元素 \n- `E::after `  选中E元素的内容前伪元素 \n\n\n\n\n\n","tags":["H5C3"]},{"title":"01-关于H5开发","url":"%2F2017%2F05%2F15%2FH5C3%2F01-%E5%85%B3%E4%BA%8EH5%E5%BC%80%E5%8F%91%2F","content":"\n# 关于H5开发\n\n## 目标\n\n- 作为前端开发人员应该怎么去理解H5开发\n- 不能单纯认为H5仅仅只是H4的下一个版本\n\n## 个人愚见 \n\n### HTML4.0.1\n\n1. html是HyperText Markup Language `超文本标记语言`的缩写，是一款描述网页的标记语言。\n2. HTML4.0.1简单的讲就是html的一个版，1999年12月发布的一直沿用至今，但是html5在慢慢代替它。\n3. 总结一下它的作用是语言规范，开发网页用的。\n\n### HTML5\n\n1. 狭义的讲html5的新的一个规范，你可以理解成H5仅仅只是H4的下一个版本。\n2. 但是如果把现在的工作岗位前端-`H5开发工程师`中的H5那就没这么简单了。\n\n### 理解H5开发\n\n1. 在前端领域H5是一个技术集合（技术栈），而不是一个单纯的技术点，所有不能理解为是一个html规范。\n2. 需要从三个方面去梳理一下常见会学习到技术（当然远不止这些）：\n   - html\n     + 语义化标签\n     + 新增表单类型\n     + 新增表单属性\n   - css\n     + 新增选择器\n     + 属性的增强\n     + 过渡\n     + 转换\n     + 动画\n     + 媒体查询\n   - javascript\n     + 新增应用API\n     + canvas绘图\n     + ES6\n3. 还可以从职能去理解H5开发是什么：\n   - 移动web开发\n   - 响应式开发\n   - 单页面应用开发\n   - 混合APP开发\n   - 微信小程序\n   - 微信公众号\n\n### 总结\n\nH5开发泛**指对h5技术栈(html提升，css提升，javascript提升)的综合使用开发网页应用程序**\n\n\n\n\n\n\n\n","tags":["H5C3"]},{"title":"13-Ajax跨域","url":"%2F2017%2F05%2F04%2Fajax%2F13-Ajax%E8%B7%A8%E5%9F%9F%2F","content":"\n# ajax跨域\n\n\n## 什么是ajax跨域\n\n\n简单来说，就是网站A去调用网站B的数据。\n\n常见案例： hao123.com的天气预报。\n\n\n但是Ajax跨域存在一个问题 --- 浏览器的同源策略，该策略会阻止ajax跨域访问\n\n同源策略（Same origin policy）是一种约定，它是浏览器的一种安全功能。 \n\n同源:  同协议，同域名，同端口；   不同源则为跨域\n\n\n![1526464487997](/images/ajax/1526464487997.png)\n\n\n同源限制案例:\n\nwww.study.com/origin/index.html使用ajax，请求www.demo.com/1.php文件中的数据\n\n1) 创建 www.study.com/origin/index.html 文件\n\n\n2) 创建 www.demo.com/1.php\n\n![1535080134040](/images/ajax/1535080134040.png)\n\n访问结果:\n\n 响应主体: \n\n ![1535080192488](/images/ajax/1535080192488.png)\n\n\n  终端：\n\n![1535080232398](/images/ajax/1535080232398.png)\n\n\n看到 Access-Control-Allow-Origin 错误，就说明正在执行跨域请求，请求数据被浏览器的同源策略所阻止。\n\n\n解决跨域问题有三种方式：\n\n- 服务器代理\n- cors （跨域资源共享）\n- jsonp\n\n\n##  代理实现ajax跨域\n\n\n核心思想:  php中有一个函数  **file_get_contents**。 该函数能够获取到其他网站的数据。\n\n  file_get_contents('http://www.baidu.com/index.html');\n\n\n![1526464641537](/images/ajax/1526464641537.png)\n\n案例: \n\nwww.study.com/proxy/index.html发送ajax请求，请求www.study.com/proxy/proxy.php文件\n\nproxy.php文件使用file_get_contents函数读取www.demo.com/1.php文件中的内容，再返回给index.html文件中的ajax请求\n\n1)创建  www.study.com/proxy/index.html\n\n     在该文件中发送ajax请求，请求同服务器(www.study.com)下的 proxy.php文件\n\n![1535080922048](/images/ajax/1535080922048.png)\n\n\n2)创建  www.study.com/proxy/proxy.php \n\n    在该文件中使用 file_get_contents函数，读取远程服务器(www.demo.com)1.php中的内容\n\n\n![1535080953785](/images/ajax/1535080953785.png)\n\n\n3)创建  www.demo.com/1.php\n\n\n![1535080973545](/images/ajax/1535080973545.png)\n\n\n访问结果:\n\n![1535081000932](/images/ajax/1535081000932.png)\n\n\n## cors跨域\n\ncors: 跨域资源共享。\n\n  同源策略是浏览器的策略。但是如果服务器允许其他网站的页面进行跨域访问，那么浏览器就不会对返回的数据进行限制了。\n\n  **核心方法: 在服务器端(PHP文件中)声明不用进行同源限制**\n\n如果设置为 * 则是所有外部网站都可以获取数据\n\nheader('Access-Control-Allow-origin: *'); \n\n只允许www.study.com网站访问并获取数据\n\nheader('Access-Control-Allow-origin: http://www.study.com'); \n\n案例:\n\nwww.study.com/cors/index.html通过cors方式，访问www.demo.com/cors.php文件的数据\t\n\n1)创建 www.study.com/cors/index.html文件 发送ajax请求\n\n![1535082102105](/images/ajax/1535082102105.png)\n\n\n2)创建 www.demo.com/cors.php\n\n![1535082122902](/images/ajax/1535082122902.png)\n\n## jsonp跨域\n\nJSONP(JSON with Padding) : 是一种解决ajax跨域访问的方案。\n\n核心思想:\n\n   浏览器虽然有同源策略，但是 src 和 href 两个属性却可以跨域访问。 可以利用这一“漏洞”发送ajax请求。\n\n案例: \n\nwww.study.com/jsonp/index.html文件中通过script标签的src属性，跨域访问www.demo.com/jsonp.php文件中的数据\n\n1) 创建 www.study.com/json/index.html ,使用 script标签引入了  www.demo.com/jsonp.php文件\n\n\n![1535083081431](/images/ajax/1535083081431.png)\n\n\n2) 创建 www.demo.com/jsonp.php文件 输出个 123\n\n![1535083100372](/images/ajax/1535083100372.png)\n\n访问结果 --- 响应主体，拿到后端的返回值\n\n![1535083123459](/images/ajax/1535083123459.png)\n\n3) 调整后台返回数据的方式 --- 返回了一个 **函数字符串 例如: 'aaa(123)'** \n\n![1535083161188](/images/ajax/1535083161188.png)\n\n访问结果: \n\n![1535083191342](/images/ajax/1535083191342.png)\n\n\n![1535083218087](/images/ajax/1535083218087.png)\n\n4) 在前端页面提前定义好 函数 aaa()\n\n\n![1535083297077](/images/ajax/1535083297077.png)\n\n访问结果 --- 123被输出到终端\n\n![1535083321525](/images/ajax/1535083321525.png)\n\n\n5) 丰富一下后台返回数据的类型\n\n![1535083388289](/images/ajax/1535083388289.png)\n\n访问结果:\n\n![1535083403809](/images/ajax/1535083403809.png)\n\n\n## $.ajax方法跨域操作 --- jsonp方式\n\n        $.post $.get $.ajax都能发送跨域请求。\n        但是，$.post和$.get是要依靠cors方式的，\n        只有$.ajax能使用jsonp方式\n\n核心: \n\n        必须设置请求类型为get ---  type: ‘get’\n        必须设置dataType为jsonp --- dataType: ‘jsonp’\n        必须额外设置一个jsonp参数，该参数值可以是任何英文字符串，常用callback。 jsonp: 'callback'\n            该参数会产生一个随机字符串\n            前端使用该字符串创建一个函数\n            后端接收该字符串作为返回函数的名称\n\n\n\n示例:\n\n1) 使用jsonp发送跨域请求\n\n\n        $.ajax({\n            url: 'http://www.study.com/test/3.php',\n            type: 'get',   \n            dataType: 'jsonp',   \n            jsonp: 'callback',  //解决前后端函数名统一的问题   \n            success: function(msg){\n                alert(msg);\n                alert(msg.name);\n            }\n        })\n\n2) 后端拼接函数字符串\n\n        <?php \n        // 函数名\n        $callback = $_GET['callback'];\n        $str = \"$.ajax--->jsonp\";\n        echo $callback . \"('$str')\";\n        ?>\n\n\n案例:\n\nwww.study.com/ajax_jsonp.html 跨域访问www.demo.com/ajax_jsonp.php文件中的内容\n\n1)　创建 www.study.com/ajax_jsonp.html 发送ajax请求\n\n\n![1535084193300](/images/ajax/1535084193300.png)\n\n\n2)　创建www.demo.com/ajax_jsonp.php 返回数据\n\n![1535084247916](/images/ajax/1535084247916.png)\n\n\n## 调用网上接口 --- 天气预报\n\n网站： www.jisuapi.com\n\n![1531067693123](/images/ajax/1531067693123.png)\n\n\napi说明:\n\n![1531148039369](/images/ajax/1531148039369.png)\n\n\n注册，购买后可在“我的api”中看到\n\n![1531148099461](/images/ajax/1531148099461.png)\n\n\n![1531148202923](/images/ajax/1531148202923.png)\n\n\n1） 发送ajax请求\n\n\n2) 将取得数据筛选后显示到网页上\n","tags":["Ajax"]},{"title":"12-虚拟主机配置","url":"%2F2017%2F05%2F04%2Fajax%2F12-%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%2F","content":"\n# 虚拟主机配置\n\n## 什么是虚拟主机\n\n虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的物理服务器划分成多个“虚拟”服务器，每一个虚拟服务器都能独立运行一个网站\n\n![1524039623401](/images/ajax/1524039623401.png)\n\n## 虚拟主机配置3步骤\n\n目标: 将我们的apache做成虚拟主机，同时支持多个网站。  还可以为每个虚拟主机自定义域名\n\n\nwww.study.com\n\n\n案例: 配置 www.study.com  虚拟主机\n\n1) 修改apache配置文件(httpd.conf)，引入apache的虚拟主机配置文件(httpd-vhost.conf)\n\n     去掉该句前的 # 号\n\n\n![1524039679721](/images/ajax/1524039679721.png)\n\n\n2) 修改虚拟主机配置文件\n\nd:\\phpstudy\\Apache\\conf\\extra\\httpd-vhosts.conf\n\n![1528962401243](/images/ajax/1528962401243.png)\n\n\n3) 修改hosts文件 (使用管理员权限修改)\n\nc:/windows/system32/drivers/etc/hosts\n\n![1528962577565](/images/ajax/1528962577565.png)\n\n在浏览器中输入 www.study.com 就会访问本机的apache服务器\n\n\n\n**重启Apche服务器**\n\n\n注意：  www.study.com 指向  d:/phpstudy/WWW/study 目录\n\n 配置两个域名：  www.study.com   www.demo.com\n\n\n\n## 需要调整_default_不影响打开localhost\n\n![](/images/ajax/localhost.png)\n","tags":["Ajax"]},{"title":"11-ArtTemplate模板引擎","url":"%2F2017%2F05%2F04%2Fajax%2F11-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%2F","content":"\n\n\n# 模板引擎\n\n## 为什么要使用模板引擎\n\n通过搜索用户名案例我们发现，要渲染到网页上的数据是使用js循环拼接字符串，再将拼接好的字符串填入tbody标签中的。\n\n   这种方式可读性差，出错不容易查找。\n\n   模板引擎技术就是为了解决字符串拼接问题的。 ==模板引擎技术本质就是拼接字符串。==\n\n   传统模式有两种拼接显示字符串的方式:\n\n- 在后端程序中拼接好，然后以字符串形式返回\n- 后端程序返回json字符串，前端程序接收了之后，解析json进行拼接\n\n模板引擎方式：\n\n\n模板引擎属于前端程序拼接字符串\n提前定义好要显示格式，所有数据位置以特殊标记表示出来。模板引擎会自动分析，并将数据填写到对应的位置。\n\n我叫__ , 今年__ 岁了\n\n\n\n\n##  常见模板引擎\n\nArtTemplate：https://github.com/aui/artTemplate\n\nvelocity.js：https://github.com/shepherdwind/velocity.js\n\nHandlebars：http://handlebarsjs.com\n\n\n\n\n## artTemplate快速上手\n\n基本使用步骤:\n\n  1) 使用script标签引入arttemplate库文件 (template-web.js)\n\n  2) 定义标签，用来显示最终解析好的模板信息\n\n  3) 定义模板和模板中所需数据。\n\n\n            ① 定义要显示在模板中的数据，必须是 json 对象\n            ② 使用script标签定义模板，type=\"text/template\"  id=\"tpl\"，并且使用 {{}}  将所有数据位置标记出来\n        \n  4) 调用template函数，解析模板，将数据和模板组装到一起\n\n  5) 将解析好的模板字符串填充到事先定义好的标签中(显示到网页上)\n\n\n简单案例：拼接模板字符串 \"我叫张三，今年20岁\"，并输出在网页的div中\n\n模板:   我叫__ , 今年__ 岁了\n\nvar json = {\"name\":\"zs\", \"age\":20};\n\n\n\n① 引入 template-web.js库文件\n\n② 定义标签，用来显示最终解析好的模板信息\n\n③ 定义数据和模板\n\n④ 调用template函数将数据和模板揉到一起\n\n⑤ 将解析好的字符串写入定义好的标签中\n\n\n![1534997889904](/images/ajax/1534997889904.png)\n\n关键点：\n\n1) 在定义模板时使用 script 标签， type=\"text/==template==\"  id=\"tpl\"\n\n2) 定义json对象，json对象中的key一定要和模板中的 {{key}}一致\n\n3) 调用template函数进行解析\n\n        参数1: 模板的id值\n        参数2: json对象\n\n\n## 循环结构  each\n\n关键点: \n\n1) template函数需要的参数是一个json对象，所以需要声明json对象，里面是数组\n\n2) 在定义模板时使用each进行循环\n\n  \n```javascript\n\n  each结构: \n\n   {{each data as value}}\n   \n\t输出内容\n\n  {{/each}}\n\n  data: 要循环的数组\n\n  value: 循环取出的单元值\n\n  注意: 使用 {{/each}} 结束循环\n\n```\n\n\n\n① 使用script标签引入arttemplate库文件 (template-web.js)\n\n② 定义标签，显示最终结果的标签\n\n③ 定义数据和模板\n\n④ 调用template函数，将数组和模板进行解析\n\n⑤ 将解析好的字符串显示到div中\n\n\n![1534998872701](/images/ajax/1534998872701.png)\n\n\n![1534998883342](/images/ajax/1534998883342.png)\n\n\n![1534998890382](/images/ajax/1534998890382.png)\n\n\n```php\nvar  arr= [\n\n\t{\"name\":\"zs\", \"age\":20},\n\n\t{\"name\":\"ls\", \"age\":20},\n\n\t{\"name\":\"ww\", \"age\":20},\n\n]\n\n\nvar arr = [\n\n\t{\"sno\":1, \"sname\":\"aaa\", \"sage\":20, \"sgender\":\"nv\", \"semail\":\"dasdsad@d.acom\", \"stel\":\"12134333\"},\n\n\t{\"sno\":2, \"sname\":\"aaa\", \"sage\":20, \"sgender\":\"nv\", \"semail\":\"dasdsad@d.acom\", \"stel\":\"12134333\"},\n\n\t{\"sno\":3, \"sname\":\"aaa\", \"sage\":20, \"sgender\":\"nv\", \"semail\":\"dasdsad@d.acom\", \"stel\":\"12134333\"},\n\n]\n\n```\n\n\n## 选择结构 --- if else\n\n```php\n\n关键点: 定义模板时使用 \n\n  {{if  判断条件}}\n\n\t程序块1\n\n  {{else}}\n\n\t程序块2\n\n  {{/if}}\n\n```\n\n![1535073931982](/images/ajax/1535073931982.png)\n\n定义数据和模板\n\n\n![1535073949659](/images/ajax/1535073949659.png)\n\n\n![1535073977980](/images/ajax/1535073977980.png)\n\n\n## 使用模板引擎改造搜索用户案例\n\n目标: 使用模板引擎来代替原来的字符串拼接\n\n\n① 引入库文件\n\n② 定义标签，显示最终结果的标签\n\n③ 定义数据和模板\n\n④ 调用template函数\n\n⑤ 将解析好的字符串渲染到tbody中\n\n\n1) 发送ajax请求\n\n![1535075681764](/images/ajax/1535075681764.png)\n\n2) 后端php接收关键词，查询，再将结果返回给前端\n\n3) 前端显示数据 --- 模板引擎\n\n   ① 引入 template-web.js 文件\n\n   ② 定义显示最终结果的标签 -- tbody\n\n   ③ 定义数据和模板\n\n       数据后端返回的 ---  数组，内部是json\n\n       需要包装成json\n\n       定义模板： each循环json中的数组，还可以增加if判断\n\n    ④ 调用template函数组装数据和模板\n\n    ⑤ 将结果显示到 tbody中\n\n  \n\n定义模板:\n\n![1535075924682](/images/ajax/1535075924682.png)\n\n定义数据：\n\n![1535075908069](/images/ajax/1535075908069.png)\n\n\n ## 模板引擎原理简介\n \n\n 核心原理: 使用正则替换模板引擎中的标记\n\n 例如: 我叫{{name}}，今年{{age}}岁\n\n  使用正则表达式找到模板字符串中的{{name}}和{{age}},再用真实的数据进行替换。\n\n 核心方法:  \n\n  ① reg.exec(str);\n\n  reg: 正则表达式\n\n  str:  字符串\n\n  函数作用: 从str字符串中找到复合reg正则表达式的对象，如果没有则返回null\n\n  ② str.replace(str1, str2);\n\n  函数作用: 在str字符串中找到str1字符串，然后用str2字符串进行替换\n\n  例如:\n\n  str = \"abcdefg\";\n\n  str1 = \"bc\";\n\n  str2 = \"zs\";\n\n  console.log(str.replace(str1, str2)); //  azsdefg\n\n  掌控每一步中变量的内容。\n\n\n\n\n\n\n\n","tags":["Ajax"]},{"title":"10-封装方法","url":"%2F2017%2F05%2F03%2Fajax%2F10-%E5%B0%81%E8%A3%85%E6%96%B9%E6%B3%95%2F","content":"\n# 封装方法\n\n从一般到通用。\n\n从一个具体的案例，完善成一个兼容相同功能函数\n\n  1) 编写一个具体案例\n\n  2) 分析其中的缺陷\n\n  3) 完善缺陷\n\n\n## 封装 $.get方法\n\n1) 编写一个具体的案例\n\n   具体案例:  封装一个get方法，能够发送ajax请求，请求1.php文件，并且能接收到1.php的返回数据\n\n  ① 使用原生js完成整个ajax请求过程\n\n  ② 定义$对象，再定义get成员方法\n\n![1534992419884](/images/ajax/1534992419884.png)\n\n**分析具体案例存在的问题，一步一步将存在问题修正，就能够形成一个通用的函数了。**\n\n具体案例存在的问题:\n\n① 在创建XMLHttpRequest对象时，没有处理浏览器兼容性\n\n② 只能访问1.php程序\n\n③ 无法灵活向后台的1.php程序发送参数\n\n④ 前端无法灵活接收后端返回的数据\n\n⑤ 返回值类型单一，只能使用字符串\n\n\n\n2) 处理创建XMLHttpRequest对象时的兼容性问题\n\n\n![1534992805274](/images/ajax/1534992805274.png)\n\n\n3) 处理只能访问1.php文件的文件的问题。\n\n  思路: 定义get函数时设置形参，调用函数时传递实参\n\n① 修改get方法，设置参数1 --- 请求的url地址\n\n![1534992911599](/images/ajax/1534992911599.png)\n\n\n② $调用get方法时，需要传递实参\n\n![1534992931301](/images/ajax/1534992931301.png)\n\n4) 处理请求后台文件时无法发送数据 \n\n  思路: 将js对象组装为字符串，拼接在请求的url地址之后\n\n $.get('1.php', {\"id\":1, \"name\":\"zs\"} , ....)  --> 1.php?id=1&name=zs\n\n 本质: {\"id\":1, \"name\":\"zs\"} ---> id=1&name=zs\n\n \n\n① 封装params方法，将js对象转为字符串\n\n i. 创建了一个test.html页面，用来测试js对象转字符串的方法\n\n\n![1534994041554](/images/ajax/1534994041554.png)\n\n\n ii. 将封装好的函数加入到 $ 对象中\n\n![1534994077331](/images/ajax/1534994077331.png)\n\n\n② 在get方法中定义参数2， 并在get方法中调用params方法，将参数2的js对象转为字符串，将字符串参数拼接到url地址当中\n\n![1534994154741](/images/ajax/1534994154741.png)\n\n5) 处理readyState==4时的回调函数\n\n① 在$.get方法中设置参数3，在方法体中使用函数形式调用，就相当于执行了一个函数\n\n\n![1534994442757](/images/ajax/1534994442757.png)\n\n\n② 在调用$.get方法时，以回调函数形式传入参数3\n\n\n![1534994457054](/images/ajax/1534994457054.png)\n\n\n6) 处理能够接收不同类型的返回值\n\n① 在$.get方法声明时，设置参数4，判断参数4的值，如果是json则进行额外处理\n\n\n![1534994665861](/images/ajax/1534994665861.png)\n\n\n② 在调用$.get方法时，传入参数4\n\n![1534994682446](/images/ajax/1534994682446.png)\n\n\n## 封装 $.post方法\n\n\n 1) 创建post方法，能够发送ajax请求\n\n 2) 处理向后台发送的数据\n\n 3) 处理回调函数和返回值类型\n  \n\n    1) 封装普通的方法\n\n    2) 处理xhr的浏览器兼容性问题\n\n    3) 请求地址参数问题\n\n    4) 让请求能够发送数据\n\n    5) 回调函数\n\n    6) 设置返回值类型\n\n\n![1534996012580](/images/ajax/1534996012580.png)\n\n\n## 封装 $.ajax方法\n\n核心思想:\n\n1) 将发送请求的地址、方式、数据、返回值类型、回调函数都封装到js对象中，然后作为参数传入$.ajax方法中。\n\n2) 在$.ajax方法中区分post和get方式，分别调用get方法和post方法。\n\n\n![1534996412903](/images/ajax/1534996412903.png)\n\n\n![1534996419610](/images/ajax/1534996419610.png)","tags":["Ajax"]},{"title":"09-jQuery提供的Ajax方法","url":"%2F2017%2F05%2F03%2Fajax%2F09-jQuery%E6%8F%90%E4%BE%9B%E7%9A%84Ajax%E6%96%B9%E6%B3%95%2F","content":"\n\n# jQuery提供的Ajax方法\n\n jQuery提供了4个ajax方法:  $.get()  $.post()  $.ajax()  $.getJSON()\n\n 前三个常用\n\n\n## $.get\n\n$.get(var1, var2, var3, var4);\n\n  参数1: 请求的后端程序的地址\n\n  参数2: 要发送到后端程序的数据，json对象/js对象（推荐）或者 字符串\n\n  参数3: 当readyState==4时的触发函数，该函数中有一个参数，就是后端程序返回的数据\n\n  参数4: 设置返回数据的类型:  text(默认)  json     xml\n\n\n案例: 在get.html文件中发送一个ajax请求，去请求后端的get.php页面，同时将id=1数据发送给后端\n\n示例: \n\n```php\n        $.get('get.php', {\"goods_id\":10101, \"_\":Math.random()}, function(msg){\n            alert(msg);\n        }, 'json');\n```\n\n解析:   上面的代码等价于原生js的\n\n```php\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function(){\n            if(xhr.readyState == 4){\n                msg = xhr.responseText;\n                msg = JSON.parse(msg);\n                alert(msg);\n            }\n        }\n        xhr.open('get', 'getData.php?goods_id=10101&_='+Math.random());\n        xhr.send(null);\n\n```\n\n使用jquery提供的ajax方法，就是为了简化开发。\n\n使用 $.get 改造 1.5的搜索案例\n\n1) 表格和文本框一样\n\n\n![1534823217314](/images/ajax/1534823217314.png)\n\n2) $.get发送请求\n\n![1534823247683](/images/ajax/1534823247683.png)\n\n\n## $.post\n\n$.post函数的用法和$.get一模一样，只是发送请求方式变为post\n\n $.post(var1, var2, var3 , var4);    //最标准的写法\n\n  参数1: 请求的后台程序的地址\n\n  参数2: 要发送到后台程序的数据，json对象/js对象（推荐） 或者 字符串\n\n  参数3: 当readyState=4时的触发函数，该函数中有一个参数，就是后台程序返回的数据\n\n  参数4: 设置返回数据的类型:  text(默认)  json     xml\n\n\n示例: \n\n```php\n        $.post('getData.php', {\"goods_id\":10101}, function(msg){\n            alert(msg);\n        }, 'json');\n```\n\n解析:   上面的代码等价于原生js的\n\n```php\n            var xhr = new XMLHttpRequest();\n            xhr.onreadystatechange = function(){\n                if(xhr.readyState == 4){\n                    msg = xhr.responseText;\n                    msg = JSON.parse(msg);\n                    alert(msg);\n                }\n            }\n            xhr.open('post', 'getData.php');\n            var param = 'goods_id=10101';\n            xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded');\n            xhr.send(param);\n```\n\n## 案例 --- 搜索框下拉列表\n\n\n![1524120186289](/images/ajax/1524120186289.png)\n\n数据表设计:\n\n\n![1524127782691](/images/ajax/1524127782691.png)\n\n\nkey_id: 主键\n\nkey_name: 关键词\n\n\n 思路分析:\n\n1. index.html  ---  在搜索框上绑定keyup事件，获取搜索框内容并发送ajax请求\n   1) 在搜索文本框上绑定键盘弹起事件\n   2) 事件函数\n      ① 获取搜索框内容\n      ② 发送ajax请求，等待结果\n\n1. getKeys.php ---  接收关键词，并根据关键词从数据表中查出相关的其他关键词，返回给前端\n   1) 接收关键词\n   2) 编写SQL语句，查询和接收关键词相关的所有关键词\n   3) 将查询结果返回给前端\n\n1. index.html --- 将接收到关键词循环显示到下拉列表（tips）中\n   接收后端返回结果并显示\n   1) 制作下拉列表\n   2) 将后端返回的每条关键词都填充到下拉列表中\n   3) 完善下拉列表\n      ① 每次循环取出关键词时都先创建div，并将关键词放在div中\n      ② 为div绑定鼠标悬浮事件（高亮显示）和鼠标移出事件（取消高亮显示）\n      ③ 为div绑定点击事件，将选中的关键词放入搜索框\n      ④ 将每个div都放入tips\n      ⑤ 将tips显示出来\n      ⑥ 每次向tips中填充数据时，都要先清空tips\n   \n\n代码实现:\n\nindex.html  ---  在搜索框上绑定keyup事件，获取搜索框内容并发送ajax请求\n\n1) 在搜索文本框上绑定键盘弹起事件\n\n2) 事件函数\n\n   ① 获取搜索框内容\n\n   ② 发送ajax请求，等待结果\n\n![1534824918237](/images/ajax/1534824918237.png)\n\n\ngetKeys.php ---  接收关键词，并根据关键词从数据表中查出相关的其他关键词，返回给前端\n\n1) 接收关键词\n\n2) 编写SQL语句，查询和接收关键词相关的所有关键词\n\n3) 将查询结果返回给前端\n\n\n![1534825243027](/images/ajax/1534825243027.png)\n\n下拉列表\n\n\n![1534825758739](/images/ajax/1534825758739.png)\n\n\nindex.html 将结果显示到下拉菜单中\n\n\n![1534826892534](/images/ajax/1534826892534.png)\n\n\n![1534826904482](/images/ajax/1534826904482.png)\n\n\n![1534826917378](/images/ajax/1534826917378.png)\n\n\n关键点总结:\n\n1) 使用键盘弹起事件来触发ajax请求\n\n   ① 获取搜索框中的内容\n\n   ② 发送ajax请求，并将搜索框中的内容一起发送给后端\n\n2) 接收到的数据需要循环显示在下拉菜单中\n\n   ① 将返回的字符串转为数组（内部是json对象）\n\n   ② 循环数组，取出每一个相似关键词\n\n   ③ 在循环中创建div对象，将关键词加入div对象\n\n   ④ 在div上绑定鼠标悬浮事件，修改背景和字体颜色\n\n   ⑤ 在div上绑定鼠标移出事件，修改背景和字体颜色为初始颜色\n\n   ⑥ 在div上绑定点击事件，将内容写在搜索框中，并隐藏下拉列表\n\n   ⑦ 将div追加到下拉列表中，然后再将下拉列表显示出来\n\n   ⑧  在循环显示下拉列表之前先清空下拉列表中已有内容\n\n\n\n## $.ajax方法\n\n\n$.ajax使用JS对象来配置ajax请求  ---  $.ajax(obj);\n\n 必须配置项：\n\n> url:         要请求的后台程序地址\n\n> data:      要发送到后台程序的数据 (建议使用json/js对象格式，也可以使用字符串，也可以是FormData)\n\n>type:      请求类型  post和get 两种  (put、delete)\n\n> dataType:  返回值类型  text(默认) 、 json 、xml 、 jsonp(跨域使用) \n\n> success:   成功完成ajax触发的事件，回调函数，其参数是后端程序的返回数据\n\n\n\n简单案例:\n\n1) 发送ajax请求\n\n![1534987626513](/images/ajax/1534987626513.png)\n\n\n2) 后端返回数据\n\n ![1534987638554](/images/ajax/1534987638554.png)\n\n 其他配置项：\n\n> cache: 是否进行缓存(true/fasle)，如果设置type为get，一般设置该项为false(不缓存)。\n\n> async: 同步/异步设置，true(异步、默认) false(同步)。\n\n> timeout: 超时设置，多少ms之后扔未接收到后端返回数据，则结束本次请求。--- 进入error方法中\n\n> error: 请求失败时的回调函数，该函数有三个参数。参数1是xhr对象，参数2是错误信息（错误信息通常是 \"null\", \"timeout\", \"error\", \"not modified\" 和 \"parsererror\"），参数3是异常对象（可选）。\n\n> complete: Ajax完成时的回调函数。不论请求成功还是失败都会执行该方法\n\n> beforeSend: 发送Ajax之前执行的回调函数。\n\n> beforeSend()  --->  success/error()  ---> complete()\n\n> contentType:  头信息设置，使用FormData对象时设置该值为false，其他情况会自动设置，不需要手动设置。\n\n> processData:  处理数据方式，使用FormData对象时设置该值为false，其他情况会自动设置，不需要手动设置。\n\n  注意: **contentType和processData只有在使用FormData对象时，设置为false，其余情况均不用设置**\n\n\n## 案例 ---  添加新管理员\n\n![1526375360112](/images/ajax/1526375360112.png)\n\n如果发送的数据是FormData，那么就只能使用原生js 或者 $.ajax\n\n  $.ajax发送请求时，如果发送的数据是FormData时，必须设置 contentType和processData为false\n\n  1) 表单页(index.html)\n\n       提交按钮上，绑定点击事件，获取表单数据，发送ajax请求\n\n  2) php页面接收表单数据，拼接SQL语句并执行 \n\n  3) 前端接收结果，进行提示\n\n\n\n代码实现:\n\n1) 表单页(index.html)\n\n    提交按钮上，绑定点击事件，获取表单数据，发送ajax请求\n\n     因为用到FormData来获取表单数据，所以必须用$.ajax，发送请求时要额外配置contentType和processData\n\n![1534991115290](/images/ajax/1534991115290.png)\n\n\n![1534991126414](/images/ajax/1534991126414.png)\n\n\n![1534991137939](/images/ajax/1534991137939.png)\n\n2) php页面接收表单数据，拼接SQL语句并执行  （自己完成）\n\n3) 前端接收结果，进行提示\n\n\n","tags":["Ajax"]},{"title":"08-JSON","url":"%2F2017%2F05%2F03%2Fajax%2F08-JSON%2F","content":"\n# JSON\n\n## 什么是JSON？\n\nJSON:  JavaScript Object Notation 是一种轻量级数据交互格式。\n\n数据交互: 每一种语言的编码都不一样，它们之间互不认识。但是现在的情况是不同的语言开发出的系统也需要进行数据交互，这时候就需要一种大家都认识的语言或者技术来实现。\n\n`xml: 扩展标记语言`\n\n\n## JSON数据的声明和使用\n\n```PHP\n        声明:  var json_obj = {\"key1\":\"value1\", \"key2\":\"value2\", ...};\n\n        key: 双引号包含的字符串\n\n        value: 数据→数值型、字符串、数组、json对象\n```\n\n\n```php\n        //key：必须用双引号\n        var json1 = {\"a\":\"Hello\", \"b\":\"world\"};\n        alert(json1.a);\n\n        var json2 = {\n            \"name\": \"郭德纲\",\n            \"age\": 50,\n            \"tudi\": ['岳云鹏', '烧饼', '张云雷'],\n            \"son\": {\"name\":\"郭麒麟\", \"age\":20}\n        };\n        alert(json2.name);\n        alert(json2.tudi[1]);\n        alert(json2.son.name);\n\n        //数组，内部的每个单元都是一个json\n        var json3 = [\n            {\"name\":\"赵四\",   \"age\":50},\n            {\"name\":\"小沈阳\", \"age\":46},\n            {\"name\":\"刘能\",   \"age\":50},\n            {\"name\":\"宋小宝\", \"age\":52},\n        ];\n        alert(json3[2].name);\n```\n\n\n\nJSON的本质:  JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。\n\n```php\nvar obj = {a:\"hello\", b:\"world\"};       // js对象\n\nvar obj = {\"a\":\"hello\", \"b\":\"world\"};    // json格式的js对象，也可以叫json对象 (JSON才是真正的JSON对象)\n\nvar str = '{\"a\":\"hello\", \"b\":\"world\"}';    // json，也叫json格式的字符串 必须外层单引号，内存双引号\n\nvar str = \"{'a':'Hello', 'b':'world'}\";  //错误，不能这样写，会影响到其他程序的执行\n\n```\n\n\n## PHP数组转JSON格式的字符串\n\n```\nphp提供了函数：  json_str  json_encode($arr);\n\n案例1: 索引数组转JSON      数组\n\n案例2: 关联数组转 JSON     json对象\n\n案例3: 二维数组转JSON      一维数组，每个单元都是一个json对象\n```\n\n\n```php\n        //索引数组\n        $arr = ['zs', 'ls', 'ww'];\n        // 一个索引数组被json_encode之后仍然是一个数组，\n        // 但是是一个字符串形式数组\n        echo json_encode($arr); // '[\"zs\", \"ls\", \"ww\"]'\n\n        echo \"<hr>\";\n\n        //关联数组\n        $info = ['id'=>1001, 'name'=>'王小明', 'age'=>8];\n        // 一维关联数组被json_encode之后是一个json字符串\n        echo json_encode($info); // '{\"id\":1001, \"name\":\"王小明\", \"age\":8}'\n\n        echo \"<hr>\";\n\n        //二维数组\n        $list = [\n            ['id'=>1001, 'name'=>'王小明', 'age'=>8],\n            ['id'=>1002, 'name'=>'韩梅梅', 'age'=>10],\n            ['id'=>1003, 'name'=>'李雷', 'age'=>9]\n        ];\n        // 二维数组，会转为数组，内部的每个单元都是json\n        echo json_encode($list);\n        /*\n        '[\n            {\"id\":1001,\"name\":\"王小明\",\"age\":8},\n            {\"id\":1002,\"name\":\"韩梅梅\",\"age\":10},\n            {\"id\":1003,\"name\":\"李雷\",\"age\":9},\n        ]'\n        */\n```\n执行结果:\n\n![1534815890487](/images/ajax/1534815890487.png)\n\n\n## JSON字符串转JSON对象 javascript代码\n\n前端的ajax请求，最后接收到的都是字符串  responseText，以字符串形式接收后端返回的数据\n```php\n\n        var a = '[{\"id\":10001,\"name\":\"zs\",\"age\":20},{\"id\":10002,\"name\":\"ls\",\"age\":21},{\"id\":10003,\"name\":\"ww\",\"age\":19}]'\n\n```\n\n        json格式的字符串转为json对象:  JSON.parse(json_str); \n\n        参数: json格式的字符串\n\n```php\n        var s = '{\"id\":1001,\"name\":\"王小明\",\"age\":8}';\n        alert(s.name);\n\n        //将json格式字符串转为json\n        var json = JSON.parse(s);\n        alert(json.name);\n\n\n        var arr = '[{\"id\":1001,\"name\":\"\\u738b\\u5c0f\\u660e\",\"age\":8},{\"id\":1002,\"name\":\"\\u97e9\\u6885\\u6885\",\"age\":10},{\"id\":1003,\"name\":\"\\u674e\\u96f7\",\"age\":9}]';\n        alert(arr[1]);\n\n        var arr1 = JSON.parse(arr);\n        console.log(arr1[1]);\n```\n\n## 案例 搜索用户名，显示用户列表信息\n\n![1534817413691](/images/ajax/1534817413691.png)\n\n    思路:\n \n    1) 创建一个搜索页面，定义好搜索框，表头。在搜索按钮上绑定点击事件。\n\n    2) 点击事件能够发送ajax请求，并将用户名文本框中的内容一起发送到后端php程序\n\n    3) 后端php程序接收用户名，链接MySQL进行模糊查询，再将数组返回给前端\n\n    4) 前端接收到后端php返回值之后，循环显示出来\n\n\n    代码实现 : \n\n    1) 创建一个搜索页面，定义好搜索框，表头。在搜索按钮上绑定点击事件。\n\n    页面布局 :\n![1534818204798](/images/ajax/1534818204798.png) \n\n\n    2) 点击事件能够发送ajax请求，并将用户名文本框中的内容一起发送到后端php程序,在搜索按钮上绑定点击事件  获取文本框中的用户名，发送ajax请求。\n![1534818226839](/images/ajax/1534818226839.png)\n    \n    3) 后端php程序接收用户名，链接mysql进行模糊查询，在将数组返回给前端。\n\n\n核心操作:\n\n    将资源转为二维数组，再将二维数组转为json字符串，再返回给前端 -->\n\n \n![1534819468793](/images/ajax/1534819468793.png)\n\n\n![1534819480657](/images/ajax/1534819480657.png)\n\n    4) 前端接收到后端php返回值之后，循环显示出来 \n![1534820413728](/images/ajax/1534820413728.png)","tags":["Ajax"]},{"title":"07-文件上传与进度条","url":"%2F2017%2F05%2F03%2Fajax%2F07-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F","content":"\n# 文件上传与进度条\n\n 1) 完成Ajax文件上传\n\n    核心: Ajax方式上传文件必须使用FormData对象\n\n    关键点:  \n\n\n        ① 表单使用提交按钮，一定是button\n        ② 获取文件对象 ---- FormData\n            i.根据id获取form表单对象 ---- DOM\n            ii. 实例化 FormData对象，将表单对象作为参数传入\n        iii. 因为使用了FormData，所以一定要用post方式发送请求，将fd作为参数传入send方法\n\n upload.html\n\n    获取文件数据，发送ajax请求\n\n\n![1534737676621](/images/ajax/1534737676621.png)\n\n\nupload.php \n\n\n![1534738152106](/images/ajax/1534738152106.png)\n\n2) 调整php配置文件（php.ini），使其支持大文件上传\n\n\n① 修改允许上传文件最大的大小\n\n![1534738492662](/images/ajax/1534738492662.png)\n\n\n② 修改post表单提交数据的最大大小\n\n![1534738552491](/images/ajax/1534738552491.png)\n\n重启Apache服务器。\n\n\n3) 文件进度条\n\n① 在页面上设置一个div，用来表示进度条\n\n![1534738923053](/images/ajax/1534738923053.png)\n  \n\n\n② 根据实际上传百分比来绘制进度条的宽度\n\n        核心:  xhr对象中有一个子对象（upload），upload对象中有一个事件 onprogress。该事件大约每100ms执行一次，里面有两个重要属性  loaded(已上传大小)    total（总大小）\n","tags":["Ajax"]},{"title":"06-XMLHttpRequest2.0新特性","url":"%2F2017%2F05%2F03%2Fajax%2F06-XMLHttpRequest2.0%E6%96%B0%E7%89%B9%E6%80%A7%2F","content":"\n# XMLHttpRequest2.0新特性\n\n## timeout 和 ontimeout\n```PHP\n timeout： 请求超时设置。属性，用来设置等待响应时长，如果超过指定时长，则会触发ontimeout事件\n\n\txhr.timeout = 3000;    // 设置等待时长为3秒\n\n    ontimeout： 事件，用来设置超过等待时长后的动作\n\n        xhr.ontimeout = function () {\n\n\t\talert('请求超时');\n\n        }\n```\n\n在创建xhr对象之后，来设置timeout属性；如果设置了timeout属性，那么就建议设置ontimeout事件。\n\n\n![1534734176919](/images/ajax/1534734176919.png)\n\n\n\n## FormData表单对象\n\n小案例:  点击button按钮时，将用户名和密码值通过ajax发送到后端php页面\n\n\n\n\n\nFormData对象优势就是能够一次性将表单中的所有数据全部取出，包括文件域的文件对象。\n\n\n1)创建表单  form标签很重要， method和action不重要\n\n   每个表单域需要设置name值\n\n2)发送ajax请求\n\n①将表单数据取出 FormData\n\ni.获取form表单对象:        var fm = document.getElementById(‘mainForm’);  //DOM对象\n\nii.实例化FormData对象:  var fd = new FormData(fm);\n\n\n②发送ajax请求\n\n   使用FormData对象以后，必须使用post方式来发送ajax请求。\n\n   将FormData对象，作为参数传入 send方法中  xhr.send(fd);\n\n③ 使用FormData对象提交表单时，不需要设置 setRequestHeader方法\n\n\n注意点: \n\n   ① form标签要给id值，方便获取form标签的DOM对象\n\n   ② 每个域都要给 name值\n\n   ③ 提交按钮必须用 button，因为submit有跳转功能\n\n代码实现:\n\n1) 使用FormData对象获取所有表单的数据，并发送ajax请求\n\n\n![1534736127757](/images/ajax/1534736127757.png)\n\n\n![1534736169386](/images/ajax/1534736169386.png)\n\n\n2) 在formdata.php页面，接收数据\n\n![1534736185571](/images/ajax/1534736185571.png)\n\n\n访问结果:\n\n![1534736212331](/images/ajax/1534736212331.png)\n\nFormData的内部构造:  key-value\n\n![1534736045066](/images/ajax/1534736045066.png)","tags":["Ajax"]},{"title":"05-同步和异步","url":"%2F2017%2F05%2F02%2Fajax%2F05-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%2F","content":"\n# 同步和异步\n\n## 同步/异步概念\n\n同步: **顺序执行** \n    \n    第一步---> 第二步 ---> 第三步 ....\n\n异步:  \n\n    甲在完成一系列工作时，自己完成主工作。将一些分支工作交给乙，甲此时一直在完成自己的工作，并等待乙完成的结果。乙完成后将结果返回给甲。\n\n\n 核心: open方法的参数3\n\n    参数3是一个布尔值， true异步方式（默认）， false是同步方式\n\n## 案例\n\n\n同时显示图片和弹出框\n\n  访问时: 先弹出123，点击“确定”之后，才显示图片 --- 同步\n\n\n\n 1) index.html文件\n\n ![1534733391709](/images/ajax/1534733391709.png)\n\n\n 2) index.php文件\n\n ![1534733426227](/images/ajax/1534733426227.png)\n\n 异步执行情况:  先显示图片，1秒后才显示时间戳弹出框\n\n同步执行情况:  等待1秒后显示时间戳弹出框，再点击确定之后才显示图片\n\n\n重点 :  在实际开发中 95% 以上的请求，都使用异步。\n\n\n","tags":["Ajax"]},{"title":"04-GET缓存","url":"%2F2017%2F05%2F02%2Fajax%2F04-GET%E7%BC%93%E5%AD%98%2F","content":"\n# GET缓存\n\n## 什么是缓存？\n\n 浏览器的请求需要从服务器获得许多 css、img、js 等相关的文件，如果每次请求都把相关的资源文件加载一次，对 带宽、服务器资源、用户等待时间 都有严重的损耗。如果浏览器将css、img、js等文件在第一次请求成功后就保存在本机上，以后的每次请求就在本机获得相关的资源文件，那么就可以明显地加快用户的访问速度，同时可以节省各种资源(带宽、服务器资源、用户等待时间)。\n\n\n## GET缓存测试\n\n ajax方式，get会有缓存问题。\n\n 案例:\n\n   index.html页面中创建一个按钮，点击该按钮时发送ajax请求，得到后端php程序返回的当前时间戳并显示。\n\n  目标:  点击“获取时间戳”按钮时，触发ajax请求，访问后端的getTime.php文件，得到时间戳并弹出显示\n\n1. index.html --- 发送请求\n\n\n![1534731418356](/images/ajax/1534731418356.png)\n\n\nindex.php --- 输出当前时间戳即可。\n\n![1534731456585](/images/ajax/1534731456585.png)\n\n\n 在IE下测试:\n\n ![1534731529792](/images/ajax/1534731529792.png)\n\n 显示的时间戳永远都是这个，说明是缓存问题。\n\n\n  解决方法\n\n  解决方法有两种:\n\n  1) 前端方案:  在open准备ajax请求时，为请求的地址增加随机后缀。相当于每次请求都是新的地址\n\n  2) 后端方案:  后端程序设置不允许缓存的头信息，php程序固定使用如下3句即可。\n\n\n\n\n            header('cache-controller:no-cache');\n\n            header('Pragam:no-cache');\n            \n            header('Expires:-1');\n\n\n1) 前端方案:\n\n![1534731918647](/images/ajax/1534731918647.png)\n\n\n\n2) 后端解决方案:\n\n        header('cache-controller:no-cache');\n        \n        header('Pragam:no-cache');\n\n        header('Expires:-1');\n\n\n![1534732086860](/images/ajax/1534732086860.png)\n\n","tags":["Ajax"]},{"title":"03-POST和GET的区别","url":"%2F2017%2F05%2F02%2Fajax%2F03-POST%E5%92%8CGET%E7%9A%84%E5%8C%BA%E5%88%AB%2F","content":"\n# POST和GET的区别\n## GET方式实现新用户注册---用户名检\n\n![1534727628005](/images/ajax/1534727628005.png)\n\n 步骤:\n\n1. get.html\n\n       1) 在用户名文本框上绑定失焦事件(onblur)\n\n       2) 失焦事件函数\n\n            ① 获取用户名文本框内已填写的用户名\n\n            ② 发送ajax请求，并将已填写的用户名一起发送给后端php页面\n\n1. get.html\n\n        1) 接收后端返回的数据，判断是1还是2。\n\n        2) 如果等于1，则提示用户名可用；如果等于2，提示用户名被占用\n\n\n代码实现:\n\n1. get.html\n\n        1) 在用户名文本框上绑定失焦事件(onblur)\n\n        2) 失焦事件函数\n\n                ① 获取用户名文本框内已填写的用户名\n\n                ② 发送ajax请求，并将已填写的用户名一起发送给后端php页面\n\n![1534728234170](/images/ajax/1534728234170.png)\n\n![1534728252209](/images/ajax/1534728252209.png)\n\n 先测试一下前后端的连通性:\n\n ![1534728362391](/images/ajax/1534728362391.png)\n\n\n\n2. get.php\n\n        1) 接收前端发送过来的用户名\n        2) 模拟用户被占用的情况 \n        3) 将结果返回给前端（1用户名可用   2用户名被占用）\n\n![1534729661714](/images/ajax/1534729661714.png)       \n\n\n\n3. get.html\n\n        1) 接收后端返回的数据，判断是1还是2。\n\n        2) 如果等于1，则提示用户名可用；如果等于2，提示用户名被占用\n\n\n![1534729897469](/images/ajax/1534729897469.png)\n\n\n\n关键点总结:\n\n1. 用户名文本框绑定失焦事件\n\n2. 发送ajax请求基本属于流程化操作\n   1) 实例化XMLHttpRequest对象\n   2) 调用open方法准备请求，**get方式发送将数据拼接在url地址之后即可**\n     xhr.open('get',  'get.php?**n='+name**);\n   3) 调用send方法发送请求，**get方式只需要将 null  作为参数传入即可**\n   4) 调用onreadystatechange事件，在readyState=4时使用responseText接收返回值。此步使用alert或者console.log先输出接收的结果即可，**不要着急将结果显示在网页上**。\n\n\n3. 创建后端php程序，接收用户名进行验证\n   核心SQL:  select * from ali_admin where admin_email = '$name';\n   该SQL语句的执行结果只可能是两种： 0条数据    1条数据(因为admin_email字段唯一)\n     0条数据: 说明没有该用户名 （没有被占用）\n     1条数据: 说明已存在该用户名 （已被占用）\n   根据SQL执行结果返回1或者2，1代表未被占用，2代表已被占用\n\n4. 修改get.html文件，将结果显示在网页上\n   获取用来显示结果的span标签，判断接收的结果为1还是2。如果为1，则将用户名可用写入span标签；反之，则将用户名已被占用写入span标签\n\n\n## POST方式实现新用户注册---用户名检测\n\n\npost和get两种方式的整体思路一致，只是细节上有所差别\n\n 1) 使用open准备请求时，参数1需要设置为post，参数2只需要设置后端程序地址。\n\n 2) 将需要传递到后端的数据拼接成一个独立的字符串，字符串的格式为\n\n\n        var str = ‘key=value&key=value&....’;    （内部结构跟get传参时的结构一致）\n\n 3) 调用setRequestHeader方法将数据格式转为 application/x-www-form-urlencoded\n\n 4) 将拼接好的数据字符串作为参数传入send方法\n\n 5) 后端的php程序需要使用 $_POST来接收数据\n\n\n前端的区别:\n\n![1534730851993](/images/ajax/1534730851993.png)\n\n后端的区别:\n\n![1534730967099](/images/ajax/1534730967099.png)\n\n\n> 关键点总结:\n\n 1) 发送程序时，参数1设置为post，参数2只用设置请求的后端文件路径\n\n    xhr.open('post', 'post.php');\n\n 2) 将需要传递到后端的数据拼接成一个独立的字符串\n\n\n  var str = 'name='+name; \n\n 3) 调用setRequestHeader方法将数据格式转为 application/x-www-form-urlencoded\n\n    xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded');\n\n 4) 发送请求时，要将之前拼接好的字符串作为参数放入send方法中\n\n    xhr.send(str);\n\n\n> 补充说明 --- 实际验证用户名是否存在的方法\n\n核心：  $sql = \"select * from ali_admin where admin_email='$username'\";\n\n该SQL语句要么查询出1条数据，要么查询出0条数据\n\n  1条数据说明: 用户名已被占用\n\n  0条数据说明: 用户名未被占用 -- 用户名可用\n\n\n","tags":["Ajax"]},{"title":"02-Ajax入门","url":"%2F2017%2F05%2F02%2Fajax%2F02-Ajax%E5%85%A5%E9%97%A8%2F","content":"\n# Ajax入门\n\n## （Ajax 开发）概述\n\nAjax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。\n\nAjax = 异步 JavaScript 和 XML（标准通用标记语言的子集）。\n\nAjax 是一种用于创建快速动态网页的技术。\n\nAjax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\n通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。\n\n\n\n  历史：\n\n1999年诞生，微软在IE5中集成了XMLHttpRequest对象，但是并没有受到人们重视。\n\n2005年，google在gtalk即时聊天工具中使用了该对象，从此之后Ajax技术开始受到人们的重视。\n\n\n## 发送Ajax请求\n\n### ajax核心对象 --- XMLHttpRequest对象\n\n创建XMLHTTPRequest对象要分为(低版本) IE和==非IE两种方式(主流)==：\n\n   IE浏览器（IE7之前） :  \n\n                  var xhr = new ActiveXObject('Msxml2.XMLHTTP');\n\n   非IE浏览器（chrome、firefox、safair、搜狗等，包括IE7+之后） (主流浏览器):\n\n\t\t  var xhr = new XMLHttpRequest();\n\n\n案例：创建XMLhttpRequest对象，兼容IE7之前和主流浏览器\n\n        //创建XMLHttpRequest对象，兼容低版本IE和非IE浏览器\n        function getXhr () {\n            var xmlhttp;\n\n            if (window.XMLHttpRequest) {\n                //IE7+ 和 非IE 中都有 XMLHttpRequest对象\n                xmlhttp = new XMLHttpRequest();\n            } else {\n                xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');\n            }\n\n            return xmlhttp;\n        }\n\n        alert(getXhr());\n\nchrome访问结果:\n\n![1534562204874](/images/ajax/1534562204874.png)\n\n\nIE访问结果:\n\n![1534562252947](/images/ajax/1534562252947.png)\n\n## 核心方法\n\nXMLHttpRequest对象有了，可以发送Ajax请求了。发送请求需要两个方法:\n\nopen(var1, var2, var3): 准备Ajax请求\n\n        var1: 请求方式  get/post\n        var2: 请求的后端程序地址\n        var3: 异步(true)/同步(false)，可选参数，默认为true\n\n\n  示例: xhr.open(‘get’, ‘index.php’);   //准备以get方式请求后端的index.php文件\n\n   send(var): 发送Ajax请求\n\n        var: 分为两种情况。 如果是get请求，则填写null。 如果是post请求，则填写要发送到后端的数据。\n\n var: 分为两种情况。 如果是get请求，则填写null。 如果是post请求，则填写要发送到后端的数据。\n\n\n    示例: xhr.send(null); \n\n## 发送请求案例\n\n\n 在index.html页面上创建按钮，点击该按钮时使用get方式请求后端的index.php页面\n\n 发送Ajax请求流程:\n\n   1) 创建XMLHttpRequest对象\n\n   2) 调用open方法准备ajax请求\n\n   3) 调用send方法发送ajax请求\n\n\n\n代码实现\n\n   1) 创建按钮，绑定点击事件\n\n   2) 创建XMLHttpRequest对象\n\n   3) 调用open方法准备ajax请求\n\n   4) 调用send方法发送ajax请求\n\n\n![1534563208094](/images/ajax/1534563208094.png)\n\n![1534563224252](/images/ajax/1534563224252.png)\n\n 访问结果: --- 通过newwork来确定请求是否发出\n\n点击\"btn\"时，又发送了请求，请求了 index.php文件，并且正常接收到结果\n\n\n![1534563287777](/images/ajax/1534563287777.png)\n\n## 接收后端响应结果\n\n### 核心属性 --- readyState\n\n\nAjax的整个过程有5个状态，对应readyState的5个值：0-4\n\n    《Pragmatic Ajax A Web 2.0 Primer 》 中对readyStae状态的介绍 \n\n   0: (Uninitialized) the send( ) method has not yet been invoked.  \n\n   1: (Loading) the send( ) method has been invoked, request in progress.  \n\n   2: (Loaded) the send( ) method has completed, entire response received. \n\n   3: (Interactive) the response is being parsed. \n\n   4: (Completed) the response has been parsed, is ready for harvesting.  \n\n   0 － （未初始化）还没有调用send()方法 \n\n   1 － （载入）已调用send()方法，正在发送请求 \n\n   2 － （载入完成）send()方法执行完成，已经接收到全部响应内容 \n\n   3 － （交互）正在解析响应内容 \n\n   4 － （完成）响应内容解析完成，可以在客户端调用了 \n\n\n百度百科: \n\n  0 （未初始化） \t对象已建立，但是尚未初始化（尚未调用open方法）               \n\n  1 （初始化）  \t已调用send()方法，正在发送请求                      \n\n  2 （发送数据） \tsend方法调用完成，但是当前的状态及http头未知              \n\n  3 （数据传送中）  已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，\n\n  4 （完成）   \t数据接收完毕，此时可以通过通过responseBody和responseText获取完整的回应数据\n\n \n\n- **最核心的重点：   4 ,  后端返回的数据已经可以在浏览器中使用了。**\n\n\n## 核心事件 --- onreadystatechange\n\n onreadystatechange事件:  readyState的值每次发生变化都会触发该事件。\n\n    0-->1    1-->2    2-->3    3-->4 总共触发4次\n\n### 其他重要属性\n\n responseText：以字符串形式接收后端程序的返回值。\n\n         以PHP为例: PHP程序最终会被解释程序一段字符串，responseText接收的就是这段字符串\n\n     responseXML：以XML格式接收后端程序返回值\n\n\n### 响应案例 --- index.php\n\nindex.php：返回字符串“Hello Ajax”给前端 --- 就是  echo \"Hello Ajax\"\n\n     index.html： 将Hello Wrold 显示在页面的div中\n\n1) index.php 返回一个字符串（Hello Ajax！！）\n\n![1534564764184](/images/ajax/1534564764184.png)\n\n\n2) 在index.html中检测readyState的状态，当readyState状态等于4的时候，使用responseText来接收后端返回的数据\n\n![1534564786499](/images/ajax/1534564786499.png)\n\nresponseText本质是接收后端返回的字符串。\n\n\nAjax程序总结\n\n一般我们编写Ajax程序时需要两个页面，三大步骤:\n\n![1525944330962](/images/ajax/12.png)\n\n  两个页面:\n\n   前端静态html页面 (php页面也行)，用来发送ajax请求，将结果渲染到页面上\n\n   后端php页面 (jsp、asp也行)，用来接收前端请求，处理数据，并将结果返回给前端页面\n\n \n\n  三大步骤:\n\n  1) 前端静态页面发送ajax请求。\n\n  ① 创建 XMLHttpRequest 对象\n\n       ② 调用open方法准备ajax请求\n\n       ③ 调用send方法发送ajax请求\n\n       ④ 调用onreadystatechange事件，判断readyState=4时，使用responseText接收后端返回数据\n\n        2) 后端php页面，处理请求并返回结果\n\n        3) 前端页面接收结果，显示在网页指定位置\n\n\n\n### 综合案例\n\n点击按钮，从student表中随机取出一条学生信息，显示在网页上。\n\n 思路分析:\n\n 1) 两个页面\n\n   前端静态页面: student/index.html\n\n   后端php页面: student/index.php\n\n \n![1524658135608](/images/ajax/13.png)\n\n 2) 三大步骤\n\n  ① index.html 页面设置一个按钮，用来触发ajax请求\n\n  ② index.php 随机取出一条学生数据，并返回给index.html页面\n\n    $sql = \"select * from student order by rand() limit 0,1\";\n\n  ③ index.html 接收到后显示在页面上\n\n   代码实现:\n\n第一步骤:  index.html页面发送ajax请求\n\n![1534566337714](/images/ajax/1534566337714.png)\n\n第二步骤: 后端php页面\n\n![1534566429341](/images/ajax/1534566429341.png)\n\n第三步骤： index.html -- 将接收到的数据渲染到页面\n\n![1534566508821](/images/ajax/1534566508821.png)\n\n\n 关键点总结:\n\n1) index.html 通过点击事件发送ajax请求\n\n ① 创建XMLHttpRequest对象\n\n ② 调用open方法准备ajax请求\n\n ③ 调用send方法发送ajax请求\n\n**此时不要着急将数据渲染到网页上**\n\n 2) index.php 随机取出一条学生数据，并返回给index.html页面\n\n  ① mysqli操作MySQL服务器的6步骤\n\n  ② 核心SQL:  select * from student order by rand() limit 0,1 \n\n  ③ 将结果拼接成字符串再输出，因为前端是以字符串形式接收的\n\n\n\n 3) index.html接收到后显示在页面上\n\n  ① 创建一个div标签，用来显示接收到数据\n\n  ② 获取div对象，再将数据显示到该标签中\n\n\n\n\n","tags":["Ajax"]},{"title":"01-Ajax 技术","url":"%2F2017%2F05%2F02%2Fajax%2F01-Ajax%E6%8A%80%E6%9C%AF%2F","content":"\n# Ajax 技术\n\n## 案例---新用户注册时用户名冲突问题\n\n## 传统模式解决方案\n\n1) 在注册页面中输入用户名和密码，点击“注册”时，要将表单数据提交给后台\n\n![1523691565801](/images/ajax/05.png)\n\n2) 后台PHP页面，接收用户名和密码之后，要去验证用户名是否存在，如果存在则提示用户名存在，再跳转回注册页面，重新输入。\n\n  当用户名存在时，提示用户名已被占用，再跳转回登录页\n\n![1523691637131](/images/ajax/06.png)\n\n![1523691696235](/images/ajax/07.png)\n\n## ajax解决方案\n\n当光标离开用户名文本框时，就已经验证了用户名是否存在，并给予提示了。\n\n  用户名被占用： \n\n![1523691892998](/images/ajax/08.png)\n\n用户名可用 :\n\n![1523691866761](/images/ajax/09.png)\n\n\n\n> 两种模式对比\n\n\n传统模式： \n\n  两个页面 ---  前端注册表单页（index.html）  和  后端数据验证页（index.php）\n\n\n![1524655686232](/images/ajax/10.png)\n\n\nAjax模式 :\n\n  两个页面 --- 前端注册表单页（index.html）  和  后端数据验证页（index.php）\n\n![1524656343611](/images/ajax/11.png)\n\n\nAjax的优势：没有页面跳转，刷新页面内容，用户体验提升。\n\najax就是在页面没有刷新或者没有跳转的情况下还能更新页面的某一部分数据\n\n\n","tags":["Ajax"]},{"title":"28-session和cookie的联系","url":"%2F2017%2F04%2F27%2FPHP%2F28-cookie%E5%92%8Csession%E7%9A%84%E8%81%94%E7%B3%BB%2F","content":"\n# session和cookie的联系\n\n## session原理\n\n    session默认是保存在服务器的文件当中的。\n\n        windows默认存放在 c:/windows/temp目录下， phpstudy存放在 phpstudy/tmp/tmp目录下\n\n\n![1534557997292](/images/php/1534557997292.png)\n\n## cookie和session的联系\n\n当浏览器访问一个设置session的页面时，服务器会随机自动生成一个session_id（字符串）。通过响应头的set-cookie返回给浏览器，并保存在浏览器的cookie当中，同时服务器中也会生成一个以该session_id为名称的文件，用来记录信息。\n\n     浏览器之后每次访问该网站时，都会携带cookie中的session_id，来和服务器中的session文件名进行比对。当文件名和cookie中的session_id一致时，则说明使用的是该session文件，可以从该session文件中读取数据。\n\n\n案例: 访问 sets.php文件 和  gets.php\n\n\n\nsets.php\n\n![1534558764734](/images/php/1534558764734.png)\n\n\ngets.php\n\n![1534558776347](/images/php/1534558776347.png)\n\n\n访问 sets.php文件时，完成两件事情\n\n1) 将session_id随着响应头返回给浏览器，并保存在浏览器中\n\n\n![1534558189499](/images/php/1534558189499.png)\n\n2) 在服务器端创建一个session文件   sess_958ur7nh1djufrs9aqkia40im1， 将$_SESSION中已保存的数据，存储到该文件中。\n\n![1534558225267](/images/php/1534558225267.png)\n\ngets.php文件\n\n![1534558307932](/images/php/1534558307932.png)\n\n\n服务器在tmp目录下找到 sess_958ur7nh1djufrs9aqkia40im1 文件，并将文件中的数据取出，返回给浏览器\n\n# session和cookie总结\n\n## cookie小结:\n\n  1） 将数据保存在客户端，安全性不好，但是可以保存的数据量较大。\n\n        一个网站能向一个浏览器写 20 个cookie\n\n        一个浏览器最多保存300个cookie，每个cookie最大4kb\n\n  2） 设置cookie使用  setcookie(var1, var2, var3)；\n\n\n        var1： cookie名称\n        var2： 名称对应的值\n        var3： 有效期。 可选参数，如果不设置该值或者设置为-1，浏览器关闭则cookie消失\n\n\n  3） 使用$_COOKIE 预定义数组来读取cookie\n\n  4） cookie的有效范围： 当前目录及子目录；上级目录无效\n\n  5） 删除cookie:  setcookie(‘name’, null);\n\n\n## session小结:\n\n  1) 将数据保存在服务器端，安全性高，但是不能保存大量的数据。一般来讲session当中保存的都是用户信息。\n\n  2) 使用session时，首先要使用 session_start函数开启session\n\n  3) 设置和读取session时，都是用$_SESSION['name'] = 'zs';  $_SESSION['name'];\n\n  4) session的有效范围，在一个域名下设置session，在整个域名范围内都有效\n\n  5) 删除session\n\n\n            unset($_SESSION[‘name’]);    //删除单个session\n            session_destroy();                   //删除所有session","tags":["PHP"]},{"title":"27-session技术","url":"%2F2017%2F04%2F27%2FPHP%2F27-session%E6%8A%80%E6%9C%AF%2F","content":"\n# session技术\n\n##  session介绍\n\n因为cookie是保存在客户端的数据，不够安全，所以出现了session。\n\nsession会将数据保存到服务器端（保存在 **文件**、内存服务器或数据表中），安全性就可以得到保证。\n\n\n## 设置/读取session\n\n重点:\n\n    php使用session时，首先要使用session_start()函数来开启session。\n    $_SESSION 超全局变量就能设置和读取session中的内容\n\n1) 设置session\n\n   将session作为数组操作就可以。\n\n![1534479772737](/images/php/1534479772737.png)\n\n2) 读取session\n\n![1534479789250](/images/php/1534479789250.png)\n\n## session作用范围\n\n   在当前网站的任何一个页面设置过session，则该网站的所有页面都能得到该session的数据\n\n   例如: 在 www.jd.com 的某个页面中设置session，那么在jd网站的任何一个页面都能找到该session\n\n   同理，在localhost的某个页面中设置session，那么在localhost的任何一个php页面都能找到\n\n![1534480032772](/images/php/1534480032772.png)\n\n## session的有效期\n\n    浏览器关闭时，session消失\n\n## 删除session\n\n unset($_SESSION[‘name’]);    //删除单个session\n\n   session_destroy();                   //删除所有session\n\n\n![1534480227294](/images/php/1534480227294.png)","tags":["PHP"]},{"title":"26-cookie技术","url":"%2F2017%2F04%2F27%2FPHP%2F26-cookie%E6%8A%80%E6%9C%AF%2F","content":"\n# cookie技术\n\n## 什么是cookie？\n\n  cookie是将数据持久化存储到客户端的一种技术。\n\n   网站可以将数据写到浏览器中， 一个网站最多能在一个浏览器写20个cookie。\n\n   一个浏览器能够设置的总cookie数最多为300个，每个不能超过4kb。\n\n   cookie既能保存在文件中，也能保存在内存中。\n\n## 设置/读取cookie\n\n1) 设置cookie\n\n   setcookie(var1 , var2, var3);\n\n   var1: cookie的名称\n\n   var2: 名称对应的值， 可选参数\n\n   var3: cookie的有效期， 可选参数\n\n   ![1534478105079](/images/php/1534478105079.png)\n\n\n2) 读取cookie信息\n\n   使用php的超全局变量 $_COOKIE进行读取\n\n   ![1534478123739](/images/php/1534478123739.png)\n\n   通过浏览器查看cookie信息:\n\n   ![1534478176053](/images/php/1534478176053.png)\n\n   ![1534478276084](/images/php/1534478276084.png)\n\n## cookie有效期\n\n  setcookie函数的参数3可以控制cookie有效期\n\n        参数3设置为-1 或者 不设置，关闭浏览器即失效\n        参数3设置为 time()+秒数，则在当前时间点的多少秒之后失效\n\n\n  设置cookie时，如果设置了有效期，则cookie会保存在文件中；如果没有设置有效期，则cookie保存在内存中。\n\n\n  ## cookie的有效范围\n\n  **setcookie函数还有参数4、5，可以用来控制cookie的有效访问，但是一般不用。**\n\n\n只需要记住下面的情况即可：   \n\n        在不使用参数4和5的情况下，cookie在当前目录及子目录中有效，在上层目录中无效。\n\n\n![1534478631803](/images/php/1534478631803.png)\n\n## cookie删除\n\n setcookie函数第二个参数设置为null，就可以删除cookie\n\n        setcookie('name', null);\n\n\n![1534478730006](/images/php/1534478730006.png)\n\n\n\n ## js控制cookie\n\n cookie是将数据保存在客户端的，所以可以使用javascript来读取/设置cookie。 \n\n   设置cookie:   document.cookie = “名称=值;expires=时间”\n\n   读取cookie:   document.cookie\n\n\n读取cookie:\n\n![1534479056017](/images/php/1534479056017.png)\n\n\n![1534479028505](/images/php/1534479028505.png)\n\n\n设置cookie:\n\n  expires: 用来指定cookie有效期的\n\n\n![1534479410042](/images/php/1534479410042.png)\n\n## cookie原理\n\n当浏览器访问一个带cookie的页面时，cookie会随着响应头返回给浏览器。\n\n  当再次访问该网站的页面时，cookie会随着请求头一起发送给服务器。\n\n![1534556304079](/images/php/1534556304079.png)\n\n![1534556836082](/images/php/1534556836082.png)","tags":["PHP"]},{"title":"25-PHP会话控制概述","url":"%2F2017%2F04%2F27%2FPHP%2F25-PHP%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6%2F","content":"\n# 会话控制概述\n\n1) http协议的缺陷\n\n     无状态，就是无记忆，不能让同一浏览器和服务器进行多次数据交换时，产生业务的连续性。\n\n2) 什么是会话控制\n\n     会话控制就是解决http无记忆的缺陷的。能够==将数据持久化的保存在客户端(浏览器)或者服务器端==，从而让浏览器和服务器进行多次数据交换时，产生连续性。\n\n3) 会话控制的分类\n\n    分为两种: cookie（客户端）  和  session（服务器端）\n\n\n\ncookie应用实例 --- 千人千面（猜你喜欢）\n\n\n![1534424615529](/images/php/0002.png)\n\n不同的用户访问优酷服务器所看的视频类型不一样。 服务器会将浏览器观看过的视频的关键词保存到浏览器的cookie中（文件、内存）。当浏览器再次访问优酷服务器时，服务器会从cookie中读取关键词，再根据关键词推荐视频。\n\nsession应用实例 --- 支付宝\n\n![1534426142105](/images/php/1534426142105.png)\n\n每个用户访问支付宝进行登录时，用的是同一套程序。服务器会为每一个浏览器进行编号(sessionid)，当用户登录成功后，服务器会创建一个区域(文件、内存服务器)用来保存用户信息。等浏览器下一次访问服务器时，服务器先拿到浏览器的编号，再和已有的编号进行比较，找到相同的区域（文件、内存服务器）。","tags":["PHP"]},{"title":"24-学生信息管理系统","url":"%2F2017%2F04%2F27%2FPHP%2F24-%E4%BF%AE%E6%94%B9%E4%BF%A1%E6%81%AF%E4%BA%8E%E7%99%BB%E5%BD%95%2F","content":"\n\n# 修改学生信息\n\n核心：构造一条修改数据的SQL语句   \n\n   **update student set sname='', sage=''..  where sno=6**\n\n![1525931034561](/images/php/0004.png)\n\n步骤:\n\n 1) 在学生列表页(list.php)为每一行都添加一个“编辑”按钮，跳转到编辑表单页(edit.php)，并且要将当前行的sno一起传递到edit.php页面。\n\n ![1534470480931](/images/php/1534470480931.png)\n\n\n 2) 创建edit.php页面(和add.html页面结构一样)，接收sno，拼接SQL语句并执行，得到一个一维数组，将该数组的值填充到表单中。\n\n  ① 接收sno\n\n  ② 根据sno 查询学生信息\n\n  ③ 将学生信息显示到表单中  -- 将add.html中的表单复制过来，稍作修改即可\n\n  ④ 保证表单能够提交到modify.php页面即可\n\n\n![1534472770097](/images/php/1534472770097.png)\n\n![1534472786290](/images/php/1534472786290.png)\n\n3) 创建一个修改页面(modify.php)，接收edit.php页面表单中的值，拼接一个修改的SQL语句，执行该SQL语句。根据修改结果提示修改成功/修改失败，再跳转\n\n ① 接收表单提交的数据\n\n ② 编写修改的SQL语句 --- update\n\n ③ 链接MySQL服务器并执行SQL语句\n\n\n![1534472861491](/images/php/1534472861491.png)\n\n![1534472871239](/images/php/1534472871239.png)\n\n关于排错: \n\n     核心思想: 如果一个程序中有SQL语句执行，那么该程序出现错误，第一反应去检查SQL语句。\n\n     检查方法:\n\n          1) 在php页面中使用echo 将sql语句进行输出\n\n           2) 在页面上复制SQL语句到navicat中进行测试\n\n\n\n   第一步:\n\n![1534471889871](/images/php/1534471889871.png)\n\n![1534471933626](/images/php/1534471933626.png)\n\n![1534472010096](/images/php/1534472010096.png)\n\n将SQL语句复制到navicat中执行，获取错误信息。\n\n![1534472183035](/images/php/1534472183035.png)\n\n\n\n\n\n\n\n\n\n# 登录\n\n![1534422493447](/images/php/0001.png)\n\n验证逻辑:\n\n 1) 根据用户名从ali_admin表中查询数据。如果有结果，则说明用户名正确；反之，说明用户名错误。\n\n 2) 登录表单提交密码和上一步查询出的密码进行比对，两者相等说明密码正确；反之，密码错误。\n\n\n\n代码实现:\n\n1) 创建login.html 登录表单页\n\n\n![1534475186781](/images/php/1534475186781.png)\n\n2)  创建check.php文件\n\n  ① 接收表单提交的数据\n\n  ② 验证用户名是否正确\n\n      核心思路:  根据接收的用户名查询ali_admin表，如果能够查询到数据，说明用户名正确；反之，查询不到数据说明用户名错误。\n\n       核心SQL: ==select * from ali_admin where admin_email='$email'==\n\n       该SQL语句的执行结果，只能是0条数据 或者 1条数据\n\n  ③ 验证密码是否正确\n\n   核心思路:  验证从数据表中查询出的数据中的密码和表单提交的密码是否一致。如果一致，则说明密码正确，可以正常登录；反之，说明密码错误，跳转到login.html页面\n\n\n![1534475375825](/images/php/1534475375825.png)\n\n![1534475387591](/images/php/1534475387591.png)\n\n测试: 直接访问 list.php页面，依然可以看到页面结果。 因为http协议是无记忆协议，不知道哪个浏览器来过，所以没办法限制是否能够正常访问到哪个页面。\n\n要实现限制的功能，必须配合 **会话控制**技术\n\n\n\n## 核心思想: \n\n    1) 登录成功时将用户重要信息写入session\n\n    2) 在其他每个页面中都进行session是否存在的验证\n\n1) 登录成功时，设置session\n\n![1534555270715](/images/php/1534555270715.png)\n\n2) 在其他页面中检测session是否存在\n\n![1534555378519](/images/php/1534555378519.png)\n\n3) 将检测session 的代码复制到每个页面中，除了 login.html 和 check.php\n\n![1534555451516](/images/php/1534555451516.png)","tags":["MySQL PHP"]},{"title":"23-学生信息管理系统","url":"%2F2017%2F04%2F26%2FPHP%2F23-%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F","content":"\n# 学生信息管理系统\n\n**目标: 通过PHP网页来管理数据库，对数据表的数据进行增删改查**\n\n数据表设计:\n\n        sno： 学号  整型  无符号  主键  自增长\n        sname： 姓名  字符串\n        sage： 年龄 无符号 微整型\n        sgender： 性别 枚举\n        semail： 邮箱\n        stel： 电话\n\n\n        create table student(\n        sno int UNSIGNED auto_increment PRIMARY key,\n        sname VARCHAR(30) not null,\n        sage tinyint UNSIGNED not null,\n        sgender enum('男', '女') DEFAULT '男',\n        semail varchar(30),\n        stel   char(11)\n        ) engine=myisam DEFAULT charset=utf8;\n\n\n\n测试数据:\n\nINSERT INTO student VALUES ('1', '赵老四', '30', '男', 'zls@a.com', '13512345678');\n\nINSERT INTO student VALUES ('2', '王翠花', '28', '女', 'wch@b.com', '13612345678');\n\nINSERT INTO student VALUES ('3', '孙狗剩', '32', '男', 'sgs@c.com', '13712345678');\n\n\n## 学生信息列表\n\n核心SQL:  select  *  from  student\n\n 将student表的数据以表格形式显示在网页上\n\n![1534258428616](/images/php/01.png)\n\n 1) 从student表中获取数据\n\n ![1534303266774](/images/php/1534303266774.png)\n\n 2) 将获取的数据显示表格\n\n ![1534303304520](/images/php/1534303304520.png)\n\n 3) 释放资源\n\n ![1534303325933](/images/php/1534303325933.png)\n\n ## 添加学生信息\n\n 核心SQL:  insert into student values(null, '路飞', 10, '男', 'lf@dasd.com', 18012345678);\n\n ![1528439313954](/images/php/4564646546545646.png)\n\n 代码实现:\n\nadd.html  ----   提供一个可以填写的表单\n\n![1534305511046](/images/php/1534305511046.png)\n\nadd_deal.php\n\n  1) 接收表单数据\n\n  2) 拼接SQL语句\n\n  3) 链接MySQL服务器并执行SQL语句\n\n  4) 处理SQL执行结果： 判断结果，如果是true说明添加成功，如果是false说明添加失败\n\n  5) 关闭数据库链接\n\n\n![1534305668178](/images/php/1534305668178.png)\n\n![1534305682999](/images/php/1534305682999.png)\n\n## 删除学生\n\n核心SQL:  **delete from student where sno=5**\n\n![1525930130559](/images/php/03.png)\n\n步骤: \n\n   1) 在学生信息列表页(index.php)，为每一行都添加一个删除按钮，删除按钮可以跳转到另一个php(del.php)页面，在跳转时，将当前行的sno一起传递到del.php页面。\n\n\n![1534306751175](/images/php/1534306751175.png)\n\n   2) del.php页面，接收sno，拼接删除的sql语句，再执行该SQL。再根据删除结果提示删除成功/删除失败。跳转回学生列表页。\n\n  ① 接收学号 sno\n\n  ② 拼接删除的SQL语句\n\n  ③ 链接MySQL服务器并执行SQL语句\n\n![1534306776699](/images/php/1534306776699.png)\n\n![1534306790027](/images/php/1534306790027.png)","tags":["MySQL PHP"]},{"title":"22-PHP操作MySQL","url":"%2F2017%2F04%2F26%2FPHP%2F22-PHP%E6%93%8D%E4%BD%9CMySQL%2F","content":"\n# PHP操作MySQL\n\n\nPHP当中一共有三组函数可以用来操作MySQL服务器： mysql    mysqli   pdo\n\n\n\n   PHP操作数据库是固定流程，一共6步:\n\n   1) 链接MySQL服务器  \n\n   2) 选择要操作的数据库\n\n   3) 设置字符集 （不设置字符集可能会出现乱码问题）\n\n   4) 执行SQL语句\n\n   5) 处理SQL执行结果\n\n   6) 关闭MySQL链接\n\n   除了第五步，其他每一步都是固定的，对应一个mysql的函数\n\n 1) 链接MySQL服务器 --- mysql_connect(var1, var2, var3)\n\n  参数1: MySQL数据库的主机地址\n\n  参数2: MySQL用户名  （root）\n\n  参数3: 用户名对应的密码\n\n  返回值: 数据库链接资源\n\n  `$conn = mysql_connect('localhost', 'root', 'root');`\n\n  2) 选择要操作的数据库  --- mysql_select_db(var)\n\n  参数1: 数据库名称\n\n `mysql_select_db('demo');`\n\n   3) 设置字符集 --- mysql_query(var);\n\n  参数1: sql 语句 ----  set names utf8  (设置字符集的sql语句)\n\n  `mysql_query('set names utf8');`\n\n   4) 执行SQL语句 --- mysql_query(var);\n\n  参数: sql 语句 ----  增删改查SQL语句\n\n  返回值: 如果是查询，则返回结果集（资源），该资源里面包含了从数据表中取出的数据\n\n            如果是增删改，则返回布尔值，执行成功返回true，失败返回false\n\n  `$result = mysql_query($conn, $sql);`\n\n\n5) 处理 **查询结果**\n\n **mysql_fetch_assoc(var);**\n\n  参数: 查询结果集（资源）\n\n  返回值: 一维数组，下标是数据表字段\n\n  将当前行的数据取出并返回成一维数组，同时将指针向下移动一行。\n\n  如果已经无法返回一维数组时，则返回false \n\n\n\n   6) 关闭MySQL链接资源 --- mysql_close(var)\n\n   参数: 数据库链接资源\n\n\n案例: 向test库中的student表中，增加一条数据\n\n![1534299226350](/images/php/1534299226350.png)\n\n![1534299257926](/images/php/1534299257926.png)\n\n 案例: 查询student表，并将数据以表格形式显示在网页上\n\n ![1534302509227](/images/php/1534302509227.png)\n\n ![1534302540798](/images/php/1534302540798.png)\n\n ![1534302553169](/images/php/1534302553169.png)\n\n 核心: mysql_fetch_assoc的执行原理\n\n ![1534302580309](/images/php/1534302580309.png)","tags":["MySQL PHP"]},{"title":"21-删除数据","url":"%2F2017%2F04%2F26%2FPHP%2F21-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%2F","content":"\n# 5. 删除数据\n\n格式:  delete from 表名  where 删除条件\n\n \n\n> 案例4: 删除cate_id=5的栏目\n\n![1534297771122](/images/php/1534297771122.png)\n\n\n![1534297834108](/images/php/1534297834108.png)","tags":["MySQL"]},{"title":"20-修改数据","url":"%2F2017%2F04%2F26%2FPHP%2F20-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%2F","content":"\n# 4. 修改数据\n\n格式:  \n\n  update  表名   set   字段1=值1, 字段2=值2,...  where  修改条件\n\n  修改表中的哪一条（几条）数据的 字段1=值1...\n\n \n\n> 案例2: 将id为6的管理员昵称改为凯子\n\n![1534297306985](/images/php/1534297306985.png)\n\n> 案例3: 将所有男性管理员的年龄都+1\n\n表: ali_admin\n\n字段: admin_age\n\n修改条件: admin_gender='男'\n\n![1534297543190](/images/php/1534297543190.png)","tags":["MySQL"]},{"title":"19-添加数据","url":"%2F2017%2F04%2F26%2FPHP%2F19-%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%2F","content":"\n# 3. 添加数据\n\n格式： insert  into  表名(字段1，字段2，...)  values(值1，值2，...);\n\n关键点:\n\n   1) 字段和值需要一一对应，如果不对应会造成添加失败或者数据错误\n\n   2) 如果每个字段都有数据，则不需要在表名后设置字段列表\n\n   3) 带有auto_increment属性的字段可以使用null来设置，MySQL会自动填充数据\n\n\n> 案例1: 向student表添加一条数据\n\n\n方式一:\n\n![1534295770586](/images/php/1534295770586.png)\n\n方式二:\n\n![1534295979697](/images/php/1534295979697.png)\n\n\n方式三: \n\n![1534296150393](/images/php/1534296150393.png)","tags":["MySQL"]},{"title":"18-数据查询","url":"%2F2017%2F04%2F26%2FPHP%2F18-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%2F","content":"\n# 2. 数据查询\n\n语法格式: \n\n  SELECT  字段名1, 字段名2, ......\n\n  FROM 表名\t\n\n\n          [ WHERE <条件表达式> ]\n\n          [ ORDER BY <字段名> [ ASC|DESC ]]\n\n          [ LIMIT  START, LENGTH]\n\n\n\n##  2.1 基本查询\n\n格式:  select  字段名1, 字段名2,....  from  表名 \n\n> 案例1: 查询所有栏目的id和名称\n\n      表:  ali_cate\n\n      字段:  cate_id、cate_name\n\n![1534213675206](/images/php/1534213675206.png)\n\n\n\n> 案例2: 查询管理员信息 (全部字段信息)\n\n      表: ali_admin\n\n      字段: 所有字段\n\n\n\n方式一:  在select和from之间，列出所有字段\n\n![1534213763761](/images/php/1534213763761.png)\n\n\n\n方式二: 使用 * 来代表所有字段\n\n![1534213822095](/images/php/1534213822095.png)\n\n\n##  2.2 带where子句的查询\n\n\nselect  field1, field2... from 表名  查询表中的所有数据\n\n  where 可以使用条件来筛选查询出的结果\n\n![img](/images/php/01.jpg) \n\n \n\n> 案例3: 查询id值为2的栏目的所有信息\n\n      表: ali_cate\n\n      字段:  *\n\n      筛选条件:  cate_id = 2\n\n![1534214952123](/images/php/1534214952123.png)\n\n\n\n> 案例4: 查询年龄大于等于25的管理员的邮箱和昵称\n\n      表: ali_admin\n\n      字段:  admin_email、 admin_nickname\n\n      筛选条件:  admin_age >= 25\n\n![1534215147258](/images/php/1534215147258.png)\n\n\n\n> 案例5: 查询年龄在23-28之间的管理员的所有信息\n\n      表: ali_admin\n\n      字段: *\n\n      筛选条件： admin_age>=23  and  admin_age<=28\n\n\n\n方法一:\n\n![1534215257922](/images/php/1534215257922.png)\n\n\n\n方式二:\n\n![1534215324315](/images/php/1534215324315.png)\n\n\n\n> 案例6: 查询年龄不在23-28之间的管理员的所有信息\n\n      表: ali_admin\n\n      字段: *\n\n      筛选条件： `admin_age<23  or  admin_age>28`\n\n方法一:\n\n![1534215426973](/images/php/1534215426973.png)\n\n\n\n方法二：\n\n![1534215454171](/images/php/1534215454171.png)\n\n\n\n> 案例7: 查询年龄大于25的男性管理员信息\n\n      表: ali_admin\n\n      字段:  *\n\n      筛选条件:  admin_age>=25 and admin_gender='男'\n\n![1534215590016](/images/php/1534215590016.png)\n\n\n\n\n##  2.3 in关键词\n\n集合:  一组相同类型的数据，使用()来包含，括号内使用 ， 分隔开\n\n(1, 2, 3, 4, 5)  (‘潮科技’, ‘会生活’, ‘奇趣事’, ‘美奇迹’)  \n\n \n\n> 案例8: 查询年龄为20、28的女性管理员信息\n\n      表： ali_admin\n\n      字段： *\n\n      筛选条件： admin_gender='女'  and  （admin_age=20 or admin_age=28）\n\n\n\n方式一:\n\n![1534215841500](/images/php/1534215841500.png)\n\n\n\n方式二：\n\n![1534215898938](/images/php/1534215898938.png)\n\n\n\n##  2.4 模糊查询\n\n通配符:\n\n  %: 代表任意长度(包括0)的任意字符\n\n  _:  代表1位长度的任意字符\n\n​    a%b :  ab  abb  a对萨达b\n    a_b: acb  atb  a的b\n    a_b%:  acb  a&baaad\n\nlike: 在执行模糊查询时，必须使用like来作为匹配条件\n\n\n\n> 案例9: 查询邮箱地址中包含字符h的管理员信息\n\n      表： ali_admin\n\n      字段： *\n\n      筛选条件： admin_email like '%h%'\n\n![1534216354094](/images/php/1534216354094.png)\n\n\n\n> 案例10: 查询包含“科技”关键词的文章信息\n\n      表： ali_article\n\n      字段： *\n\n      筛选条件：admin_title like ‘%科技%’\n\n![1534216526440](/images/php/1534216526440.png)\n\n\n\n\n\n> 案例11: 查询邮箱以a字符开头并且包含n的管理员信息\n\n      表： ali_admin\n\n      字段： *\n\n      筛选条件： admin_email like ‘a%n%’\n\n![1534216625722](/images/php/1534216625722.png)\n\n\n\n\n\n##  2.5 order by 排序\n\norder by 可以对查询结果按某个字段的升降进行排序\n\n  升序 asc （默认值） ，  降序 desc \n\n可进行排序的字段通常是  整型  英文字符串型  日期型  (中文字符串也行,但一般不用)\n\n\n\n> 案例12: 查询所有的栏目信息，并按别名的降序排列\n\n      表： ali_cate\n\n      字段：*\n\n      排序条件： cate_slug  desc\n\n![1534216794928](/images/php/1534216794928.png)\n\n\n\n> 案例13: 查询所有栏目信息，并按发布时间升序排列\n\n      表：ali_cate\n\n      字段： *\n\n      排序条件：cate_addtime asc\n\n![1534216877104](/images/php/1534216877104.png)\n\n\n\n> 案例14: 查询所有男性的管理员信息，并按照创建时间降序排列\n\n      表： ali_admin\n\n      字段：*\n\n      筛选条件： admin_gender='男'\n\n      排序：admin_addtime desc\n\n![1534217036912](/images/php/1534217036912.png)\n\n \n\n##  2.6 limit 限制\n\nlimit用来限制查询结果的起始点和长度\n\n 格式:  \n\n      limit  var1, var2\n\n\n var1: 起始点。 查询结果的索引，从0开始。 0代表第一条数据\n\n var2: 长度\n\n \n\n> 案例15: 查询年龄最大的3名男性管理员的信息\n\n      表： ali_admin\n\n      字段： *\n\n      筛选： admin_gender='男'\n\n      排序：order by admin_age desc\n\n      限制：limit 0,3\n\n\n\n![1534218129029](/images/php/1534218129029.png)\n\n\n\n> 案例16: 将文章按发布时间逆序排列，并取出第三条到第五条\n\n    表： ali_article\n\n    字段：*\n\n    排序： article_addtime desc\n\n    限制：limit 2,3\n\n![1534218422235](/images/php/1534218422235.png)\n\n\n\n将 *  解释成对应的字段需要 0.0001秒，但是人多了之后就会变慢。\n\n\n\n##  2.7 多表查询\n\n关键词: \n\n      join   on\n\n\n\n格式:  \n\n    select  *  from  表1\n\n    join 表2  on  链接条件\n\n链接条件一定是   表1的某个字段 =  表2的某个字段\n\n\n\n> 案例: 查询学生的全部信息，系别需要使用系名来进行显示\n\n      表： student     dept\n\n      字段: student.*   dept.dept_name\n\n\n\n![1534219437090](/images/php/1534219437090.png)\n\n\n\n\n\n原理:\n\n![1534219689703](/images/php/1534219689703.png)\n\n\n\n> 案例17: 查询所有文章信息，作者使用昵称显示\n\n表： ali_article   ali_admin\n\n字段： ali_article.*   ali_admin.admin_nickname\n\n![1534220115051](/images/php/1534220115051.png)\n\n\n\n> 案例18: 查询大牛发布的所有文章信息，作者使用昵称显示\n\n表： ali_article   ali_admin\n\n筛选： admin_nickname='大牛'\n\n![1534220239981](/images/php/1534220239981.png)\n\n\n\n> 案例19: 查询属于潮科技和奇趣事的所有文章\n\n表：ali_cate   ali_article\n\n筛选条件： cate_name in ('潮科技', '奇趣事')\n\n![1534220507814](/images/php/1534220507814.png)\n\n\n\n> 案例20: 查询所有文章信息，作者使用昵称显示，栏目使用栏目名显示\n\n表： ali_article    ali_admin   ali_cate\n\n![1534220828795](/images/php/1534220828795.png)\n\n\n\n","tags":["MySQL"]},{"title":"17-创建数据表","url":"%2F2017%2F04%2F25%2FPHP%2F17-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D%2F","content":"\n\n# 1. 关系型数据库\n\n##   1.1 关系型数据库简介\n\n> 案例: 创建一个数据表，能够保存学生的基本信息(学号、姓名、年龄等)和学生每一科的考试成绩\n\n1)  一张表的形式\n\n![img](/images/php/03.jpg) \n\n缺点: 重复数据太多（数据冗余）\n\n \n\n2) 关系型数据库:\n\n![1528187325051](/images/php/02.png)\n\n\n缺点: 表多\n优点:\n   数据耦合性低\n   每个数据表都能够独立管理\n\n##   1.2 student 和 dept表   \n\n 目标: 创建student和dept表用来存储学生的基本信息、学院基本信息和学生所属的学院信息\n\n![1534172874473](/images/php/04.png)\n\n\n\n   student：学生表，所需字段  学号、姓名、性别、年龄、系别\n\n```php\ncreate table student(\n  sno int UNSIGNED auto_increment primary key,\n  sname varchar(20) not null,\n  sage tinyint UNSIGNED not null,\n  sgender enum('男','女') not null,\n  sdept tinyint UNSIGNED not null\n)engine=myisam default charset=utf8;\n```\n\n\n\n   dept：系别表，所需字段  系号  系名\n\n```php\ncreate table dept(\n  dept_id tinyint UNSIGNED auto_increment primary key,\n  dept_name varchar(20) unique not null\n)engine=myisam default charset=utf8;\n```\n\n##   1.3 ali_admin、ali_cate和ali_article的关系\n\n   目标: 创建 ali_cate表和ali_article表，用来保存栏目基本信息、文章信息 以及 作者、栏目、文章的关系\n\n![05](/images/php/05.png)\n\n\n\nali_cate表（栏目表）： 栏目id (主键)、 栏目名、栏目别名、栏目创建时间\n\n```php\ncreate table ali_cate(\n  cate_id tinyint UNSIGNED auto_increment primary key,\n  cate_name varchar(10) unique not null,\n  cate_slug varchar(30) UNIQUE not null,\n  cate_addtime date not null\n)engine=myisam default charset=utf8;\n```\n\n\n\nali_article（文章表）： 文章id（主键）、文章标题、文章内容、文章作者、所属栏目、发布时间、文章状态（草稿、已发布）\n\n```php\ncreate table ali_article(\n  article_id int UNSIGNED auto_increment primary key,\n  article_title varchar(30) UNIQUE not null,\n  article_content text not null,\n  article_adminid int UNSIGNED not null,\n\tarticle_cateid tinyint UNSIGNED not null,\n  article_addtime int not null,\n  article_state enum('草稿','已发布')\n)engine=myisam default charset=utf8;\n```\n","tags":["MySQL"]},{"title":"16-创建数据表","url":"%2F2017%2F04%2F25%2FPHP%2F16-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8%2F","content":"\n# 创建数据表\n\n## 创建表的基本格式\n\n语句格式:\n\nCREATE TABLE 表名 (\n\n        列名     数据类型(长度)    完整性约束条件,\n\n        列名     数据类型(长度)    完整性约束条件,\n        ......\n  \n\n) engine=myisam default charset=utf8\n\n \n\n**注意事项:**\n\n   **列名、数据类型、长度是必有的； 完整性约束条件可以没有**\n\n   **最后的 utf8 没有 -**\n\n\n## 创建用户表 -- users\n\n---\n\n案例:  在cms数据库中，创建一张users数据表，该表中只保存用户id和用户名两个字段\n\n**一定要先选中 cms 库，再去打开查询编辑器**\n\n![](/images/php/1534046076681.png)\n\n![](/images/php/1534046277367.png)\n\nuid   int (5) :  uid字段是整型的，长度是5 (0--99999)\n\nuname varchar(20): uname字段是字符串类型，长度是20 \n","tags":["MySQL"]},{"title":"15-创建/删除数据库","url":"%2F2017%2F04%2F25%2FPHP%2F15-%E5%88%9B%E5%BB%BA%E3%80%81%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%2F","content":"\n# 创建/删除数据库\n\n操作数据库需要使用SQL语句（结构化查询语言）\n\n1) 创建数据库\n\n 语法格式: create database 库名;\n\n    示例:\n            create database study;   创建一个名为 study的数据库\n\n            create database cms:     创建一个名为 cms 的数据库\n\n![](/images/php/1534045491228.png)\n\n![](/images/php/1534045569648.png)\n\n![](/images/php/1534045609713.png)\n\n\n2) 删除数据库:\n\n  语法格式:  drop database 库名;\n\n  示例:   \n    \n        drop database school;  删除school库\n\n        drop database cms;      删除cms库\n\n![](/images/php/1534045702681.png)","tags":["MySQL"]},{"title":"14-MySQL数据库服务器","url":"%2F2017%2F04%2F25%2FPHP%2F14-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%2F","content":"\n# MySQL数据库服务器\n\n## 什么是数据库\n\n存储数据的仓库。\n\n常见的数据库: MySQL、 Oracle、 Sqlserver、 DB2等。\n\n## MySQL简介\n\n\nMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品 \n\nMySQL结构\n\n![img](/images/php/wps459D.tmp.jpg)\n\n在一个MySQL服务器中有多个数据库，每个数据库又有多个数据表。 数据是存储在数据表当中的。\n\n数据表的结构和excel一模一样\n\n![img](/images/php/wps459E.tmp.jpg)\n\n表结构:  \n\n   和excel表的结构是一样的。\n\n      每一列都是一类数据 --- 字段\n\n      每一行代表一条数据 --- 记录\n\n## 安装客户端\n\n    MySQL是一款C/S结构的软件。\n\n    MySQL本身是服务器端。\n\n常见的客户端: CMD 、 Navicat、 Sqlyog、 phpmyadmin等等\n\n\n\n安装 Navicat\n\n1.解压\n\n![img](/images/php/wps45C1.tmp.jpg)\n\n\n2.选择安装版本\n\n![img](/images/php/wps45C2.tmp.jpg)\n\n\n3.选择安装路径\n\n![](/images/php/1528170859377.png)\n\n继续下一步...\n\n4.链接服务器\n\n![img](/images/php/wps45C4.tmp.jpg)\n\n ① 点击“链接”按钮 ---  选择要链接的数据库种类\n\n![img](/images/php/wps45C5.tmp.jpg)\n\n  ② 配置链接信息\n\n      用户名： root       该用户是MySQL服务器系统的最高用户，拥有该系统的所有权限\n\n      密码：  root             phpstudy中MySQL系统root用户的默认密码\n\n\n![img](/images/php/wps45C6.tmp.jpg)\n\n  ③ 点击“localhost”结果\n\n![img](/images/php/wps45C7.tmp.jpg)\n\n  左侧的localhost下的内容都是数据库名称。\n\n  information_schema、mysql、performance_schema 这三个是系统数据库。\n\n  其他的都是自建数据库\n\n看到上图，说明已经使用navicat 客户端正常链接到了 MySQL服务器了。\n","tags":["MySQL"]},{"title":"13-Http协议","url":"%2F2017%2F04%2F25%2FPHP%2F13-Http%E5%8D%8F%E8%AE%AE%2F","content":"\n\n# Http协议\n\n## Http协议概述\n\n协议: 就是事先的一种约定、规则、规范、标准。（租房合同、工作合同）。\n\n    HTTP协议：HyperText Transfer Protocol 超文本传输协议，客户端（浏览器端）与WEB服务器端之间的交互协议。当浏览器和服务器进行数据交换时，html文件、图片、CSS、JS等都是基于HTTP协议进行传输的。\n\n  HTTP协议有两个版本: 1.0 和 1.1，目前使用的基本都是1.1\n\n  特点: \n\n    通常是基于 B/S 结构软件的。\n    无连接: 浏览器向服务器发送一次请求，服务器响应一次，链接即结束。\n    无状态: 无记忆。 服务器不能记住哪个浏览器访问过。 \n\n\n## 无连接 -- 没有持久化链接\n\n    当浏览器地址栏输入 www.baidu.com/index.html，按下回车时。浏览器向服务器发送请求。\n    服务器找到index.html文件返回给浏览器之后，本次链接断开。\n\n如果在点击该页面中任何一个链接，则重新建立一次链接。客户端发送请求，服务器响应。之后又断开链接。 \n\n![](/images/php/1528123196860.png)\n\n\n## 请求和响应\n\nHTTP协议主要分为两大部分: \n\n    请求:  访问服务器的任何一个文件都是一次请求\n    响应:  服务器处理请求，将结果返回给浏览器。\n\n\n## 请求( **request** / http request)(请求报文)\n\n\n客户端(浏览器)向服务器索要数据时遵循的协议\n\n> 请求分为3个部分:  请求行   请求头   请求主体\n> 请求行:  请求方式、请求URL地址、协议版本号\n\n    请求头:  主机域名，客户端(浏览器)的信息等\n\n    请求主体:  发送给服务器的数据，get和post都会通过请求主体将数据发送给服务器\n\n可以使用Chrome tools 或者 firebug 来查看请求和响应的信息（F12）\n\n       \n\n        主要请求项:\n\n\t  host： \n    \n            主机名和端口号，80端口默认不显示\n\n    accept：          可接受的程序类型\n    accept-encoding： 可接受的压缩类型\n    accept-language： 可接受的语言类型\n    cache-control：   缓存控制\n\n\n---\n\n案例1:  访问 localhost/php4/code/http/index.html 文件    \n\n![](/images/php/1534037686331.png)\n\n通过F12进行查看\n\n![](/images/php/1534037719460.png)\n\n点击 index.html就能看到右侧的三个信息\n\n![](/images/php/1534037758865.png)\n\n![](/images/php/1534037865601.png)\n\n案例2:  index.html表单数据提交到index.php文件\n\n![](/images/php/1534038374457.png)\n\n![](/images/php/1534038385472.png)\n\n\npost方式提交的数据叫  FormData，以字符串形式将数据进传递\n\n![1534038450547](/images/php/1534038450547.png)\n\n案例3:  index.html页面中a标签跳转到get.php文件\n\n![1534038586471](/images/php/1534038586471.png)\n\n![1534038596860](/images/php/1534038596860.png)\n\n![1534038629048](/images/php/1534038629048.png)\n\nget传值叫做  Query String Parameters\n\n![](/images/php/1534038670110.png)\n\n\n## 响应( **response** / http response)(响应报文)\n\n\n\t响应也分为3部分: \n  \n        响应行   \n        响应头   \n        响应主体\n\n\t响应行: 协议版本号、响应结果\n\n\n  **状态码**\n\n\n    响应头: 主要是服务器端的信息\n    响应主体: 就是从服务器返回给客户端的数据\n\n   主要响应项：\n\n    content-type： 响应内容类型， \n    content-type:text/html，服务器告诉浏览器，返回的这部分数据是文本类型，使用html方式来解析即可。\n    content-length： 响应内容的长度 ，content-length:336, 从服务器返回给浏览器的数据总长度为336字节\n\n---\n\n案例1: 访问 localhost/php4/code/http/index.html 文件时的响应信息\n\n![](/images/php/1534038956636.png)\n\n![](/images/php/1534039173890.png)\n\n\n案例2: index.html表单数据提交到index.php文件的响应信息\n\n\n\n案例3: index.html页面中a标签跳转到get.php文件的响应信息\n\n\n## 状态码\n\n常见的状态码如下: \n\n    200 ok   -----   请求成功\n\n    302 redirect|Found  ----- 重定向\n\n    304 not modified ----- 缓存文件\n\n    403 forbidden   -----  禁止访问 （没有权限访问）\n\n    404 Not Found  -----  未找到页面\n\n    500 internal server error  ----- 服务器内部错误 (可能是服务器本身有问题，或者代码错的太离谱)\n\n## header响应头设置\n\n## 设置响应类型\n\n    浏览器发起请求的方式是多样的，当发起请求后服务端会有对应的内容响应过来，浏览器会根据响应头==Content-Type==来对响应的内容进行解析\n\n    content-type主要的响应类型是  text/html   \n\n其他常见类型 :  text/css   text/javascript   image/png  image/jpeg  image/gif\n\n注意: \n      \n      所有的响应类型都是  大范围/小类型， 千万不能写反\n\n---\n\n案例1: php绘制的验证码 verify.php\n\n![](/images/php/1534040061590.png)\n\n![](/images/php/1534040079302.png)\n\n如果改为 text/html\n\n![](/images/php/1534040111085.png)\n\n![](/images/php/1534040123921.png)\n\n\n---\n\n案例2: link标签发送请求 \n\n① 创建html文件，使用link标签引入一个php文件\n\n![](/images/php/1534040360466.png)\n\n② 在h1.php文件中，设置响应类型（content-type为css）\n\n![](/images/php/1534040405398.png)\n\n\n访问结果:\n\n![](/images/php/1534040433662.png)\n\n\n\n\n## 指定字符集\n\n\n   中文字符集: utf-8  gb2312  gbk\n\n      header('Content-Type:text/html;charset=utf-8');\n\n      header('Content-Type:text/html;charset=gb2312');\n\n页面乱码问题处理方式：\n\n 页面乱码是因为 **文件编码** 和 **页面指定编码** 不一致，所以解决该问题就是要 **统一文件编码和页面指定编码**\n\n    ① 在页面中设置 header ，编码指定为 utf-8\n\n    ② 将文件的编码格式，指定为utf-8 (使用sublime，将保存格式设置为 utf-8 或者 使用editplus另存为文件时，设置utf-8)\n\n\n    如果 header设置为 utf-8，则文件编码格式也要设置为 utf-8\n\n    如果 header设置为 gbk，则文件编码格式要设置为 ANSI \n\n\n① 在sublime创建charset_utf8.php\n\n![](/images/php/1534041680058.png)\n\n访问结果:\n\n![](/images/php/1534041704258.png)\n\n\n② 在windows中直接创建 charset_gbk.php\n\n![](/images/php/1534041740929.png)\n\n访问结果:\n\n![](/images/php/1534041755891.png)\n\n原因:\n\n    sublime创建的文件是utf-8编码的，和页面中header设置的字符集一致，所以能正常显示。\n\n    windows创建的文件是ANSI编码的, 而页面中header设置的字符集是utf-8，两者不一致，所以乱码了。\n\n\n解决方案:\n\n    ① windows创建的文件，header要设置为 gb2312或者gbk\n\n    ② 将windows创建的文件，改为utf-8编码\n\n\n修改文件编码可以使用editplus或者sublime都行\n\n![](/images/php/1534042040846.png)\n\n![](/images/php/1534042064418.png)\n\n\n现在我们常用的sublime和vs，创建的都是utf-8编码格式的文件，所以，header要设置为 utf-8\n\n\n## 页面重定向\n\n     header('location:页面地址');\n\n     header('refresh:2;url=页面地址');\n\n![](/images/php/1534042530403.png)\n\n扩展内容:\n\n![](/images/php/1534042923833.png)","tags":["PHP"]},{"title":"12-PHP文件读写","url":"%2F2017%2F04%2F25%2FPHP%2F12-PHP%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F","content":"\n\n# 文件读写\n\n##  读取文件内容\n\n```php\n    string  file_get_contents(string $file);\n    参数: 文件路径，可以是本地文件的路径，也可以是网络地址\n    返回值: 文件内容\n```\n```php\n    /**\n     * 获取文件内容\n     * 参数: 要获取的文件的路径，该路径可以是本地文件路径，\n     *       也可以是网络文件路径\n     * 返回值: 文件内容\n     */\n    echo file_get_contents('./data.txt');\n    \n    echo file_get_contents('http://s1.bdstatic.com/r/www/cache/static/home/css/index.css');\n\n```\n\n## 向文件中写入内容\n\n```php\n    int file_put_contents(string $file, string $data[, constants flag]);\n    参数1: 文件路径\n    参数2: 要写入文件的字符串\n    参数3: 可选参数，默认不写，新内容覆盖原文件中的内容；FILE_APPEND是向文件中追加内容\n    返回值: 写入文件的字符串长度\n```\n\n\n## 序列化 和 反序列化\n\n\nfile_put_contents函数不能将数组直接写入文件，因为数组不能直接转化为字符串。\n\n   string  ==serialize==($arr):   将数组转为字符串，该字符串是一种特殊结构的字符串。\n\n   array  unserialize(string):   将序列化的字符串转为数组\n\n### 序列化:\n\n```php\n    $arr = [\n        ['name'=>'张飞', 'size'=>'1920*1200', 'path'=>'./pic/11.jpg'],\n        ['name'=>'吕布', 'size'=>'1920*1200', 'path'=>'./pic/10.jpg'],\n        ['name'=>'安琪拉', 'size'=>'1920*1200', 'path'=>'./pic/6.jpg'],\n    ];\n\n    /**\n    * 能将数组转为带有数组结构的字符串\n    */\n    echo serialize($arr);\n```\n\n结果:\n\n```php\n    a:3:{\n        i:0;a:3:{\n            s:4:\"name\";s:6:\"张飞\";\n            s:4:\"size\";s:9:\"1920*1200\";\n            s:4:\"path\";s:12:\"./pic/11.jpg\";\n        }\n        i:1;a:3:{\n            s:4:\"name\";s:6:\"吕布\";\n            s:4:\"size\";s:9:\"1920*1200\";\n            s:4:\"path\";s:12:\"./pic/10.jpg\";\n        }\n        i:2;a:3:{\n            s:4:\"name\";s:9:\"安琪拉\";\n            s:4:\"size\";s:9:\"1920*1200\";\n            s:4:\"path\";s:11:\"./pic/6.jpg\";\n        }\n    }\n```\n\n### 反序列化:\n\n```php\n    $str = file_get_contents('./data.txt');\n\n    /**\n    * 将结构化好的字符串转回成数组\n    * 参数: 结构化好的字符串\n    * 返回值: 数组\n    */\n    $arr = unserialize($str);\n    print_r($arr);\n```\n\n![](/images/php/1533959168968.png)\n\n---\n\n## 综合案例--壁纸管理\n\n目标：以表格形式将data.txt文件中所有的数据展示出来\n\n![](/images/php/1533895818621.png)\n\n思路分析：  \n\n  1) 从文件中读取数据 --- 字符串\n\n  2) 将字符串恢复成数组结构(unserialize) --- 二维数组  \n\n  3) 循环将数据进行输出\n\n\n代码实现:\n\n![](/images/php/1533960011212.png)\n\n\n\n\n\n###  添加新壁纸\n\n![](/images/php/1533892050303.png)\n\n思路分析:  三个文件完成该功能    表单页 、 数据处理页 、 数据保存文件\n\n    1) 表单页（upload.html）\n\n         保证数据能够正常提交，文件能够正常上传\n\n    2) 数据处理页 (upload.php)\n\n```\n    ① 文件上传\n    ② 接收表单数据\n    ③ 将数据写入data.txt文件\n```\n\n  i.  将接收到的数据构造成一个一维数组 ($info)\n\n             ii. 将data.txt文件中原有的数据取出，反序列化成二维数组 （$list）\n\n             iii. 将$info 追加到 $list中\n\n\t     iv. 将$list序列化后，再写回data.txt文件（覆盖）\n\n    3) 数据保存页 (data.txt)\n\n        在该文件中保存的数据必须是被序列化过的数组\n\n 代码实现:\n\n   add.html\n\n\n![](/images/php/1533961868828.png)\n\nadd_deal.php\n\n![](/images/php/1533961912216.png)\n\n![](/images/php/1533961954758.png)\n\n![](/images/php/1533961997564.png)\n\n\n关键点总结：\n\n  1) 表单页（upload.html）\n\n     表单要上传文件，所以必须有  enctype属性，必须使用post进行数据提交\n\n  2) 数据处理页（upload.php）\n```\n     ① 因为上传的必须是图片，所以要做检测上传文件类型，还要重命名文件防止覆盖\n     ② 创建数组用来保存表单接收的数据，数组应该有三个单元 (name  size  url)\n     ③ 要先将data.txt文件中的数据读出来。如果文件为空，则创建一个空数组，再将表单提交的数据追加到数组中；如果文件不为空，则反序列化成一个数组，再将表单数据追加到数组中。\n     ④ 将追加后的新数组序列化，再写入data.txt文件中\n\n```\n","tags":["PHP"]},{"title":"11-PHP函数","url":"%2F2017%2F04%2F24%2FPHP%2F11-PHP%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F","content":"\n# 常用函数\n\n## 日期函数\n\n```php\n    int time():  获取当前时间点的时间戳 -- 1970.1.1 00:00:00 到现在的秒数\n    string date(format $str, timestamp $int): 可以将时间戳转为年月日时分秒的形式\n```\n```php\n    date函数说明：\n\n    参数1: 要显示的时间格式\n    参数2: 时间戳, 可选参数, 如果不指定则为当前时间戳\n    返回值: 指定的时间格式\n\n    时间格式参数:\n    Y: 4位年\n    m: 带前导0的2位月\n    d: 带前导0的2位日\n    H: 带前导0的2位时\n    i: 带前导0的2位分\n    s: 带前导0的2位秒\n\n    修改时区有两种方法:\n    1)  使用函数 ---- date_default_timezone_set();      临时修改\n    2)  修改php配置文件 php.ini                         永久修改\n    北京时间: PRC (中国人民共和国)  或者  asia/shanghai (亚洲/上海)\n```\n\n\n在php.ini文件中永久修改时区的配置项\n\n![](/images/php/1533953422928.png)\n\n重启apache服务器，才能使最新的配置项生效。 （只要修改过Apache或者php的配置文件，就都需要重启Apache服务器才能生效。Apache配置文件 httpd.conf）\n\n![](/images/php/1533953606233.png)\n\n\n## 变量函数\n\n```php\n    bool empty($var): 判断变量是否为空。如果为空返回 true；反之，则返回false\n    bool isset($var): 判断一个变量是否被设置。 如果已设置返回true，反之，返回false\n    void unset($var): 删除变量，无返回值\n```\n\n\n## 数组函数\n\n```php\n    bool in_array(mixed, arr):  检查一个值是否存在于一个数组当中\n    array explode(delimiter, str): 使用一个字符串将另一个字符串分割为数组\n    string implode(str, arr):  使用一个字符串将一个数组链接为字符串\n```\n\n## 字符串函数\n\n```php\n    int strlen(str):  获取字符串长度\n    int strpos/strrpos($str, $char): 查询$char字符串在$str字符串中的第一次/最后一次出现的下标\n    string substr（str, start[, length]）:  字符串截取\n    string str_replace（search, replace, str）:  字符串替换\n    string trim（str）:  删除字符串左右两边的空格\n    void die/exit([str]): 结束当前脚本\n```","tags":["PHP"]},{"title":"10-PHP函数","url":"%2F2017%2F04%2F24%2FPHP%2F10-PHP%E5%87%BD%E6%95%B0%2F","content":"\n# 函数 \n\n## 什么是函数\n\n函数(function) 是一段完成指定任务的已经命名的代码块。\n\nPHP函数包括内置函数（系统函数）和自定义函数两类\n\n## 函数的格式\n\nPHP声明函数的方式和Javascript一致。\n```php\n    function  函数名称（[参数1 [,参数2 [,…]]]）\n    {\n        函数体;\n        \n        //如需函数有返回值时使用\n        [return 返回值;]\n    } \n``` \n\n\n## 变量的作用域\n\n\n 核心概念: 在函数体外定义的变量，在函数体内无效\n\n \t  \t   在函数体内定义的变量，在函数体外无效\n\n![](/images/php/1533949815695.png)\n\n- 全局变量 和 局部变量:\n    - 局部变量:  函数体内的变量，该变量只在函数范围内有效。\n    - 全局变量:  函数体外的变量，在整个php文件中都有效（除了函数）。\n\n\n## 文件包含\n\n\n文件包含一共有4个函数:   include、include_once、require、require_once\n\n  **文件A中包含文件B，那么文件B就相当于文件A的一部分。**\n\n  注意事项: \n```php\n    如果文件A和文件B定义了相同的变量，则会发生覆盖。\n    如果文件A和文件B定义了相同的函数，则会发生致命错误。\n```\n\n    include        require\n\n    include_once   require_once\n\n\n四个语句的区别：\n\n1) include在包含一个不存在的文件时，会产生一个Warning错误，程序不会中断继续执行；而require会产生Fatal错误，中断执行。\n\n2) include_once和require_once的区别：include_once只会加载一次相同的文件，而inlcude会加载多次。\n\n3) 在实际开发中基本使用 include_once或者require_once\n\n\n## static静态变量\n\n\n   当一个变量使用static进行修饰时，该变量在整个php页面运行过程中只有一份。\n\n  ![](/images/php/1533888584603.png)\n\n      每次调用 aaa() 函数时，都会去静态内存区寻找是否有 $i。如果没有，则创建$i并进行赋值；如果有，则直接使用，跳过赋值过程。\n\n    static在递归操作中非常有用。\n\n\n\n## global全局变量\n\n\n 如果在一个函数体内想强行使用函数体外定义的变量，可以使用global关键词来声明。\n\n ![](/images/php/1533952559547.png)\n\n    $GLOBALS的功能和global差不多，都不推荐使用。","tags":["PHP"]},{"title":"09-PHP文件上传","url":"%2F2017%2F04%2F24%2FPHP%2F09-PHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F","content":"\n# 文件上传\n\n 文件上传属于一种特殊的表单提交，也需要两个页面 ---  表单页  和   数据处理页。\n![](/images/php/1525424869723.png)\n\nupload.html表单页\n\n![](/images/php/1533787848965.png)\n\nupload.php 上传文件处理页\n\n![](/images/php/1533788030706.png)\n\n文件上传核心点总结:\n\n\n## 核心点一：表单设计\n\n\n\t表单标签form中必须额外增加 enctype属性，必须使用post提交表单\n\n\t文件域必须有name属性和值\n\n\n\n## 核心点二  ---  $_FILES\n\n\n$_FILES是一个二维数组，保存了上传文件的相关信息：\n\n 第一维下标是 文件域的name值\n\n 第二维有5个固定单元\n\n   name: 上传的文件名\n\n   type: 上传的文件类型\n\n   tmp_name: 上传文件在服务器临时存储的路径\n\n   error:  错误码，错误码有0-4  5个值。 等于0时，代表文件正常上传\n\n      0：代表正常上传，没有错误\n\n      1：代表上传文件大小超过了 php.ini中 upload_max_filesize 定义的大小\n\n      2：代表上传文件大小超过了 php.ini中 post_max_size 定义的表单最大值\n\n      3：文件只有部分被上传 \n\n      4：没有文件被上传 \n\n   size: 上传文件的大小  bit\n\n![](/images/php/1533545384816.png)\n\n\n## 核心点三  ---  move_uploaded_file**\n\n\n从$_FILES中我们可以知道，文件已经正常上传到服务器了。\n\n所以，接下来就需要将文件从临时保存路径，移动到我们希望保存的路径中。\n\nmove_uploaded_file (参数1， 参数2)；\n\n 参数1: 临时路径  --->  $_FILES['pic']['tmp_name']\n\n 参数2: 目标路径  --->  使用相对路径移动到当前目录下   ./ \n\n","tags":["PHP"]},{"title":"08-PHP超全局变量","url":"%2F2017%2F04%2F24%2FPHP%2F08-PHP%E8%B6%85%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F","content":"\n# 超全局变量(预定义数组)\n\n## 什么是超全局变量\n\n\n    超全局变量是PHP内置的变量，在每一个php文件中都可以直接使用。\n\n    特点: \n    在每个页面都能直接使用\n    内部都是**关联数组**结构\n\n>非常重要: $_GET、$_POST、$_SESSION、$_COOKIE、$_FILES\n知道: $_SERVER、$_REQUEST、$GLOBALS\n\n## $_SERVER\n\n$_SERVER记录了服务器和客户端的主要信息，和当前页面的信息\n![](/images/php/1533782283446.png)\n\n重点记住的内容:\n\n  REQURES_URI ： 访问的文件地址\n\n  SCRIPT_NAME： 脚本名称（路径）\n\n  PHP_SELF： 自身文件名\n\n  访问的文件的绝对路径。 此处的绝对路径是和域名绝对\n\n   /php2/code/server.php -->  localhost/php2/code/server.php\n\n\n## get/post方式接收表单数据\n\n\n    表单处理通常需要两个页面：\n\n      1)  form.html，表单页，用户可以在表单页上填写相关数据\n\n      2)  form.php ,  数据接收处理页， 接收用户在表单填写的数据，然后做进一步处理\n\n![](/images/php/1525418662232.png)\n\n\n代码实现：\n\nform.html\n\n![](/images/php/1533783297322.png)\n\nform.php\n![](/images/php/1533783312171.png)\n注意:  表单中每个域的name值，会作为$_POST的下标\n\n表单提交关键点总结:\n\n  表单页: form.html\n\n    1) 必须有form表单标签，form必须有action 和 method 两个属性\n\n- action: 指定表单数据提交的位置 ---  php/jsp/asp文件的路径\n- method: 表单提交的方式， post 、get(默认)\n\n    2) 每个表单域都要有name属性    input   select   textarea\n\n    3) 必须有submit类型的按钮\n\n   \n\n   数据接收处理页： form.php\n\n    1) method=post时，使用$_POST接收数据    \n\n    2) method=get时，使用$_GET接收数据\n\n    3) 不管是$_POST还是$_GET，都是一个关联数组，数组的下标就是表单域中 name 属性的值\n\n\n## 每种域和类型的提交方式\n\n 表单标签： form 、 **input 、 select 、 textarea**\n\n  **表单提交的实际上是每个域的value值**\n\n  1) input  type= text/password/hidden/email  提交的就是value属性中的值\n\n  2) input  type=radio  提交的是选中项的value值。**value必须设置，否则后端会接收 on**\n\n  3) input  type=checkbox  **在name的值后增加[] 转换成数组结构**，后端才能接收到所有的已勾选项\n\n  4) select  name值需要定义在select标签中； value定义在option中，每条option都有自己的value\n\n                 如果不定义option中的value，则会将option中间的内容发送到后端页面中\n\n  5) textarea  name值定义在textarea标签中，value没有显式的表示出来，就是开始标签和结束标签之间的内容\n\n![](/images/php/1533784655977.png)\n\n#  post和get的区别 (非常重要)\n\n## 通过URL地址栏来区分post和get\n\n\nget将提交数据拼接成字符串显示在URL地址栏中\n![](/images/php/1525423939656.png)\npost不显示\n![](/images/php/1525423862000.png)\n\n1) 提交方式\n\n- get会将数据显式的拼接到url地址栏中  (字符串)\n  例如： form.php?id=10001&username=heiheihei&passwd=123456&key=value....\n  key=value方式传参，多个参数之间使用&符号隔开\n\n         id、username、passwd等等（键/key）都是表单域的name值\n\n         1、heiheihei、123456等等（值/value）都是表单域的value值\n\n- post不会显示出来\n\n2) 传递数据量大小\n\n- post最小值是2M，默认8M，可以通过修改php配置(php.ini)文件来修改大小，理论上没有上限的。\n- get会受到浏览器的地址栏的限制。有的是2k，有的是8K(chrome)\n\n3) 应用范围不一样\n\n- post在绝大多数情况下都使用在表单提交中。\n- get的应用范围比较广。在a标签的href中，location.href中等都能使用get方式。\n![](/images/php/1533786580917.png)\n\n## $_REQUEST\n\n   $_REQUEST 即可以接收get方式提交的表单，也能接收post方式提交的表单。但是因为速度比较慢，所以现在被弃用。\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n","tags":["PHP"]},{"title":"07-PHP数组","url":"%2F2017%2F04%2F23%2FPHP%2F07-PHP%E6%95%B0%E7%BB%84%2F","content":"\n# 数组\n\n ```javascript\n    var  arr = [123, 'abc', 234];   \n    console.log(arr[1]); \n```\n   PHP的数组分为索引数组和关联数组两类:\n\n```php\n 索引数组: **下标是数字**的数组就是索引数组\n 关联数组: **下标是字符串**的数组就是关联数组 (重点)\n```\n\n格式：\n\n```php\n    $arr = array();\n    $arr = [];\n```\n```php\n    //声明索引数组\n    //               0         1         2\n    $arr1 = array('福禄娃', '海绵宝宝', '猪猪侠');\n    $arr2 = array(3=>'蜘蛛侠', 6=>'钢铁侠', 10=>'煎饼侠');\n    $arr3 = ['张无忌', '赵敏', '灭绝师太'];\n\n    //声明关联数组 -- 下标是字符串\n    $info = ['name'=>'张二狗', 'age'=>20, 'gender'=>'男'];\n    $goods_info = ['goods_name'=>'小米 8', 'goods_price'=>1999];\n```\n\n## 数组读写\n\n   不管是索引还是关联数组，都是通过下标来进行读写控制的。\n```php\n    echo $arr2[6];\n    //下标是字符串，一定要加引号\n    // 如果不加引号就会变为常量\n    echo $info['name'];\n\n    $goods_info['goods_name'] = '小米 note 3';\n```\n\n## 数组遍历\n\nforeach 语句结构，用来遍历数组(关联数组和索引数组均可)。\n\n格式: \n\n```php\n    foreach($arr as $key=>$value){程序体}\n\n    foreach($arr as $value){程序体}\n```\n\n$arr : 要遍历的数组   \n\n```php\n    $key: 单元的下标，可以是任意变量名\n    $value: 单元的值，可以是任意变量名\n```\n```php\n    <?php \n    $arr = ['张无忌', '赵敏', '灭绝师太'];\n\n    //第一次循环，将第一个单元取出\n    //将单元的下标，赋值给$key\n    //将单元的值， 赋值给$value\n    //第二次循环，将第二个单元取出，赋值步骤同上\n    foreach ($arr as $key=>$value) {\n        echo $key . \"-\" . $value . '<br>';\n    }\n\n\n    $goods_info = ['goods_name'=>'小米 8', 'goods_price'=>1999];\n    foreach ($goods_info as $k=>$v) {\n        echo $k . '-' . $v . '<br>';\n    }\n\n    //如果as后面只有一个变量，该变量就是数组的单元值\n    foreach ($goods_info as $value) {\n        echo $value;\n    }\n    ?>\n```\n\n## 二维数组和多维数组\n\n- 一维数组的单元中，保存了一个数组，那么该数组就是二维数组\n- 二维数组可以想象成一个表格\n- 二维数组同样也用下标来进行控制\n- 二维数组常用来存储一组相似/相关的数据\n- 二维数组的每个单元都保存一个一维数组，就是三维数组；三维数组的每个单元都保存一个数组就是四维数组； 依次类推，可以到n维。在一般开发中，最常用的是一维和二维数组，三维极少使用。\n \n![](/images/php/1533544335589.png)\n```php\n    //同质数据\n    $list = [\n    0=>['name'=>'zs', 'age'=>20, 'gender'=>'男'],\n    1=>['name'=>'ls', 'age'=>21, 'gender'=>'女'],\n    2=>['name'=>'ww', 'age'=>19, 'gender'=>'女'],\n    ];\n```\n\n## 遍历二维数组\n\n     核心思想： 使用foreach取出第一维的数据（数组），第二层通过下标输出\n```php\n    $list = [\n    0=>['id'=>1, 'name'=>'zs', 'age'=>20, 'gender'=>'男'],\n    1=>['id'=>2, 'name'=>'ls', 'age'=>21, 'gender'=>'女'],\n    2=>['id'=>3, 'name'=>'ww', 'age'=>19, 'gender'=>'女'],\n    ];\n\n    //通常在实际开发当中，都只用一层foreach;\n    //第二层数据的显示，使用$value[下标]\n    //$value是一位数组\n    //第一次循环: $value = ['id'=>1, 'name'=>'zs', 'age'=>20, 'gender'=>'男'];\n    //第二次循环: $value = ['id'=>2, 'name'=>'ls', 'age'=>21, 'gender'=>'女'];\n    //第三次循环: $value = ['id'=>3, 'name'=>'ww', 'age'=>19, 'gender'=>'女']\n    foreach ($list as $key=>$value) {\n        echo $value['id'] . ' ';\n        echo $value['name']. ' ';\n        echo $value['age']. ' ';\n        echo $value['gender'];\n        echo \"<br>\";\n    }\n```\n\n## 将数组输出成一个表格\n\n方式一 : 使用echo来输出整体的表格结构，再用foreach来循环输出tbody中的结构和数据\n```php\n    $list = [\n    0=>['id'=>1, 'name'=>'zs', 'age'=>20, 'gender'=>'男'],\n    1=>['id'=>2, 'name'=>'ls', 'age'=>21, 'gender'=>'女'],\n    2=>['id'=>3, 'name'=>'ww', 'age'=>19, 'gender'=>'女'],\n    ];\n\n    echo \"<table border='1' width='600'>\";\n    echo \"<thead>\";\n    echo \"<tr>\";\n    echo \"<th>编号</th><th>姓名</th><th>年龄</th><th>性别</th>\";\n    echo \"</tr>\";\n    echo \"</thead>\";\n    echo \"<tbody>\";\n    //以第一次循环为例\n    //$value = ['id'=>1, 'name'=>'zs', 'age'=>20, 'gender'=>'男'];\n    foreach ($list as $value) {\n        echo \"<tr>\";\n        echo \"<td>\".$value['id'].\"</td>\";\n        echo \"<td>\".$value['name'].\"</td>\";\n        echo \"<td>\".$value['age'].\"</td>\";\n        echo \"<td>\".$value['gender'].\"</td>\";\n        echo \"</tr>\";\n    }\n    echo \"</tbody>\";\n    echo \"</table>\";\n```\n\n方式二: 提前定义好表格结果，只循环tbody中的内容\n\n```php\n    <?php \n    //同质数据\n    $list = [\n    0=>['id'=>1, 'name'=>'zs', 'age'=>20, 'gender'=>'男'],\n    1=>['id'=>2, 'name'=>'ls', 'age'=>21, 'gender'=>'女'],\n    2=>['id'=>3, 'name'=>'ww', 'age'=>19, 'gender'=>'女'],\n    ];\n    ?>\n    <table border=\"1\" width=\"600\" class=\"a\">\n        <thead class=\"b\" style=\"color:red\">\n            <tr>\n                <th>编号</th>\n                <th>姓名</th>\n                <th>年龄</th>\n                <th>性别</th>\n            </tr>\n        </thead>\n        <tbody>\n            <?php foreach ($list as $value) { ?>\n            <tr>\n                <td><?php echo $value['id']; ?></td>\n                <td><?php echo $value['name']; ?></td>\n                <td><?php echo $value['age']; ?></td>\n                <td><?php echo $value['gender']; ?></td>\n            </tr>\n            <?php } ?>\n        </tbody>\n    </table>\n```\n\n\n## print_r函数\n\n   该函数不但能够输出基本类型，还能够输出数组，在项目开发时经常使用该函数查看数组中的所有数据。\n\n   debug的核心思想就是跟踪变量，一段程序中所有变量中保存的是自己需要的数据，程序才在自己的掌控之下。\n\n```php\n    $info = ['id'=>10001, 'name'=>'张飞', 'age'=>21, 'gender'=>'男'];\n    print_r($info);\n```\n\n![](/images/php/1533781004203.png)\n\n```php\n    $list = [\n    0=>['id'=>1, 'name'=>'zs', 'age'=>20, 'gender'=>'男'],\n    1=>['id'=>2, 'name'=>'ls', 'age'=>21, 'gender'=>'女'],\n    2=>['id'=>3, 'name'=>'ww', 'age'=>19, 'gender'=>'女'],\n    ];\n    print_r($list);\n```\n\n![](/images/php/1533781034981.png)\n\n使用 echo  来输出数组，则会得到以下错误\n\n![](/images/php/1533781096919.png)\n\n\n\n\n\n\n\n","tags":["PHP"]},{"title":"06-PHP流程控制","url":"%2F2017%2F04%2F23%2FPHP%2F06-PHP%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F","content":"\n# 流程控制\n\n## 选择结构  (if...else)\n```php\n        if(判断表达式){\n            程序块1;\n        } else {\n            程序块2;\n        }\n\n        if(判断表达式){\n            程序块;\n        } elseif(判断表达式) {\n            程序块;\n        } ...{\n        } else {\n            程序块;\n        }\n```\n\n小练习：判断三个变量中的最大值\n\n```php\n        header('content-type:text/html;charset=utf-8');\n        $a = 40;\n        $b = 50;\n        $c = 30;\n\n        if ($a > $b) {\n            if ($a > $c) {\n                echo '最大值是：$a';\n            } else {\n                echo '最大值是：$c';\n            }\n        } else {\n            if ($b > $c) {\n                echo '最大值是：$b';\n            } else {\n                echo '最大值是：$c';\n            }\n        }\n```\n\n小练习：判断时间，提示不同的问候语\n\n```php\n        header('content-type:text/html;charset=utf-8');\n        $time = 10; //此处应该动态获取当前时间（小时）。因为没有学过动态获取时间，先固定成某个值\n\n        if ($time >= 0 && $time < 6) {\n            echo \"凌晨好\";\n        } else if ($time >= 6 && $time < 12) {\n            echo \"上午好\";\n        } else if ($time >= 12 && $time < 18) {\n            echo \"下午好\";\n        } else if ($time >= 18 && $time < 24) {\n            echo \"晚上好\";\n        } else {\n            echo \"时间有误\";\n        }\n\n        #不允许这么写。没有这种语法 6 <=  $time  < 12\n```\n\n## 循环结构  (while / for / do...while)\n\n```php\n        while(判断表达式){\n            程序块;\n        }\n\n        for(赋值表达式; 判断表达式; 步进表达式){\n            程序块;\n        }\n\n        do{\n            程序块\n        } while(判断表达式)\n\n        下面循环执行几次?\n        for(i = 1; i == 1; $i++){}\n        for(i = 1; i = 1; $i++){}\n```\n\n小练习：输出1-100之间的偶数\n\n```php\n        for ($i = 1; $i <= 100; $i++) {\n            if ($i % 2 == 0) {\n                echo $i . \"<br>\";\n            }\n        }\n```\n小练习：输出九九乘法口诀表\n\n```php\n    for ($i = 1; $i <= 9; $i++) {\n        for ($j = 1; $j <= $i; $j++) {\n            echo $i * $j . \"&nbsp;\";\n        }\n        echo \"<br>\";\n    }\n```\n\n## 分支结构  (switch)\n\n```php\n        switch(变量){\n            case 值1:\n                程序块1；\n                break;\n            case 值2:\n                程序块2；\n                break;\n            ...\n            default:\n                程序块\n        }\n        \n        // 变量一般使用 : 整型  字符  字符串\n```\n\n小练习：不同语言的\"我爱你\"\n```php\n        header('content-type:text/html;charset=utf-8');\n        $lang = 'dasdsad';\n\n        switch ($lang) {\n            case 'zh-cn':\n                echo \"我爱你\";\n                break;\n            case 'en-us':\n                echo \"I love you\";\n                break;\n            case 'de-de':\n                echo \"Ich liebe dich\";\n                break;\n            case 'ja-jp':\n                echo \"あなたのことが好きです\";\n                break;\n            case 'fr-fr':\n                echo \"Je t'aime!\";\n                break;\n            default:\n                echo \"语种错误\";\n                break;\n        }\n```\n\n## 特殊语句  (continue、 break)\n\n- contiune: 结束当前循环，直接跳入下一次循环\n\n- break: 结束整个循环","tags":["PHP"]},{"title":"05-PHP变量","url":"%2F2017%2F04%2F23%2FPHP%2F05-PHP%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%2F","content":"\n# 变量\n\n变量命名规则：\n\n- 由字母、数字、下划线组成，必须以字母或者下划线起头\n- 变量的长度可以是任意的，但不能超过255个字符\n- 最前面需要加 $\n- 变量名最好有意义，能够做到见名知意\n- 当变量名由多单词组成时，最好使用下划线分割或者使用驼峰命名法\n- PHP变量区分大小写\n\n```php\n        <?php \n        // 正确的变量名\n        $int = 123;\n        $str = 'abc';\n        $str1 = \"def\";\n\n        // 变量名区分大小写\n        $INT = 234;\n\n        echo $int;\n        echo $INT;\n\n        // 推荐的变量名\n        $goods_name = \"华为 保时捷\";\n        $goodsPrice = 10888;\n\n        $a = 'big';\n        $big = 123;\n        echo $$a;  //可变变量  echo $big\n        ?>\n```\n\n思考：\n以下变量名哪些是正确的：\n\n```php\n    $a、  $var、  $_123、  $1b、  $b1c2、  $_#abc  \n```\n\n\n## 双引号和单引号的区别\n\n\n**双引号中的变量会被解释为值**\n\n**单引号中的变量会被解释为字符串**\n\n  单引号的执行速度会快于双引号的速度\n\n\n##  常量\n\n\n保存不会发生改变的数据(如：3.1415， 路径等)时，最好使用常量。\n\n 常量的使用方法：\n\n   1) 声明:  define(常量名,  常量值,  大小写区分标志);   \n\n\ttrue（不区分）/false（区分/默认）;\n\n   2) 调用:  echo  常量名;\n\n   ![](/images/php/1533698709352.png)\n\n\n##  运算符\n\n\n### 运算符种类\n\n- 算术运算符\n- 字符串运算符\n- 赋值运算符\n- 比较运算符\n- 逻辑运算符\n- 其他运算符\n\n算术运算符：\n\n![img](/images/php/wpsEA60.tmp.jpg)\n\n特殊案例:\n```php\n    $str = \"abc\";\n    $int = 20;\n    echo $str + $int;   //20\n\n    $str = \"5\";\n    $int = 20;\n    echo $str + $int;   //25\n```\n\n赋值运算符：\n\n![img](/images/php/wps7D4D.tmp.jpg)\n\n`$a += $b   $a = $a + $b`\n\n比较运算符：\n\n ![img](/images/php/wpsCF.tmp.jpg)\n\n逻辑运算符：\n\n![img](/images/php/wps5CD4.tmp.jpg)\n\n异或: (了解)\n```\n    true   xor   true   =  false\n    true   xor   false  =  true\n    false  xor   true   =  true\n    false  xor   false  =  false\n```\n\n其他运算符：\n\n![img](/images/php/wps3355.tmp.jpg)\n\n三元运算符: 判断表达式？值1：值2\n\nphp默认内置有4种错误： \n\n```\n    notice：         通知错误\n    Warning error：  警告错误\n    Parse error：    解析错误\n    Fatal error：    致命错误 \n```\n@不能屏蔽掉所有的错误。 也不建议在实际开发中使用该符号\n```php\n        <?php \n        // 语法错误是不能被屏蔽掉的\n        @$books = \"JavaScript\"\n        echo $books;\n\n        // 大多数其他错误是可以被屏蔽掉的\n        @abc();\n        ?>\n```\n\n\n##  字符串链接运算符\n\n- 字符串拼接:  （ . ）  \n\n        在php中字符串拼接:   .  \n\n        与js中的 + 号 拼接符使用方式一致\n   \n   在php中  + 号 是运算符。\n\n","tags":["PHP"]},{"title":"04-PHP运行原理","url":"%2F2017%2F04%2F23%2FPHP%2F04-PHP%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%2F","content":"\n# PHP运行原理\n\n##HTML运行原理\n\n![](/images/php/1525248413592.png)\n\n1) 在浏览器的URL地址栏中输入 www.baidu.com/index.html 地址，点回车。请求就发送给百度服务器。\n\n2) 百度服务器找到index.html文件，并将文件的内容返回给浏览器\n\n3) 浏览器接收到index.html中的内容，渲染到页面上。\n\n同理: localhost/a.html ,  则会返回 本机web服务器根目录下 a.html文件的内容。浏览器拿到内容后进行渲染。\n\n\n## PHP运行原理\n\n **apache不认识php**\n\n **浏览器也不认识php**\n\n ![](/images/php/1525248877964.png)\n\n\n 1) 在浏览器地址栏中输入 localhost/index.php ,点回车之后。将请求发送给apache服务器。\n\n 2) 服务器找到 index.php文件之后，转发给php解释器\n\n 3) php解释器将index.php文件中的php代码全部转为html，再返回给apache\n\n 4) apache将处理好的html返回给浏览器，浏览器渲染后就可以看到页面\n\n\n\n ## PHP的数据类型\n \n\n  **PHP数据类型一共有8种:**\n\n- 基本类型(标量):\n\n        整型: 整数， 例如: 10, 234, -20, -35 \n        浮点型:  小数,  例如: 3.1415, 2.13, 35.123\n        布尔值:  true/false\n        字符串:  使用单引号/双引号包含的内容, 例如: ‘abc’, “王者荣耀”\n\n- 复合类型:\n\n        数组\n\n        对象\n\n- 特殊类型:\n\n        资源 \n        null (空)\n\n","tags":["PHP"]},{"title":"03-PHP介绍","url":"%2F2017%2F04%2F23%2FPHP%2F03-PHP%E5%88%9D%E8%AF%86%2F","content":"\n# 初识PHP\n\n## 第一个程序 --- Hello World\n\n1) 在WWW目录下创建如下目录结构： php1/code/\n\n2) 在code目录下创建  hello.php 文件\n\n3) 使用sublime（或其他编辑器）打开hello.php，编写如下代码\n\n4) 访问测试 \n\n     在浏览器中输入：localhost/php1/code/hello.php\n\n![](/images/php/1533694176851.png)\n\n\n##  程序解析\n\n\n1) **php文件不能使用中文进行命名， 浏览器地址栏不允许出现中文**———在实际开发中摒弃中文\n\n2) **在浏览器中查看任何文件（不管是html还是php）都必须使用localhost**\n\n3) PHP程序可以和HTML进行混编，可以写在HTML中的任何位置，head、body，任何标签，任何属性均可\n\n4) php语言的标记\n```php\n <?php  php代码  ?>   标准标记\n <?     php代码  ?>   短标记（需要修改php.ini文件打开）\n```\n\n5) 指令分隔符：**必须使用**（不然会报错）\n```php\n PHP语句使用 ‘;’  结束     \n```\n\n6) echo相当于js的 document.write 能够在页面上输出内容，包括输出标签、css样式代码等\n\n7) php文件中可以编写html、css、js代码，但是html文件中不能编写php代码。也就是说**后缀是php的文件才能编写php代码**\n\n\n## URL解析\n\n### URL地址说明\n\nURL: uniform resource locator  统一资源定位器\n\n       localhost  <==>  http://localhost:80/index.html （全URL）\n\n- http: 超文本传输协议\n- localhost: 域名。（一般域名：www.taobao.com，www.sina.com.cn） localhost是特殊域名，每一台电脑都有，并且指向当前使用的电脑\n- 80: 端口号。 apache的默认端口号为80，所以可以省略不写  (tips:很多web服务器默认端口都是80 Nginx IIS)\n- index.html: 访问的文件的路径 (localhost指向了 d:/phpstudy/WWW)，所以该url地址访问的是  d:/phpstudy/WWW/index.html文件\n- 如果没有指定访问的文件，则默认会访问index.html文件；如果没有index.html文件，则会以列表形式显示当前目录下的所有文件夹和文件\n  localhost:  D:\\phpStudy\\WWW\n\n### IP\n\nIP: Internet Protocol  互联网协议，是为计算机网络相互连接进行通信而设计的协议。\n\n    处于网络（互联网、局域网）上的任何一台计算机都有一个独立的ip地址。\n```\nip地址由4段3位长度的数字组成， 3位数字的取值范围 0-255。如： 102.15.201.10\n```\n\n特殊ip:\n```\n127.0.0.1 : 回环地址，每一台电脑都有该ip，指向当前使用的电脑\n192.168.**.* *: 该网段是专门用于做==局域网==的ip段。\n```\n\n### 域名\n\n域名（Domain Name）： 每个网站都有一个自己的域名。人们可以在浏览器中输入域名来访问对应的网站。\n\n    淘宝: www.taobao.com\n\n    百度: www.baidu.com\n\n\n特殊域名：\n```\n   localhost: 本地主机。在浏览器中输入localhost就会访问当前操作的这台电脑的web服务器。\n```\n\n###  DNS\n\n  DNS: Domain Name System  域名系统。在DNS服务器中保存了域名和IP的映射关系。主要工作是将域名转换为IP地址，因为我们通过浏览器访问网站时，实际上是去找对应的IP地址。\n\n   域名: 网站的名称，就相当于人名。\n\n   IP: 网站在网络上的实际地址，就相当于人的住址。\n\n      一般访问网站时都是输入域名的(例如： www.tmall.com  www.163.com)，但是在实际访问时域名会被DNS转换为IP地址。\n\n   DNS工作机制图:\n   ![](/images/php/1533537911304.png)\n\nhosts文件可以手动设置域名和IP的映射关系\n\ndns缓存可以保存曾经访问过的域名和IP的映射关系\n\n\n工作步骤:\n\n1)  在浏览器中输入  www.taobao.com，按下回车\n\n2)  浏览器首先在本机中的 hosts文件和dns缓存中查询，www.taobao.com的IP地址。如果有，则获取该IP地址，然后去访问淘宝服务器。 如果没有，则向dns服务器发送解析请求。\n\n3) dns服务器获取到浏览器请求信息之后， 将域名转换为IP地址，再将IP地址返回给浏览器。\n\n4) 浏览器获取到IP地址，然后通过IP地址访问淘宝服务器。 \n\n\n windows下查看dns缓存:\n\n ```\n  windows下查看dns缓存:\n ```\n\n思考：IP地址和域名是不是一一对应的？\n\n  有域名没有IP； 有IP没有域名；一个IP可以对应多个域名。\n\n\n### 端口\n\n 端口是英文port的意译。端口可以理解为区分服务器上服务的标号。\n\n   已被占用的著名端口号：\n\n```\n80:   Web端口号， Apache、Nginx、IIS\n21:   FTP端口号， FTP软件\n22:   SSH端口号\n25:   sendmail端口号\n......\n```\n\n因为Web服务的默认端口号是80，所以在地址栏可以不输入，但是如果将端口号改为其他的（如：8088），那就必须输入端口号，才能正常访问。\n\n![](/images/php/1527767769377.png)","tags":["PHP"]},{"title":"02-PHP安装环境 （phpstudy）","url":"%2F2017%2F04%2F23%2FPHP%2F02-PHP%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%2F","content":"\n\n# 安装环境 （phpstudy）\n\n>  phpstudy是一个集成环境，集成了Apache（IIS和nginx）、PHP、MySQL。 安装该软件后，PHP开发的程序就能运行了。\n\n## 准备工作\n\n解压phpstudy包\n![](/images/php/1523379032499.png)\n\n解压后:\n\n![](/images/php/1523379104282.png)\n\n## 安装\n\n双击安装文件即开始安装\n\n   特别注意: **phpstudy**的安装路径中**不允许出现中文**，今后安装所有开发相关的软件时也都安装在英文路径下\n    \n![](/images/php/1523379251895.png)\n\n此处选择“是”\n\n(也许会在这之前弹出一个空白的网页，不要管他，关闭就会出现下面的情况)\n![](/images/php/1523379346800.png)\n\n设置防火墙允许访问， **Apache和MySQL**都要允许\n\n![](/images/php/1523379425748.png)\n\n开启Apache和MySQL服务： **绿色圆圈表示启动， 红色方块表示停止**\n\n![](/images/php/1523379454261.png)\n\n打开浏览器输入\n\n测试:  开启任意浏览器，输入下列地址\n\n  127.0.0.1  、  127.0.0.1:80\n\n  localhost  、  localhost:80\n\n![](/images/php/1523379608850.png)\n\n看到上图说明已经安装成功\n\n\n## phpstudy目录结构\n\n\n![](/images/php/1523380423065.png)\n\nphpstudy集成了 Apache、IIS、nginx三种最常见的web服务器软件和多个版本的PHP，并且通过图形化控制面板（phpstudy.exe）可以自由切换\n\n切换服务器和php版本：  默认使用的是  **Apache + php-5.4.45**\n\n![](/images/php/1523380821032.png)\n\n\n## Apache目录结构\n\n\n![](/images/php/1523380676384.png)\n![](/images/php/1523380739318.png)\n配置文件中带 # 的都是注释项，不带的是有效的配置项\n![](/images/php/1523381071356.png)\n\n主要配置项：\n![](/images/php/1523381009030.png)\n\n重点:\n\n  **Listen: 如果报80端口被占用可以修改为其他值，例如：8088**\n![](/images/php/1523381364324.png)\n\nDocumentRoot: 配置html、css、js、php等文件保存的路径。\n\n浏览器中输入localhost或者127.0.0.1，系统就会去DocumentRoot指定的目录去寻找对应的文件。\n![](/images/php/1525313932857.png)\n\nDirectoryIndex:  默认访问文件配置\n![](/images/php/1525314000860.png)\n\nlocalhost =>  localhost/index.html\n\nlocalhost : 首先在www目录下找 index.html；如果没有index.html，找index.php；如果没有Index.php找index.htm；没有则找 l.php。  如果连 l.php都没有，则会将 www 目录下的所有文件和文件夹以列表形式显示出来\n\n\n\n## PHP目录结构\n\n\n![](/images/php/1523380928859.png)\n\nphp.ini: php配置文件。  进入到 php-5.4.45目录\n![](/images/php/1525314434763.png)\n带 ； 是注释，不带的是有效配置项\n\n\n### WWW目录\n\n\n我们今后编写的所有网页文件（html、css、js、php）和网页所需要的资源文件（图片、音频、视频） 都需要保存在该目录下。\n![](/images/php/1525244224450.png)\n\n当我们通过浏览器访问任意页面时，都需要在浏览器的url地址栏输入类似地址来进行访问，不论是php文件还是html文件。\n\n例如：\n\nlocalhost/index.html       localhost/admin/showlist.php\n\nlocalhost会找  d:/phpstudy/www 目录下的文件","tags":["PHP"]},{"title":"01-PHP介绍","url":"%2F2017%2F04%2F22%2FPHP%2F01-PHP%E4%BB%8B%E7%BB%8D%2F","content":"\n# PHP介绍\n\n## 前言:\n\n> PHP是现在非常流行的一种后端开发语言，常见的语言还有：JSP、ASP.NET、 Ruby等。相对于其他的语言来讲，PHP更容易上手，并且开发速度快、功能强大。\n\n## web服务器\n\n### 什么是服务器？\n\n > 服务器可以从硬件、软件(系统软件、应用软件)两个角度描述。\n\n> 按硬件描述： 服务器就是一台超级计算机。\n\n> 按系统划分： 在硬件上安装了什么操作系统，就可以称为该系统的服务器\n```\n    例如:  linux服务器、windows服务器、unix服务器等。\n```\n> 按软件划分： 在操作系统中安装了什么软件，就可以称作该软件的服务器\n```\n   例如:  ==web服务器、数据库服务器==、邮件服务器等。\n```\n### Web服务器\n\n> Web服务器就是安装了Web服务软件，能够提供网站服务的服务器。淘宝、京东、新浪等等\n-   常见的Web软件：\n```\nApache、Nginx、IIS、Tomcat、Node等。\nApache服务器、Nginx服务器、IIS服务器、Tomcat服务器、Node服务器\n```\n\n> Apache是世界使用排名第一的Web服务器软件。我们将编写好的html、css、js等文件存入apache，就能够通过网络来访问这些文件了。\n\nPS: web服务器又叫做http/httpd服务器\n![](/images/php/1527767382808.png)\n\n## PHP概述\n\n### PHP简介\n\n>   PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。主要适用于**Web领域的开发**，能够完成**动态网页**的制作。\n\n- 例如：淘宝的搜索功能，不同的关键词能够动态产生不同的网页。\n![](/images/php/1533535903794.png)\n\n\n### PHP特点\n\n\n- PHP是目前最流行的网站开发语言（B/S结构）之一。\n- PHP是一种在服务器端执行的嵌入HTML文档的脚本语言。\n- PHP 独特的语法混合了 C、Java、Perl 以及 PHP 自创新的语法。\n- **PHP是一种解释型弱类型语言 （弱类型  解释执行 / 强类型  编译执行）**\n- 支持几乎所有流行的数据库以及操作系统。\n- 源码开放、免费（free）  zend\n\n\n### B/S结构和C/S结构\n\n- C/S软件体系结构，即Client/Server (客户机/服务器)结构。\n  ```\n   核心特点：要下载一个客户端，例如：QQ、微信、LOL、王者荣耀、绝地求生等。   \n  ```\n\nC/S结构的软件，服务器主要做**数据转发**工作。以QQ聊天为例：\n```\n任何两个人聊天的内容都会发送到QQ服务器上，然后再由QQ服务器进行转发\n```\n\n 例：王小贱和小仙女聊天\n ```\n    王小贱发送一句话，这句话会先发送到QQ服务器，再由QQ服务器转发到小仙女的客户端。\n ```\n ![](/images/php/1525243346757.png)\n\n- B/S软件体系结构，即Browser/Server （浏览器/服务器）结构。\n\n  B/S结构软件，服务器承担了所有业务，浏览器只是用来显示最终内容的。\n\n![](/images/php/1525243588778.png)\n\n\n> 思考问题： B/S的优势和劣势， C/S的优势和劣势。\n\n> **B/S的优势: 部署方便，容易维护。用户使用方便（一个浏览器即可）。**\n\n> **B/S的劣势: 客户端功能简单**\n\n> **C/S的优势: 功能强大**\n\n> **C/S的劣势: 必须下载客户端非常麻烦，升级维护麻烦**\n\n\n\n    \n\n\n","tags":["PHP"]},{"title":"16-jquery操作DOM(节点)","url":"%2F2017%2F03%2F26%2FjQuery%2F16-jQuery%E6%93%8D%E4%BD%9CDOM%E8%8A%82%E7%82%B9%2F","content":"\n# jquery操作DOM(节点)\n\n## 创建元素\n\n```javascript\n    //$(htmlStr)\n    //htmlStr：html格式的字符串\n    $(“<span>这是一个span元素</span>”);\n```\n\n## 添加元素\n\n### 添加新建的元素\n\n```javascript\n    //方法一：将jQuery对象添加到调用者内部的最后面。 \n    var $span = $(“<span>这是一个span元素</span>”);\n    $(“div”).append($span);\n\n    //方法二：参数传字符串，会自动创建成jquery对象\n    $(“div”).append(“<span>这是一个span元素</span>”);\n```\n\n### 添加已经存在的元素\n\n```javascript\n    var $p = $(“p”);\n    $(“div”).append($p);\n    //注意：如果添加的是已经存在的元素，那么会把之前的元素给干掉。（类似于剪切的功能）。\n```\n类似的用法：append  prepend  after before\n\n\n### 使用html方法创建元素\n\n```javascript\n    //设置内容\n    $(“div”).html(“<span>这是一段内容</span>”);\n    //获取内容\n    $(“div”).html()\n```\n\n### 清空元素\n\nempty：清空指定节点的所有元素，自身保留(清理门户)\n```javascript\n    $(“div”).empty();//清空div的所有内容（推荐使用，会清除子元素上绑定的内容，源码）\n```\n\n### 清空元素的第二种方法\n\n```javascript\n    $(“div”).html(“”);//使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。\n```\n\n### 删除元素\n\n- remove：相比于empty，自身也删除（自杀）\n```javascript\n    $(“div”).remove();\n```\n\n### 克隆元素\n\n- 作用：复制匹配的元素\n```javascript\n    // 复制$(selector)所匹配到的元素（深度复制）\n    //cloneNode(true)\n    // 返回值为复制的新元素，和原来的元素没有任何关系了。即修改新元素，不会影响到原来的元素。\n    $(selector).clone();\n```","tags":["jQuery"]},{"title":"15-jquery动画","url":"%2F2017%2F03%2F25%2FjQuery%2F15-jQuery%E5%8A%A8%E7%94%BB%2F","content":"\n# jquery动画\n\n通过下拉菜单引入动画。\n\njquery提供了三组动画，这些动画都是标准的、有规律的效果，jquery还提供了自定义动画的功能。\n\n## 显示与隐藏\n\n显示(show)与隐藏(hide)是一组动画：\n\n### show方法详解：\n\n```javascript\n    show([speed], [callback]);\n    //speed(可选)：动画的执行时间\n    1.如果不传，就没有动画效果。\n    2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐)\n    3.固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal。\n    //callback(可选):执行完动画后执行的回调函数\n```\n\n### hide方法详解：\n\n与show方法的用法完全一致。\n\nshow/hide：修改的是元素的width、height、opacity。\n\n\n### 滑入与滑出\n\n\n滑入(slideUp)与滑出(slideDown)是一组动画，效果与卷帘门类似\nslideUp/slideDown,使用方法与show/hide基本一致。\n```javascript\n    slideUp(speed, callback);\n    //speed(可选)：动画的执行时间\n    1.如果不传，默认为normal，注意区分show/hide。\n    2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐)\n    3.固定字符串，slow(200)、normal(400)、fast(600)\n    //callback(可选):执行完动画后执行的回调函数\n```\n\n### 滑入滑出切换\n\n```javascript\n    $(selector).slideToggle(speed,callback);\n    //如果是隐藏状态，那么执行slideDown操作，如果是显示状态，那么执行slideUp操作。\n```\nslideUp/slideDown：修改的是元素的height\n\n\n### 淡入与淡出\n\n> fadeIn/fadeOut使用方法与show/hide、slideDown/slideUp一致。\n```javascript\n    fadeIn(speed, callback);\n    //speed(可选)：动画的执行时间\n    1.如果不传，默认是normal。\n    2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐)\n    3.固定字符串，slow(200)、normal(400)、fast(600)\n    //callback(可选):执行完动画后执行的回调函数\n```\n\n### 淡入淡出切换：\n\n```javascript\n    fadeToggle(speed, callback);\n    //如果当前元素处于隐藏状态，那么执行fadeIn操作，如果处于显示状态，那么执行fadeOut操作。\n```\n\n### 淡入淡出到某个值\n\n与淡入淡出的区别：淡入淡出只能控制元素的不透明度从 完全不透明 到完全透明；而fadeTo可以指定元素不透明度的具体值。并且时间参数是必需的！\n```javascript\n    fadeTo(speed, value, callback)//可以设置具体的透明度\n    //speed（必须）\n    //value  0-1之间的数值(比如0.4)，表示淡到某一个值。\n    //callback(可选) 回调函数\n```\n- fade系列方法：修改的是元素的opacity\n\n\n\n- 1.jQuery给我们提供了三组动画，show/hide、slideUp/slideDown、fadeIn/fadeOut\n\n- 2.动画切换方法：slideToggle、fadeToggle，注意：show和hide没有切换的方法。\n\n- 3.淡入淡出到某个值：fadeTo方法。\n- 4.show/slideDown/fadeIn三个是显示效果、hide/slideUp/fadeOut三个是隐藏效果。\n- 5.show/hide修改的是元素的height,width,opacity。slide系列方法修改的是元素的height。fade系列方法修改的是元素的opacity。这三种方法修改的这些值，都是带数字的，因为带了数字才能做渐变。\n\n## 自定义动画\n\n### animate：自定义动画\n\n```javascript\n    $(selector).animate({params},[speed],[callback]);\n    // {params}：要执行动画的CSS属性，带数字（必选）\n    // speed：执行动画时长（可选）\n    // callback：动画执行完后立即执行的回调函数（可选）\n```\n\n### 动画支持的属性 \n\n\n#### 动画支持的属性：\n\n\n\thttp://www.w3school.com.cn/jquery/effect_animate.asp\n\n\n##### easing参数\n\n\n控制动画在不同元素的速度，默认为“swing”\n\n“swing”：在开头和结尾移动慢，在中间移动速度快\n\n“linear”：匀速移动\n\n## 动画队列问题\n\n引出事件队列效果\n\n在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行（联想：地铁进站）。\n\n## 停止动画\n\n\n### stop方法：停止动画效果\n\n```javascript\n    stop(clearQueue, jumpToEnd);\n    //第一个参数：是否清除队列\n    //第二个参数：是否跳转到最终效果\n```\n**最常用的停止动画：stop();**\n\n","tags":["jQuery"]},{"title":"14-jQuery操作样式","url":"%2F2017%2F03%2F25%2FjQuery%2F14-jQuery%E6%93%8D%E4%BD%9C%E6%A0%B7%E5%BC%8F%2F","content":"\n# jQuery操作样式\n\n## css操作\n\n\n- 功能：设置或者修改样式，操作的是style属性\n\n### 设置单个样式\n\n```javascript\n    //name：需要设置的样式名称\n    //value：对应的样式值\n    css(name, value);\n    //使用案例\n    $(\"#one\").css(\"background\",\"gray\");//将背景色修改为灰色\n```\n\n### 设置多个样式\n\n```javascript\n    //参数是一个对象，对象中包含了需要设置的样式名和样式值\n    css(obj);\n    //使用案例\n    $(\"#one\").css({\n        \"background\":\"gray\",\n        \"width\":\"400px\",\n        \"height\":\"200px\"\n    });\n```\n\n### 获取样式\n\n```javascript\n    //name:需要获取的样式名称\n    css(name);\n    //案例\n    $(\"div\").css(\"background-color\");\n```\n- 注意：获取样式操作只会返回第一个元素对应的样式值。\n\n\n## class操作\n\n### 添加样式类\n\n```javascript\n    //name：需要添加的样式类名，注意参数不要带点.\n    addClass(name);\n    //例子,给所有的div添加one的样式。\n    $(\"div\").addClass(\"one\");\n```\n\n### 移除所有样式类\n\n```javascript\n    //不带参数，移除所有的样式类\n    removeClass()\n    //例子，移除div所有的样式类\n    $(\"div\").removeClass();\n```\n\n### 移除单个样式类\n\n```javascript\n    //name:需要移除的样式类名\n    removeClass(\"name\");\n    //例子，移除div中one的样式类名\n    $(\"div\").removeClass(\"one\");\n```\n\n### 判断是否有样式类\n\n```javascript\n    //name:用于判断的样式类名，返回值为true false\n    hasClass(name)\n    //例子，判断第一个div是否有one的样式类\n    $(\"div\").hasClass(\"one\");\n```\n\n### 切换样式类\n\n```javascript\n    //name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。\n    toggleClass(name);\n    //例子\n    $(\"div\").toggleClass(\"one\");\n```\n- 经验总结：\n\n1.如果操作到的样式非常少，可以考虑css方法\n\n2.如果操作到的样式非常多，那么可以通过class方法来操作，将样式写到一个class类里面。\n\n3.如果考虑到后期维护方便，将css从js中分离出来，那么推荐使用class的方式来操作。","tags":["jQuery"]},{"title":"13-jQuery插件机制","url":"%2F2017%2F03%2F24%2FjQuery%2F13-jQuery%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%2F","content":"\n\n# jQuery插件机制\n\n## 第三方插件\n\njQuery有着丰富的插件，使用这些插件能给jQuery提供一些额外的功能。\n\njquery.color.js\n\n\tanimate不支持颜色的渐变，但是使用了jquery.color.js后，就可以支持颜色的渐变了。\n\n如何使用第三方插件：\n\n1.引入jQuery文件\n\n2.引入插件\n\n3.使用插件\n\n\n## 制作插件\n\n- jQuery对象扩展方法\n```javascript\n    $.fn. pluginName = function() {};\n```\n\n## jQuery UI\n\n- jQueryUI专指由jQuery官方维护的UI方向的插件。\n\n官方API：\nhttp://api.jqueryui.com/category/all/\n\n其他教程：jQueryUI教程\n\n基本使用:\n\n1.引入jQueryUI的样式文件\n\n2.引入jQuery\n\n3.引入jQueryUI的js文件\n\n4.使用jQueryUI功能\n\n","tags":["jQuery"]},{"title":"12-jQuery多库共存","url":"%2F2017%2F03%2F24%2FjQuery%2F12-jQuery%E5%A4%9A%E5%BA%93%E5%85%B1%E5%AD%98%2F","content":"\n# 多库共存\n我们知道jQuery占用了$这个标识符，如果引用的其他库也用到$这个标识符，这时候为了保证每个库都能正常使用，这时候就存在了多库共存的问题。\n\n后引入的$的会覆盖掉先引入的库中的$。\n\n$ === jQuery\n\n解决办法：\n\njQuery的$和jQuery是两个相同的变量，因此遇到多库共存的时候，可以让jquery交出$符的控制权，这个时候还是可以使用$.\n```javascript\n    console.log($);//function(selector, context){}\n    //$.noConflict();//释放$的控制权\n    console.log($);{name:\"zhangsan\",age:12}\n    jQuery(function () {\n        jQuery(\"div\").html(\"我不是div的内容\");\n    });\n```","tags":["jQuery"]},{"title":"11-jQuery链式编程与隐式迭代","url":"%2F2017%2F03%2F24%2FjQuery%2F11-jQuery%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E8%BF%AD%E4%BB%A3%2F","content":"\n# 链式编程\n\n- 链式编程原理：return this;\n通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 this。\n\n- end(); // 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。\n\n# 隐式迭代\n\n- 隐式迭代的意思是：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。\n如果获取的是多元素的值，大部分情况下返回的是第一个元素的值。\n设置性操作的时候：设置的是所有的元素\n获取性操作：获取的是第一个元素。\n\n# each方法\n\n- 有了隐式迭代，为什么还要使用each函数遍历？\n\n大部分情况下是不需要使用each方法的，因为jQuery的隐式迭代特性。\n如果要对每个元素做不同的处理，这时候就用到了each方法\n\n 作用：遍历jQuery对象集合，为每个匹配的元素执行一个函数\n\n ```javascript\n    // 参数一表示当前元素在所有匹配元素中的索引号\n    // 参数二表示当前元素（DOM对象）\n    $(selector).each(function(index,element){});\n ```","tags":["jQuery"]},{"title":"10-jQuery事件对象（）","url":"%2F2017%2F03%2F24%2FjQuery%2F10-jQuery%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%2F","content":"\n# jQuery事件对象（）\n\n| **对象属性**                    | **解释**                       |\n| --------------------------- | ---------------------------- |\n| **event.type**              | 事件类型                         |\n| **event.data**              | 存储绑定事件时传递的附加数据               |\n| **event.target**            | 点了谁就是谁                       |\n| **event.currentTarget**     | 当前DOM元素，等同于this              |\n| **event.delegateTarget**    | 代理对象                         |\n| **screenX和screenY**         | 对应屏幕最左上角的值                   |\n| **offsetX和offsetY**         | 点击的位置距离元素的左上角的位置             |\n| **clientX和clientY**         | 距离页面左上角的位置（忽视滚动条）            |\n| **ageX和pageY**              | 距离页面最顶部的左上角的位置（会计算滚动条的距离）    |\n| **event.witch**             | 鼠标按键类型，1=鼠标左键 2=鼠标中键 3=鼠标右键\" |\n| **event.keyCode**           | 按下的键盘代码,                     |\n| **event.stopPropagation()** | 阻止事件冒泡行为                     |\n| **event.preventDefault()**  | 阻止浏览器默认行为                    |\n| **return false；**           |                              |\n\n","tags":["jQuery"]},{"title":"09-jQuery的on事件绑定与解绑","url":"%2F2017%2F03%2F24%2FjQuery%2F09-jQuery%E7%9A%84on%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E7%BB%91%2F","content":"\n\n# on事件绑定\n优势：最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。\n```javascript\n    // 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）\n    // 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。\n    // 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）\n    // 第四个参数：handler，事件处理函数\n    $(selector).on(events[,selector][,data],handler);\n\n    例子：\n    // 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定\n    $(selector).on( \"click\",\"span\", function() {});\n    // 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定（不使用代理）。\n    $(selector).on( \"click\", function() {});\n```\n\n## 事件解绑\n\n### unbind()方式（不用）\n\n作用：解绑事件\n```javascript\n    $(selector).unbind(); //解绑所有的事件\n    $(selector).unbind(\"click\"); //解绑指定的事件\n```\n### undelegate() 方式（不用）\n\n作用：解绑事件\n```javascript\n    $( selector ).undelegate(); //解绑所有的delegate事件\n    $( selector).undelegate( \"click\" ); //解绑所有的click事件\n```\n### off方式（重点）\n\n作用：解绑事件\n```javascript\n// 解绑匹配元素的所有事件\n    $(selector).off();\n    // 解绑匹配元素的所有click事件\n    $(selector).off(\"click\");\n    // 解绑所有代理的click事件，元素本身的事件不会被解绑 \n    $(selector).off( \"click\", \"**\" ); \n```\n\n## 事件触发\n\n- 简单事件触发\n```javascript\n    $(selector).click(); //触发 click事件\n```\n- trigger方法触发事件\n```javascript\n    $(selector).trigger(\"click\");\n```\n- triggerHandler触发 事件响应方法，不触发浏览器行为\n\n比如:文本框获得焦点的默认行为\n```javascript\n    $(selector).triggerHandler(\"focus\");\n```\n\n\n\n","tags":["jQuery"]},{"title":"08-jQuery事件机制","url":"%2F2017%2F03%2F23%2FjQuery%2F08-jQuery%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F","content":"\n# jQuery事件机制\n\n> JavaScript中已经学习过了事件，但是jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。\n\n## jQuery事件的发展历程\n- 简单事件绑定>>bind事件绑定>>delegate事件绑定>>on事件绑定(推荐)\n\n## 简单事件绑定\n\n> click(handler)\t\t\t单击事件\n>\n>mouseenter(handler)\t\t鼠标进入事件\n>\n>mouseleave(handler)\t\t鼠标离开事件\n>\n>scroll(handler)\t\t\t滚动事件\n>\n>缺点：一次只能绑定一个事件\n\n## bind事件绑定\n\n- 不推荐使用，jQuery1.7版本后被on取代\n```javascript\n    //绑定多个事件\n    //第一个参数：事件类型\n    //第二个参数：事件处理程序\n    $(\"p\").bind(\"click mouseenter\", function(){\n        //事件响应方法\n    });\n```\n- 缺点：不支持动态创建出来的元素绑定事件。\n\n- delegate事件绑定\n    - 支持动态绑定事件\n```javascript\n    // 第一个参数：selector，要绑定事件的元素\n    // 第二个参数：事件类型\n    // 第三个参数：事件处理函数\n    $(\".parentBox\").delegate(\"p\", \"click\", function(){\n        //为 .parentBox下面的所有的p标签绑定事件\n    });\n```\n- 理解：为什么delegate支持动态绑定事件？原因是事件冒泡机制。因为事件时绑定到父元素上的，由子元素触发。\n","tags":["jQuery"]},{"title":"07-jQuery操作坐标值","url":"%2F2017%2F03%2F23%2FjQuery%2F07-jQuery%E6%93%8D%E4%BD%9C%E5%9D%90%E6%A0%87%E5%80%BC%2F","content":"\n# jQuery操作坐标值\n\n## offset\n\n- 设置或者获取元素相对于文档document的位置。\n```javascript\n    //设置位置\n    $(selector).offset({left:100, top: 150});\n    //获取位置\n    $(selector).offset();\n```\n- 注意：使用offset操作，如果元素没有设置定位(默认position:static)，则会把position修改为relative.会修改left、top\n\n## position\n\n- 获取相对于其最近的有定位的父元素的位置。\n\n```javascript\n    // 获取，返回值为对象：{left:num, top:num}\n    $(selector).position();\n```\n- 注意：position方法只能获取，不能设置\n![](/images/jquery/8.png)\n\n\n## scrollTop\n\n\n- 设置或者获取垂直滚动条的位置\n```javascript\n    // 有参数表示设置偏移，参数为数值类型\n    $(selector).scrollTop(100);\n    // 无参数表示获取偏移\n    $(selector).scrollTop();\n```\n\n\n## scrollLeft\n\n\n- 设置或者获取水平滚动条的位置\n```javascript\n    // 有参数表示设置偏移，参数为数值类型\n    $(selector).scrollLeft(100);\n    // 无参数表示获取偏移\n    $(selector).scrollLeft();\n```","tags":["jQuery"]},{"title":"06-jQuery操作尺寸","url":"%2F2017%2F03%2F22%2FjQuery%2F06-jQuery%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8%2F","content":"\n# jQuery操作尺寸\n\n## height\n\n- 设置或者获取高度\n```javascript\n    //带参数表示设置高度\n    $(\"img\").height(200);\n    //不带参数获取高度\n    $(\"img\").height();\n```\n返回值是number类型（比如200），而使用$(“img”).css(“width”)返回的是字符串（比如200px）\n\n## width\n\n- 设置获取获取宽度，与高度操作功能一样\n```javascript\n    //带参数表示设置宽度\n    $(\"img\").width(200);\n    //不带参数获取宽度\n    $(\"img\").width();\n```\n","tags":["jQuery"]},{"title":"05-jQuery操作值与内容","url":"%2F2017%2F03%2F22%2FjQuery%2F05-jQuery%E6%93%8D%E4%BD%9C%E5%80%BC%E4%B8%8E%E5%86%85%E5%AE%B9%2F","content":"\n# jQuery操作值与内容\n\n## val方法\n\n- val方法用于设置和获取表单元素的值，例如input、select、textarea的值\n```javascript\n    //设置值\n    $(\"#name\").val(\"张三\");\n    //获取值\n    $(\"#name\").val();\n```\n\n## html方法\n\n```javascript\n//设置内容\n    $(\"div\").html(\"<span>这是一段内容</span>\");\n    //获取内容\n    $(\"div\").html()\n```\n\n## text方法\n\n```javascript\n    //设置内容\n    $(\"div\").text(\"<span>这是一段内容</span>\");\n    //获取内容\n    $(\"div\").text()\n```\n- html方法与text方法的区别：\n\thtml方法会识别html标签，text方法会把内容直接当成字符串，并不会识别html标签。","tags":["jQuery"]},{"title":"04-jQuery操作DOM","url":"%2F2017%2F03%2F22%2FjQuery%2F04-jQuery%E6%93%8D%E4%BD%9CDOM%2F","content":"\n# jQuery操作DOM\n\n## jQuery操作属性\n\n- **设置单个属性**\n```javascript\n    //第一个参数：需要设置的属性名\n    //第二个参数：对应的属性值\n    attr(name, value);\n    //用法举例\n    $(\"img\").attr(\"title\",\"哎哟，不错哦\");\n    $(\"img\").attr(\"alt\",\"哎哟，不错哦\");\n```\n\n- **设置多个属性**\n```javascript\n    //参数是一个对象，包含了需要设置的属性名和属性值\n    attr(obj)\n    //用法举例\n    $(\"img\").attr({\n        title:\"哎哟，不错哦\",\n        alt:\"哎哟，不错哦\",\n        style:\"opacity:.5\"\n        });\n```\n- **获取属性**\n```javascript\n        //传需要获取的属性名称，返回对应的属性值\n        attr(name)\n        //用法举例\n        var oTitle = $(\"img\").attr(\"title\");\n        alert(oTitle);\n```\n- 注意：\n    - 1.获取属性时，只会获取到第一个元素对应的属性，与css方法一样\n    - 2.获取属性时，如果该属性不存在，那么会返回undefined\n\n- **移除属性**\n```javascript\n    //参数：需要移除的属性名，如果传空，那么不会有任何操作，注意，并不是移除所有的属性。区分removeClass。\n    removeAttr(name);\n    //用法举例\n    $(\"img\").removeAttr(\"title\");\n```\n- **prop**\n\n注意：在jQuery1.6之后，对于checked、selected、disable这类boolean类型的属性来说，如果使用attr方法获取属性值，得到的不是true和false，而是checked以及undefined。，使用prop方法来获取或者设置checked、selected、disable这类的值。prop方法使用跟attr方法一样。\n```javascript\n    //设置属性\n    $(\":checked\").prop(\"checked\",true);\n    //获取属性\n    $(\":checked\").prop(\"checked\");//返回true或者false\n```","tags":["jQuery"]},{"title":"03-jQuery选择器","url":"%2F2017%2F03%2F21%2FjQuery%2F03-jQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F","content":"\n# jQuery选择器\n\n## jQuery选择器概述\n\n\n- 为什么要学习jQuery选择器？\n  考虑兼容性的话，js提供的获取元素的方法太少了,只有两个，不能够满足我们的要求，比如想要通过class来获取元素就不行了。\n```javascript\n    document.getElementById('btnShowDiv');\n    document.getElementsByTagName('div');\n```\n## 什么是jQuery选择器？\n- jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。\n```javascript\n    $(\"#btnShowDiv\")//id选择器\n    $(\"div\")//标签选择器\n```\n> jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多更加复杂的选择器。【查看jQuery文档】\n\n> jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。\n\n\n## jQuery选择器\n\n```javascript\n    <body>\n      <ul id=\"list\">\n        <li>\n          <ul>\n            <li>这是后代li</li>\n          </ul>\n        </li>\n        <li>这是子代li</li>\n        <li>这是子代li</li>\n        <li>这是子代li</li>\n        <li>这是子代li</li>\n      </ul>\n      <!-- <div id=\"box\"></div>\n      <div class=\"box\"></div>\n      <div class=\"box\"></div>\n      <p class=\"box\"></p>\n      <span></span> -->\n    </body>\n\n  <script src=\"jQuery-1.12.4.min.js\"></script>\n\t<script>\n\t\t$(document).ready(function () {\n\t\t\t// jQuery的选择器大部分跟css的选择器\n\t\t\t// 1 id选择器\n\t\t\t// $('#box').text('这是box');\n\n\t\t\t// 2 class选择器\n\t\t\t// $('.box').text('这是类名为box的div');\n\n\t\t\t// 3 标签选择器\n\t\t\t// $('div').text('这是div');\n\n\t\t\t// 4 交集选择器\n\t\t\t// $('div.box').text('这是类名为box的div');\n\n\t\t\t// 5 并集选择器\n\t\t\t// $('.box,span').text('这是div和p标签');\n\n\t\t\t// 过滤选择器：\n\t\t\t/*$('li:odd').text('索引为奇数的li');\n\t\t\t$('li:even').text('索引为偶数的li');\n\t\t\t$('li:eq(2)').text('这是第三个li');*/\n\n\t\t\t/*$('li:odd').css('backgroundColor', 'red');\n\t\t\t$('li:even').css('backgroundColor', 'blue');*/\n\n\n\t\t\t// 层级选择器\n\t\t\t// 1 子代选择器\n\t\t\t// $('#list>li').css('backgroundColor', 'red');\n\n\t\t\t// 2 后代选择器\n\t\t\t// $('#list li').css('backgroundColor', 'red');\n\t\t});\n\t</script>\n```\n\n## 基本选择器\n\n| **名称**              | **用法**             | **描述**                                   |\n| ------------------- | ------------------ | ---------------------------------------- |\n| **ID选择器**           | $(\"#id\");          | 获取指定ID的元素                                |\n| **类选择器**            | $(\".class\");       | 获取同一类class的元素                            |\n| **标签选择器**           | $(\"div\");          | 获取同一类标签的所有元素                             |\n| **并集选择器**           | $(\"div,p,li\");     | 使用逗号分隔，只要符合条件之一就可。获取所有的div、p、li元素        |\n| **交集选择器（标签指定式选择器）** | $(\"div.redClass\"); | 注意选择器1和选择器2之间没有空格，class为redClass的div元素，注意区分后代选择器。 |\n\n**总结：跟css的选择器用法一模一样。**\n\n\n\n## 层级选择器\n\n| **名称**    | **用法**      | **描述**                          |\n| --------- | ----------- | ------------------------------- |\n| **子代选择器** | $(\"ul>li\"); | 使用>号，获取儿子层级的元素，注意，并不会获取孙子层级的元素  |\n| **后代选择器** | $(\"ul li\"); | 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 |\n\n**跟CSS的选择器一模一样。**\n\n\n\n## 过滤选择器\n\n- **这类选择器都带冒号：**\n\n  |                | **用法**                             | **描述**                             |\n  | -------------- | ---------------------------------- | ---------------------------------- |\n  | **:eq（index）** | $(\"li:eq(2)\").css(\"color\", \"red\"); | 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 |\n  | **:odd**       | $(\"i:odd\").css(\"color\", \"red\");    | 获取到的li元素中，选择索引号为奇数的元素              |\n  | **:even**      | $(\"li:even\").css(\"color\", \"red\");  | 获取到的li元素中，选择索引号为偶数的元素              |\n\n##  筛选选择器(方法)\n\n  筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。\n\n  |                        | **用法**                      | **说明**                     |\n  | ---------------------- | --------------------------- | -------------------------- |\n  | **children(selector)** | $(\"ul\").children(\"li\")      | 相当于$(\"ul>li\")，子类选择器        |\n  | **find(selector)**     | $(\"ul\").find(\"li\");         | 相当于$(\"ul li\"),后代选择器        |\n  | **siblings(selector)** | $(\"#first\").siblings(\"li\"); | 查找兄弟节点，不包括自己本身             |\n  | **parent()**           | $(\"#first\").parent();1;     | 查找父亲                       |\n  | **eq(index)**          | $(\"li\").eq(2);1;            | 相当于$(\"li:eq(2)\"),index从0开始 |\n\n  ​\n```javascript\n<script src=\"jquery-1.12.4.min.js\"></script>\n\t<script>\n\t\t$(function () {\n\t\t\t// 筛选选择器: 均为方法形式，作用是为了完善链式编程\n\t\t\t// 1 children() 子代选择器\n\t\t\t//   参数：选择器字符串，如果不传默认选择所有子元素\n\t\t\t//  $('#list').css('width', '300px').children('.item').css('backgroundColor', 'red');\n\n\t\t\t// 2 find()  后代选择器 \n\t\t\t//   参数：选择器字符串（必须有），如果不传会被忽略。\n\t\t\t// $('#list').css('width', '300px').find('li').css('backgroundColor', 'red');\n\n\t\t\t// 3 parent() 父元素选择器，相当于parentNode\n\t\t\t//   参数：选择器字符串，如果不传默认选择所有父元素\n\t\t\t// $('p').parent('.box').css('backgroundColor', 'red');\n\n\t\t\t// 4 parents() 祖先元素选择器\n\t\t\t//   参数：选择器字符串，如果不传默认选择所有的祖先元素，但是推荐传入参数。\n\t\t\t// $('.text').parents('div').css('backgroundColor', 'red');\n\n\t\t\t// 5 siblings() 兄弟元素获取\n\t\t\t//   参数：选择器字符串，可选。\n\t\t\t//  $('.li').siblings('.item').text('这是其他同级元素');\n\n\t\t\t// 6 next() 和 prev()\n\t\t\t//   参数：选择器字符串，可选。\n\t\t\t// $('.li').next().text('这是后一个li');\n\t\t\t// $('.li').prev().text('这是前一个li');\n\n\t\t\t// 7 nextAll() 和 prevAll()\n\t\t\t//   参数：选择器字符串，可选。\n\t\t\t// $('.li').nextAll('.item').text('这是后面的所有li');\n\t\t\t// $('.li').prevAll('.item').text('这是前面的所有li');\n\n\t\t\t// 8 eq() 按索引获取指定的元素\n\t\t\t//   当需要按索引取值时推荐使用.eq()的形式，不需要进行字符串拼接。\n\t\t\tvar index = 2;\n\t\t\t// $('li:eq(' + index + ')');\n\t\t\t$('li').eq(index).text('这是第三个li');\n\t\t});\n\t</script>\n\n```\n\n\n\n\n\n\n\n","tags":["jQuery"]},{"title":"02-jQuery入口函数","url":"%2F2017%2F03%2F21%2FjQuery%2F02-jQuery%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%2F","content":"\n# 入口函数\n- jQuery入口函数的两种写法\n```javascript\n    //第一种写法\n    $(document).ready(function() {\n        });\n    //第二种写法\n    $(function() {\n        \n    });\n```\n- 对比JavaScript的入口函数jQuery的入口函数,执行时机\n    - 1.JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。\n    - jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。\n```javascript\n\t    // DOM中的入口函数执行时机：页面完全加载后（结构，图片，文件）\n\t\twindow.onload = function () {\n\t\t\tconsole.log('DOM的入口函数');\n\t\t};\n\n\t\t// jQuery的入口函数执行时机：结构加载完毕后执行\n\t\t// jQuery入口函数的书写方式：\n\t\t$(document).ready(function () {\n\t\t\tconsole.log('jQuery的入口函数1');\n\t\t});\n\t\t$(function () {\n\t\t\tconsole.log('jQuery的入口函数2');\n\t\t});\n\n\n\t\t// 如果需要使用jQuery设置页面完全加载后执行操作，可以使用以下形式：\n\t\t$(window).load(function () {\n\t\t\tconsole.log('这是jQuery在页面加载后执行的操作');\n\t\t});\n```\n\n\n## jQuery提供了两个定级对象\n\n\n```javascript\n        // $ jQuery\n\t\t// 实际上$和jQuery是同一个对象，只不过起了两个名字\n\t\tconsole.log($ === jQuery); // true\n\n\t\t// 2 $ 实际上是一个函数\n\t\tconsole.log(typeof $); // 'function'\n\n\t\t// $根据传入的参数形式不同，会具有不同的功能\n\n\t\t$('div'); // 选择器\n\t\t$(function () {}); // 入口函数\n\t\t$(document); // 可以让一个DOM对象具有更多的功能\n```\n\n## 了解jQuery的$符号\n\n- **$是什么**\n\n    `其实$就是一个函数：$();参数不一样，功能不一样`\n\n$常用的几种情况：\n```javascript\n    $(function() {});//参数是function，说明是入口函数\n    $(\"#btnSetConent\");//参数是字符串，并且以#开头，是一个标签选择，查找id=“btnSetContent”的元素\n    $(\"div\");//查找所有的div元素\n    $(document).ready(funciton(){})//将document转换成jQuery对象\n```\n补充:\n\n`$ === jQuery,也就是说能用$的地方，完全可以用jQuery，$仅仅是简写形式。`\n\n\n## jQuery对象与DOM对象之间的转换\n\n\n- 1.什么是DOM对象？\n\t- DOM对象：通过DOM方式获取的页面元素。\n\t- jQuery对象：通过jQuery方式获取的页面元素。\n\n使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。比如使用document.getElement*系列的方法返回的就是dom对象。\n\n\n- 2 DOM对象和jQuery对象的关系\n\t- jQuery对象是伪数组形式，内部放置了DOM对象\n\t- 我们称jQuery对象是DOM对象的包装集。\n```javascript\n        var box = document.getElementById('box');\n\t\tvar $box = $('div');\n\t\t\tconsole.dir(box);\n\t\t\tconsole.log($box);\n\n```\n\n- 3.功能的区别：\n\t- DOM对象只能使用DOM的功能，无法使用jQuery功能\n\t- jQuery对象只能使用jQuery功能，不能使用DOM功能\n```javascript\n        box.text('这是box');\n\t\t$box.innerHTML = '这是box的内容';\n```\n\n- 4 DOM对象与jQuery对象的转换方式\n- 4.1 将DOM对象转换为jQuery对象:将DOM对象传入到$()中\n```javascript\n        $(box).text('这是新内容');\n ```\n- 4.2 将jQuery对象转换为DOM对象\n    - 利用索引取出jQuery对象中的DOM对象(推荐)\n```javascript\n        $box[0].innerHTML = '这是box的新内容';\n        利用get(索引)\n        $box.get(0).innerHTML = '这也是新内容';\n ```\n\n\n## 什么是jquery对象？\n\n\n- jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。比如使用$()方法返回对象都是jquery对象。\n```javascript\n    $(\"div\");//标签选择器返回的jquery对象。\n    $(\"#btnShowDiv\");//id选择器返回的jquery对象。\n```\njquery对象只能使用jquery对象的方法\n```javascript\n    var $obj = $(\"div\");\n    $obj.html(\"jquery对象设置文本的方法\");\n    $obj.show();//jquery对象显示文本\n    $obj.click(function() {});//jquery对象绑定事件\n```\n错误的用法\n```javascript\n    $(\"div\").innerHTML;//jquery对象不能调用dom方法\n    //dom对象不能调用jquery方法。\n    document.getElementById(\"btnShowDiv\").show();\n```\n\n## 深入了解jQuery对象\n\n\n- jQuery对象其实就是DOM对象的包装集（包装了DOM对象的集合）\n  联想记忆：衣服和洗衣机的关系\n\n## jQuery对象和DOM对象的相互转换\n\n\n- 1. jquery对象转DOM对象\n```javascript\n    var $li = $(\"li\");\n    //第一种方法（推荐使用）\n    $li[0]\n    //第二种方法\n    $li.get(0)\n    //其实jQuery对象转DOM对象的实质就是取出jQuery对象中封装的DOM对象。\n```\n\n- 2. DOM对象转jquery对象（联想记忆：我有钱[美元]，所以我的功能就更强大）\n```javascript\n    var $obj = $(domObj);\n    // $(document).ready(function(){});就是典型的DOM对象转jQuery对象\n```\n\n\n## 区分jQuery和JavaScript\n\n\n- JavaScript是一门编程语言，jquery是用JavaScript实现的一个JavaScript库，目的是简化我们的开发。（联想记忆：不能扛着洗衣机去出差）\n  ![](/images/jquery/7.png)","tags":["jQuery"]},{"title":"01-jQuery简介","url":"%2F2017%2F03%2F21%2FjQuery%2F01-jQuery%E7%AE%80%E4%BB%8B%2F","content":"\n# jQuery简介\n\n - jQuery让js的开发变得更加简单\n\n - jQuery解决了浏览器的兼容性问题\n\n## jQuery基本概念\n\n## 为什么要学习jQuery？\n\n![](/images/jquery/1.png)\n\n##  什么是jQuery？ \n\n- **jquery的官网:**http://jquery.com/\n\n  - 说白了：jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。\n\n  - js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。（animate.js）\n\n\n## 学习jQuery，主要是学什么呢？\n\n- 学习jQuery，主要学习jQuery的一大堆的api。\n\n- API：application programming interface：应用程序编程接口，说白了，API就是方法。\n\n> obj.funName(params);\n\n- 注意：方法调用的时候，都带小括号(),使用jQuery的方法的时候，不要忘了小括号。\n\n\n## 怎样使用jQuery？\n\n- 下载jquery\n\n  官网下载地址：http://jquery.com/download/\n\n  \n- jQuery的文件相关内容：\n\t- 下载文件：https://cdnjs.com/libraries/jquery/\n\n\n![](/images/jquery/2.png)\n\n\n\n\n## jQuery详细解释\n\n- **版本介绍**\n\n    - 根据版本jQuery一共分为3类\n    - jquery大版本分为1.x和2.x（3.0）\n      ![](/images/jquery/3.png)\n      **区别：2.x版本不再支持IE6/7/8**\n\n>     1.x： 兼容所有现代浏览器（ie678和其他浏览器），使用最为广泛\n>\n>     1.12.4 是1.x的最新版本，不会再设置新功能了\n>\n>     2.x： 不支持ie678,几乎没人用\n>\n>     3.x： 不支持ie678,官方主要更新维护的版本\n\n\n\n- 同一版本分类\n\n> jQuery每一个版本又分为压缩版和未压缩版：\n>\n> jquery.js：未压缩版本（开发版本），代码可读性高，推荐在开发和学习阶段使用，方便查看源代码。\n>\n> jquery.min.js：压缩版本，去除了注释、换行、空格、并且将一些变量替换成了a,b,c之类的简单字符，基本没有可读性，推荐在项目生产环境使用，因为文件较小，减少网络压力。\n>\n> 3.x版本还提供了精简版，删除了部分功能，体积小。\n\n\n\n- **关于jquery3.0**\n  ![](/images/jquery/4.png)\n  翻译：jquery3.0现在发布了，这个版本自从2014年10月就开始测试了，我们的目标是创建一个更苗条、更快的jquery版本（并且能向后兼容）。我们已经移除了IE旧版本的解决方案，并且带来了一些较为现代的web API，但这是有道理的。3.0是2.x分支的延续，但是有一些突破性的改变。但是1.12和2.2分支将会在同一时间继续获得关键性的支持补丁。但是他们不会再有任何新的功能和重大的修订。jQuery3是jQuery的未来，如果你需要兼容IE6-8，你可以继续使用1.12版本。\n\n- **引包的注意点**\n    - 忘记引包或者引包在入口函数的后面。\n      ![](/images/jquery/5.png)\n\n    - 引包路径错误(404)\n      ![](/images/jquery/6.png)\n\n\n\n\n## 使用jQuery实现div动态展示的步骤：\n\n```javascript\n    1.引包（引入jQuery文件）\n    <script src=\"jquery-1.11.1.js\"></script>\n\n    2.入口函数\n    $(document).ready(function () {\n    });\n\n    3.功能实现\n    $(\"#btnShowDiv\").click(function () {\n        $(\"div\").show(1000);\n    });\n```\n\n\n\n ## div动态展示JavaScript与jquery的对比\n\n|            |        **JavaScript**        |         **jquery**         |\n| :--------: | :--------------------------: | :------------------------: |\n|  **入口函数**  |     只能有一个，如果有多个，后面的会覆盖前面     |     可以有多个，并且不会发生覆盖的情况      |\n| **代码容错性**  |  代码容错性差，代码出现错误，会影响到后面代码的运行。  | 代码容错性好，屏蔽错误，并且不会影响后面代码的运行。 |\n| **浏览器兼容性** |    兼容性差，比如火狐不支持innerText     |   对浏览器兼容性做了封装，因此不存在兼容性问题   |\n| **操作复杂性**  | DOM操作复杂，对于一些简单的动画效果，实现起来比较麻烦 |  DOM操作简单，支持隐式迭代，实现动画非常简单。  |\n\n\n## 使用js实现效果的缺点：\n  - 1 入口函数执行的时机较晚，需要等待所有内容加载完毕\n  - 2 DOM操作较为繁琐（经常遍历）\n  - 3 兼容性问题\n  - 4 实现动画操作较为复杂\n  - 5 容错性差（报错导致后续代码不执行）\n","tags":["jQuery"]},{"title":"40-伪数组和数组","url":"%2F2017%2F03%2F19%2FJS%2F40-%E4%BC%AA%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%2F","content":"\n# 伪数组和数组\n\n在JavaScript中，除了5种原始数据类型之外，其他所有的都是对象，包括函数（Function）。\n\n## 对象与数组的关系\n\n在说区别之前，需要先提到另外一个知识，就是 JavaScript 的原型继承。\n所有 JavaScript 的内置构造函数都是继承自 `Object.prototype` 。\n在这个前提下，可以理解为使用 `new Array()` 或 `[]` 创建出来的数组对象，都会拥有 `Object.prototype` 的属性值。\n\n```javascript\n    var obj = {};// 拥有 Object.prototype 的属性值\n    var arr = [];\n    //使用数组直接量创建的数组，由于 Array.prototype 的属性继承自 Object.prototype，\n    //那么，它将同时拥有 Array.prototype 和 Object.prototype 的属性值\n```\n\n可以得到对象和数组的第一个区别：对象没有数组 Array.prototype 的属性值。\n\n## 什么是数组\n\n数组具有一个最基本特征：索引，这是对象所没有的，下面来看一段代码：\n\n```javascript\n    var obj = {};\n    var arr = [];\n    \n    obj[2] = 'a';\n    arr[2] = 'a';\n    \n    console.log(obj[2]); // => a\n    console.log(arr[2]); // => a\n    console.log(obj.length); // => undefined\n    console.log(arr.length); // => 3\n```\n\n\n- obj[2]输出'a'，是因为对象就是普通的键值对存取数据\n- 而arr[2]输出'a' 则不同，数组是通过索引来存取数据，arr[2]之所以输出'a'，是因为数组arr索引2的位置已经存储了数据\n- obj.length并不具有数组的特性，并且obj没有保存属性length，那么自然就会输出undefined\n- 而对于数组来说，length是数组的一个内置属性，数组会根据索引长度来更改length的值\n- 为什么arr.length输出3，而不是1\n  + 在给数组添加元素时，并没有按照连续的索引添加，所以导致数组的索引不连续，那么就导致索引长度大于元素个数\n\n\n## 什么是伪数组\n\n1. 拥有 length 属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解)\n2. 不具有数组所具有的方法\n\n伪数组，就是像数组一样有 `length` 属性，也有 `0、1、2、3` 等属性的对象，看起来就像数组一样，但不是数组，比如:\n\n```javascript\n    var fakeArray = {\n    \"0\": \"first\",\n    \"1\": \"second\",\n    \"2\": \"third\",\n    length: 3\n    };\n    for (var i = 0; i < fakeArray.length; i++) {\n    console.log(fakeArray[i]);\n    }\n \n    Array.prototype.join.call(fakeArray,'+');\n``` \n\n\n常见的伪数组有：\n\n- 函数内部的 `arguments`\n- DOM 对象列表（比如通过 `document.getElementsByTags` 得到的列表）\n- jQuery 对象（比如 `$(\"div\")` ）\n\n伪数组是一个 Object，而真实的数组是一个 Array。\n\n伪数组存在的意义，是可以让普通的对象也能正常使用数组的很多方法，比如：\n\n```javascript\n    var arr = Array.prototype.slice.call(arguments);\n    \n    Array.prototype.forEach.call(arguments, function(v) {\n    // 循环arguments对象\n    });\n\n    // push\n    // some\n    // every\n    // filter\n    // map\n    // ...\n```\n\n\n以上在借用数组的原型方法的时候都可以通过数组直接量来简化使用：\n\n```javascript\n    var obj = {\n    0: 'a',\n    1: 'b',\n    2: 'c',\n    length: 3\n    }\n\n    ;[].push.call(obj, 'd')\n\n    console.log([].slice.call(obj))\n\n    ;[].forEach.call(obj, function (num, index) {\n    console.log(num)\n    })\n```\n\n## 小结\n\n- 对象没有数组 Array.prototype 的属性值，类型是 Object ，而数组类型是 Array\n- 数组是基于索引的实现， length 会自动更新，而对象是键值对\n- 使用对象可以创建伪数组，伪数组可以正常使用数组的大部分方法\n\n\n\n## 静态成员\n\n- Object.assign()\n- Object.create()\n- Object.keys()\n- Object.defineProperty()\n\n## 实例成员\n\n- constructor\n- hasOwnProperty()\n- isPrototypeOf\n- propertyIsEnumerable()\n- toString()\n- valueOf()\n\n---\n\n\n### 代码风格\n\n- [JavaScript Standard Style ](https://github.com/feross/standard)\n- [Airbnb JavaScript Style Guide() {](https://github.com/airbnb/javascript)\n\n### 校验工具\n\n- [JSLint](https://github.com/douglascrockford/JSLint)\n- [JSHint](https://github.com/jshint/jshint)\n- [ESLint](https://github.com/eslint/eslint)\n\n### B Chrome 开发者工具\n\n### C 文档相关工具\n\n- 电子文档制作工具: [docute](https://github.com/egoist/docute)\n- 流程图工具：[DiagramDesigner](http://logicnet.dk/DiagramDesigner/)","tags":["JS"]},{"title":"39-正则表达式","url":"%2F2017%2F03%2F18%2FJS%2F39-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F","content":"\n# 正则表达式\n\n- 了解正则表达式基本语法\n- 能够使用JavaScript的正则对象\n\n## 什么是正则表达式\n\n> 正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。\n\n> 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。\n\n## 正则表达式的作用\n\n- 作用：用于对字符串进行处理。匹配，替换，提取。\n\n\n- 实现方式：不是js中独有的功能。\n  - 大多数变成语言都对正在有时限方式，在js中采用了内置对象设置方式实现。\n\n\n\n1. 给定的字符串是否符合正则表达式的过滤逻辑(匹配)\n2. 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取)\n3. 强大的字符串替换能力(替换)\n\n\n## 正则表达式的特点\n\n\n1. 灵活性、逻辑性和功能性非常的强\n2. 可以迅速地用极简单的方式达到字符串的复杂控制\n3. 对于刚接触的人来说，比较晦涩难懂\n\n## 正则表达式的测试\n\n- [在线测试正则](https://c.runoob.com/front-end/854)\n- 工具中使用正则表达式\n  + sublime/vscode/word\n  + 演示替换所有的数字\n\n\n## 正则表达式的组成\n\n- 普通字符\n- 特殊字符(元字符)：正则表达式中有特殊意义的字符\n\n\n示例演示：\n\n- `\\d` 匹配数字\n- `ab\\d` 匹配 ab1、ab2\n\n## 元字符串\n\n\n通过测试工具演示下面元字符的使用\n\n\n## 常用元字符串\n\n\n| 元字符  | 说明              |\n| ---- | --------------- |\n| \\d   | 匹配数字            |\n| \\D   | 匹配任意非数字的字符      |\n| \\w   | 匹配字母或数字或下划线     |\n| \\W   | 匹配任意不是字母，数字，下划线 |\n| \\s   | 匹配任意的空白符        |\n| \\S   | 匹配任意不是空白符的字符    |\n| .    | 匹配除换行符以外的任意单个字符 |\n| ^    | 表示匹配行首的文本(以谁开始) |\n| $    | 表示匹配行尾的文本(以谁结束) |\n\n\n## 限定符\n\n\n| 限定符   | 说明       |\n| ----- | -------- |\n| *     | 重复零次或更多次 |\n| +     | 重复一次或更多次 |\n| ?     | 重复零次或一次  |\n| {n}   | 重复n次     |\n| {n,}  | 重复n次或更多次 |\n| {n,m} | 重复n到m次   |\n\n\n\n### 其它\n\n\n```\n[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思\n[^]  匹配除中括号以内的内容\n\\ 转义符\n| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱\n() 从两个直接量中选择一个，分组\n   eg：gr(a|e)y匹配gray和grey\n[\\u4e00-\\u9fa5]  匹配汉字\n```\n\n### 案例\n\n验证手机号：\n\n```javascript\n    ^\\d{11}$\n```\n\n验证邮编：\n\n```javascript\n    ^\\d{6}$\n```\n\n验证日期 2012-5-01\n\n```javascript\n    ^\\d{4}-\\d{1,2}-\\d{1,2}$\n```\n\n验证邮箱 xxx@xxx.cn：\n\n```javascript\n    ^\\w+@\\w+\\.\\w+$\n```\n\n验证IP地址 192.168.1.1\n\n```javascript\n    ^\\d{1,3}\\(.\\d{1,3}){3}$\n```\n\n## JavaScript 中使用正则表达式\n\n方式1：\n\n```javascript\n    var reg = new Regex('\\d', 'i');\n    var reg = new Regex('\\d', 'gi');\n```\n\n方式2：\n\n```javascript\n    var reg = /\\d/i;\n    var reg = /\\d/gi;\n```\n\n\n### 参数\n\n\n| 标志   | 说明         |\n| ---- | ---------- |\n| i    | 忽略大小写      |\n| g    | 全局匹配       |\n| gi   | 全局匹配+忽略大小写 |\n\n\n### 正则匹配\n\n\n\n### 简单类和test方法使用\n\n\n- 简单类：表示当前正则用于匹配含义内部字符串的字符串\n  - 只要字符串中含义abc即可，位置不限\n\n```javascript\n\tvar reg = /abc/\n\t// 正则方法：test() - 参数为要匹配得字符串，返回布尔类型值\n\tconsole.log(reg.test('abc')); // true\n\tconsole.log(reg.test('abc123123')); // true\n\tconsole.log(reg.test('123123abc')); // true\n\tconsole.log(reg.test('123abc123')); // true\n\tconsole.log(reg.test('123a1b1c123')); // false\n```\n\n\n### 字符类和反向类\n\n\n#### 字符类：\n\n  - 标识方式：在正常内部使用[]标识\n\n  - 含义：[ ]内部整体表示一位字符，内部书写的多个字符表示此位置的多种情况\n\n    `var reg = /[abcd]/;` 基本形式\n\n    示例：例如需要检测的字符串有以下四种情况abc\t bbc \tcbc \t\tdbc\n\n```javascript\n         var reg = /[asbc]bc/;\n         console.log(reg.test('abc'));\t//true\n         console.log(reg.test('bbc'));\t//true\n         console.log(reg.test('cbc'));\t//true\n         console.log(reg.test('dbc'));\t//false\n```\n\n\n### 反向类：\n\n  - 基于字符类的功能\n  - 标识方式：在字符类[]内部最开始位置书写一个^\n  - 含义：可以匹配除内部字符串外的其他字符，当前字符有没有都不影响，主要看其他字符\n\n```javascript\n        var reg = /[^abc]/;\n        console.log(reg.test('abc'));\t//false\n        console.log(reg.test('123'));\t//true\n        console.log(reg.test('fhs'));\t//true\n        console.log(reg.test('zabc'));  //true\n```\n\n## 范围类和组合类\n\n### 范围类：\n\n- 是对字符类功能的扩展,在字符类内部使用 - 标识范围\n\n  - 作用：是对字符类功能得扩展\n  - 标识方式：在字符类内部使用-标识范围\n\n  ​\n\n  ```javascript\n        var reg = /[b-h]/;\n        console.log(reg.test('d'));// true\n        console.log(reg.test('a'));// false\n        console.log(reg.test('h'));// true\n  ```\n\n- 常用范围类表示方式\n\n  - 1.表示所有得小写字母   /[a-z]/\n\n  - 2.表示所有得大写字母   /[A-Z]/\n\n  - 3.表示所有得数字   /[0-9]/\n\n    ​\n\n### 组合类：是对范围类的功能扩展\n\n - 作用：用于同时属性多种规则\n\n```javascript\n        var reg = /[a-z0-9]/;\n        console.log(reg.test('3'));\n        console.log(reg.test('h'));\n        console.log(reg.test('D'));\n        console.log(reg.test('Z'));\n```\n\n\n\n## 预定义类\n\n\n- 预定义类：正则表达式内部预先提供好得匹配方式\n\n\n- 1.数字字符操作\n  - \\d - 用于表示数字字符匹配 - 相当于[0-9]\n\n```javascript\n        var reg = /\\d/;\n\n        console.log(reg.test('sdfghj5kfghj')); // true\n        console.log(reg.test('sdfghj8kfghj')); // true\n```\n\n- \\D     用于表示非数字字符  相当于`[^0-9]`\n\n```javascript\n\t\tvar reg = /\\D/;\n\t\t\n\t\tconsole.log(reg.test('1234567890'));\n\t\tconsole.log(reg.test('a'));\n\t\tconsole.log(reg.test('C'));\n\t\tconsole.log(reg.test('-'));\n```\n\n- 2.单词字符操作：\n  - ​    \\w - 用于表示单词字符 - [0-9a-zA-Z_]\n\n```javascript\n\t\tvar reg = /\\w/;\n\n\t\tconsole.log(reg.test('456'));\n\t\tconsole.log(reg.test('fgh'));\n\t\tconsole.log(reg.test('TYU'));\n\t\tconsole.log(reg.test('_'));\n\t\tconsole.log(reg.test('*$#@!~^&'));\n```\n\n- \\W - 用于表示非单词字符 \n\n```javascript\n\t\tvar reg = /\\W/;\n\n\t\tconsole.log(reg.test('456'));\n\t\tconsole.log(reg.test('fgh'));\n\t\tconsole.log(reg.test('TYU'));\n\t\tconsole.log(reg.test('_'));\n\t\tconsole.log(reg.test('*$#@!~^&'));\n```\n\n- 3.可见和不可见字符匹配\n  -  \\s - 不可见字符 - 通常用于识别空格和换行 - [ \\f\\n\\r\\t\\v]\n\n```javascript\n\t\tvar reg = /\\s/;\n\n\t\tconsole.log(reg.test('abcde45678GHJK_')); // false\n\t\tconsole.log(reg.test(' ')); // true\n\t\tconsole.log(reg.test('\\n')); // true\n\t\tconsole.log(reg.test('\\t')); // true\n```\n\n-  \\S - 可见字符 - 很少使用\n\n```javascript\n\t\tvar reg = /\\S/;\n\n\t\tconsole.log(reg.test('abcde45678GHJK_')); // true\n\t\tconsole.log(reg.test(' ')); // false\n\t\tconsole.log(reg.test('\\n')); // false\n\t\tconsole.log(reg.test('\\t')); // false\n```\n\n- 本身具有匹配功能，用于匹配可见字符，含有空格\n\n\n- 通常用于匹配用户输入得内容，由于用户可能输入空格，使用\\S不行，使用 点 即可\n\n```javascript\n\t\tvar reg = /./;\n\t\tconsole.log(reg.test('abc'));\n\t\tconsole.log(reg.test('123'));\n\t\tconsole.log(reg.test(' '));\n```\n\n小结：以后不可见字符使用\\s,可见字符使用英文点符号。\n\n\n\n-  匹配日期\n\n```javascript\n        var dateStr = '2015-10-10';\n        var reg = /^\\d{4}-\\d{1,2}-\\d{1,2}$/\n        console.log(reg.test(dateStr));\n```\n\n## 边界\n\n- 1 检测起始位置内容\n  - 标识方式：在正则最开始位置书写^\n\n```javascript\n        var reg = /^abc/;          \n        console.log(reg.test('abcghjkl'));        \n        console.log(reg.test('1abcghjkl'));\n```\n\n- 2 检测结束位置内容\n  - 标识方式：在正则最后位置书写$\n\n```javascript\n        var reg = /abc$/;\n        console.log(reg.test('1111abc'));\n        console.log(reg.test('1111abc222'));\n```\n\n- 3 严格匹配:将^和$同时使用，必须与内容得内容完全一致\n\n```javascript\n        var reg = /^a[qwe]c$/\n        console.log(reg.test('abc123'));\n        console.log(reg.test('abc'));\n        console.log(reg.test('abcabc'));\n        console.log(reg.test('aqc'));\n        console.log(reg.test('awc'));\n        console.log(reg.test('aec'));\n```\n\n\n## 量词\n\n\n- 自定义量词：\n\n```javascript\n// 1 {n} 用于指定重复次数\n\n        var reg = /^a{3}$/;\n        console.log(reg.test('aa'));    // false\n        console.log(reg.test('aaa'));   // true\n        console.log(reg.test('aaaa'));  // false\n        console.log(reg.test('aaaaa')); // false\n\n```\n\n```javascript\n// 2 {n,} 用于指定至少重复几次\n\n        var reg = /^a{3,}$/;\n        console.log(reg.test('aa'));    // false\n        console.log(reg.test('aaa'));   // true\n        console.log(reg.test('aaaa'));  // true\n        console.log(reg.test('aaaaa')); // true\n```\n\n```javascript\n  // 3 {n,m} 用于指定重复得次数范围\n\n        var reg = /^a{3,5}$/;\n        console.log(reg.test('aa')); \t  // false\n        console.log(reg.test('aaa')); \t  // true\n        console.log(reg.test('aaaa')); \t  // true\n        console.log(reg.test('aaaaa'));   // true\n        console.log(reg.test('aaaaaaa')); // false\n```\n\n\n\n### 预定义量词：\n\n```javascript\n//  1 * 出现0次或多次即可(有没有出现都可以)\n\n        /var reg = /^a$/;\n        console.log(reg.test('')); \t  // true\n        console.log(reg.test('aa'));  // true\n        console.log(reg.test('aaa')); // true\n\n// 例如说，需要进行邮箱内容匹配\n//  zxx@sina.com.cn\n// 域名部分得.cn是可有可无的，可以使用*\n//  /^\\w{3,5}@\\w{2,5}.\\w{2,5}(.\\w{2,5})*$/\n//  2 + 至少出现1次 \n     \n            var reg = /^a+$/;\n            console.log(reg.test('')); \t  // false\n            console.log(reg.test('a'));   // true\n            console.log(reg.test('aa'));  // true\n            console.log(reg.test('aaa')); // true\n        \n//  zxx@sina.com.cn\n// 例如：域名部分得.com和.cn规则相同，可以简化为使用+\n// /^\\w{3,5}@\\w{2,5}(.\\w{2,5})+$/\n//   3 ? 出现0次或1次\n\n        var reg = /^a?$/;\n        console.log(reg.test(''));    // true\n        console.log(reg.test('a'));   // true\n        console.log(reg.test('aa'));  // false\n        console.log(reg.test('aaa')); // false\n\n```\n\n\n\n## 正则替换/提取\n\n- replace() 字符串得替换方法\n\n```javascript\n\t\tvar str = 'a-a-a-a-a';\n  \n         console.log(str.replace('a', 'z'));\n         console.log(str.split('a').join('z'));\n         var str = '5a-4A-3A-2A-1a';\n\n  //replace()得参数1，支持正则表达式\n  //正则得匹配模式：\n  //将匹配模式得字符，书写到正则得后面,或者new RegExp('\\d', 'gi')\n  //g - 全局匹配    \n  //i - 忽略大小写\n\n        console.log(str.replace(/\\d/g, 'z'));\n        console.log(str.replace(/a/g, 'z'));\n        console.log(str.replace(/a/ig, 'z'));\n```\n\n- 2 提取操作：\n  - 例如：老板给你发了一个邮件，邮件中有各个不份额负责人得名称以及对应得邮箱地址\n\n```javascript\n  \t\tvar str = '张三:zhangsan1@qq.com呵呵呵，还有一个张三:zhangsan2@qq.com呵呵呵，还有一个张三:zhangsan9@qq.com呵呵呵，还有一个张三:zhangsan3@qq.com呵呵呵，还有一个';\n        // 2.1 字符串得match()方法：\n        //      - 参数：要替换内容得规则，正则对象\n         console.log(str.match(/\\w+@\\w+.\\w+/g));\n         console.log(str.match(/\\w+@\\w+.\\w+/g).join(';') + ';');\n         \n        // 2.2 正则对象的exec()方法\n        //    - 参数：要进行提取得字符串\n        //    - 使用方式：必须使用同一个正则对一个字符串进行多次调用提取操作，每次返回某一个结果\n        //    - 当一轮提取完毕，再继续提取，会返回null\n\n        var reg = /(\\w+)@(\\w+.\\w+)/g;\n\n        // 思考：由于字符串中满足条件得邮箱个数是无法确定得，不能手动调用多次，需要进行处理。\n        \n        console.log(reg.exec(str));\n        console.log(reg.exec(str));\n        console.log(reg.exec(str));\n        console.log(reg.exec(str));\n        console.log(reg.exec(str));\n\n      \n\n```\n\n\n\n​      \n\n## 或者和括号\n\n- | 或者\n\n```javascript\n\n\t\t// var reg = /a|b|c/; // 相当于 /[abc]/\n\n\t\tvar reg = /ab|cd|ef/;\n\t\tconsole.log(reg.test('ab'));\n\t\tconsole.log(reg.test('cd'));\n\t\tconsole.log(reg.test('ef'));\n```\n\n>  小结：\n>\n> ​\t如果是单个字符得多种情况，使用字符类[]操作\n>\n> ​\t如果是多个字符得多种情况，使用或者|操作\n\n- 括号：用于表示整体\n\n```javascript\n\t\tvar reg = /abc{3}/;\n\n        console.log(reg.test('abcabcabc')); // false\n        console.log(reg.test('abccc')); // true\n        var reg = /(abc){3}/;\n        console.log(reg.test('abcabcabc')); // true\n        console.log(reg.test('abccc')); // false\n```\n\n\n\n\n\n```javascript\n\n```\n\n\n\n## 案例：表单验证\n\n```html\n    QQ号：<input type=\"text\" id=\"txtQQ\"><span></span><br>\n    邮箱：<input type=\"text\" id=\"txtEMail\"><span></span><br>\n    手机：<input type=\"text\" id=\"txtPhone\"><span></span><br>\n    生日：<input type=\"text\" id=\"txtBirthday\"><span></span><br>\n    姓名：<input type=\"text\" id=\"txtName\"><span></span><br>\n```\n\n```javascript\n    //获取文本框\n    var txtQQ = document.getElementById(\"txtQQ\");\n    var txtEMail = document.getElementById(\"txtEMail\");\n    var txtPhone = document.getElementById(\"txtPhone\");\n    var txtBirthday = document.getElementById(\"txtBirthday\");\n    var txtName = document.getElementById(\"txtName\");\n\n    //\n    txtQQ.onblur = function () {\n    //获取当前文本框对应的span\n    var span = this.nextElementSibling;\n    var reg = /^\\d{5,12}$/;\n    //判断验证是否成功\n    if(!reg.test(this.value) ){\n        //验证不成功\n        span.innerText = \"请输入正确的QQ号\";\n        span.style.color = \"red\";\n    }else{\n        //验证成功\n        span.innerText = \"\";\n        span.style.color = \"\";\n    }\n    };\n\n    //txtEMail\n    txtEMail.onblur = function () {\n    //获取当前文本框对应的span\n    var span = this.nextElementSibling;\n    var reg = /^\\w+@\\w+\\.\\w+(\\.\\w+)?$/;\n    //判断验证是否成功\n    if(!reg.test(this.value) ){\n        //验证不成功\n        span.innerText = \"请输入正确的EMail地址\";\n        span.style.color = \"red\";\n    }else{\n        //验证成功\n        span.innerText = \"\";\n        span.style.color = \"\";\n    }\n    };\n```\n\n表单验证部分，封装成函数：\n\n```javascript\n    var regBirthday = /^\\d{4}-\\d{1,2}-\\d{1,2}$/;\n    addCheck(txtBirthday, regBirthday, \"请输入正确的出生日期\");\n    //给文本框添加验证\n    function addCheck(element, reg, tip) {\n    element.onblur = function () {\n        //获取当前文本框对应的span\n        var span = this.nextElementSibling;\n        //判断验证是否成功\n        if(!reg.test(this.value) ){\n        //验证不成功\n        span.innerText = tip;\n        span.style.color = \"red\";\n        }else{\n        //验证成功\n        span.innerText = \"\";\n        span.style.color = \"\";\n        }\n    };\n    }\n```\n\n通过给元素增加自定义验证属性对表单进行验证：\n\n```html\n    <form id=\"frm\">\n    QQ号：<input type=\"text\" name=\"txtQQ\" data-rule=\"qq\"><span></span><br>\n    邮箱：<input type=\"text\" name=\"txtEMail\" data-rule=\"email\"><span></span><br>\n    手机：<input type=\"text\" name=\"txtPhone\" data-rule=\"phone\"><span></span><br>\n    生日：<input type=\"text\" name=\"txtBirthday\" data-rule=\"date\"><span></span><br>\n    姓名：<input type=\"text\" name=\"txtName\" data-rule=\"cn\"><span></span><br>\n    </form>\n```\n\n```javascript\n// 所有的验证规则\n\n    var rules = [\n    {\n        name: 'qq',\n        reg: /^\\d{5,12}$/,\n        tip: \"请输入正确的QQ\"\n    },\n    {\n        name: 'email',\n        reg: /^\\w+@\\w+\\.\\w+(\\.\\w+)?$/,\n        tip: \"请输入正确的邮箱地址\"\n    },\n    {\n        name: 'phone',\n        reg: /^\\d{11}$/,\n        tip: \"请输入正确的手机号码\"\n    },\n    {\n        name: 'date',\n        reg: /^\\d{4}-\\d{1,2}-\\d{1,2}$/,\n        tip: \"请输入正确的出生日期\"\n    },\n    {\n        name: 'cn',\n        reg: /^[\\u4e00-\\u9fa5]{2,4}$/,\n        tip: \"请输入正确的姓名\"\n    }];\n\n    addCheck('frm');\n\n\n    //给文本框添加验证\n    function addCheck(formId) {\n    var i = 0,\n        len = 0,\n        frm =document.getElementById(formId);\n    len = frm.children.length;\n    for (; i < len; i++) {\n        var element = frm.children[i];\n        // 表单元素中有name属性的元素添加验证\n        if (element.name) {\n        element.onblur = function () {\n            // 使用dataset获取data-自定义属性的值\n            var ruleName = this.dataset.rule;\n            var rule =getRuleByRuleName(rules, ruleName);\n\n            var span = this.nextElementSibling;\n            //判断验证是否成功\n            if(!rule.reg.test(this.value) ){\n            //验证不成功\n            span.innerText = rule.tip;\n            span.style.color = \"red\";\n            }else{\n                //验证成功\n            span.innerText = \"\";\n            span.style.color = \"\";\n            }\n        }\n        }\n    }\n    }\n\n    // 根据规则的名称获取规则对象\n    function getRuleByRuleName(rules, ruleName) {\n    var i = 0,\n        len = rules.length;\n    var rule = null;\n    for (; i < len; i++) {\n        if (rules[i].name == ruleName) {\n        rule = rules[i];\n        break;\n        }\n    }\n    return rule;\n    }\n```\n\n\n\n","tags":["regexp"]},{"title":"38-函数递归","url":"%2F2017%2F03%2F17%2FJS%2F38-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92%2F","content":"\n# 函数递归\n\n## 递归(递归函数)：\n\n- 一个函数在内部调用自身，称为递归。\n\n\n\n- 递归最容易出现得问题：\n\n- 1 死'循环'\n\n  - 必须给递归设置结束条件\n  - 例如，记录递归执行得次数，次数到达，return(使用较少，通常使用for)\n  - 例如：观察功能中得规律，设置结束条件\n\n- 2 性能问题：\n\n  - 需要尽量减少递归执行得次数\n\n    ​\n\n- 斐波那契数列(兔子)： 1 1 2 3 5 8 13 21 34 55 89 \n\n  - 数列规律：最前面两个数是1，后续得值为前两个值得和\n\n    ​\n\n> 设置一个功能，可以计算出数列中某个位置得值, n代表得是第几个数\n\n       ```javascript\n\t\t/*function getFb (n) {\n            // 根据规律已知，位置1和2得值为1\n            if (n === 1 || n === 2) {\n                return 1;\n            }\n            return getFb(n - 1) + getFb(n - 2);\n        }\n        console.log(getFb(51));\n\n        // 对递归进行优化操作:\n        // 问题：有些值计算多次，导致调用次数过多，如果这个值 仅仅计算1次，执行会快很多\n        // 解决方式：\n        // 使用一个对象记录某个位置和对应得值\n        var obj = {};\n        var count = 0;\n        function getFb (n) {\n            count++;\n            // 根据规律已知，位置1和2得值为1\n            if (n === 1 || n === 2) {\n                return 1;\n            }\n            // 进行递归操作之前，先检测obj中是否存在对应得数据\n\n            // 如果存在，直接返回，如果不存在，计算后保存在obj中给下次使用。\n            return obj[n] ? obj[n] : obj[n] = getFb(n - 1) + getFb(n - 2);\n        }\n        console.log(getFb(1500), count);*/\n  \n  \n        // 将递归函数和进行优化得数据设置在一个函数中，确保数据得安全。\n        var getFb = (function () {\n            // obj这个数据只和getFb函数得功能相关，不应该被其他代码操作，应当设置为私有变量\n            var obj = {};\n            function getFb (n) {\n                // 根据规律已知，位置1和2得值为1\n                if (n === 1 || n === 2) {\n                    return 1;\n                }\n                // 进行递归操作之前，先检测obj中是否存在对应得数据\n                // 如果存在，直接返回，如果不存在，计算后保存在obj中给下次使用。\n                return obj[n] ? obj[n] : obj[n] = getFb(n - 1) + getFb(n - 2);\n            }\n            return getFb;\n        })();\n        console.log(getFb(20));\n\n       ```\n\n\n\n## 递归执行模型\n\n```javascript\n    function fn1 () {\n    console.log(111)\n    fn2()\n    console.log('fn1')\n    }\n\n    function fn2 () {\n    console.log(222)\n    fn3()\n    console.log('fn2')\n    }\n\n    function fn3 () {\n    console.log(333)\n    fn4()\n    console.log('fn3')\n    }\n\n    function fn4 () {\n    console.log(444)\n    console.log('fn4')\n    }\n\n    fn1()\n```\n\n### 举个栗子：计算阶乘的递归函数\n\n```javascript\n    function factorial (num) {\n    if (num <= 1) {\n        return 1\n    } else {\n        return num * factorial(num - 1)\n    }\n    }\n```\n\n## 深拷贝\n\n```javascript\nvar obj = {\n\t\t\tname : 'jack',\n\t\t\tage : 18,\n\t\t\taiHao : ['游泳', '打代码', '跑步'],\n\t\t\tgf : {\n\t\t\t\tname1 : 'rose',\n\t\t\t\tage1 : 21\n\t\t\t}\n\t\t};\n\t\t// 普通遍历操作：浅拷贝\n\t\t/*var obj2 = {};\n\t\tfor (var k in obj) {\n\t\t\tobj2[k] = obj[k];\n\t\t}\n\t\tobj.aiHao[0] = '吃饭';\n\t\tconsole.log(obj2.aiHao);*/\n\n\t\t// 深拷贝操作：用于对复杂数据类型进行完整拷贝\n\t\tvar obj2 = {};\n\t\tfunction deepCopy (obj, obj2) {\n\t\t\tfor (var k in obj) {\n\t\t\t\t// 利用这个条件，检测数据是基本数据类型还是复杂数据类型\n\t\t\t\tif (typeof obj[k] !== 'object' || obj[k] === null) {\n\t\t\t\t\t// 当某个属性是基本数据类型时，直接拷贝即可\n\t\t\t\t\tobj2[k] = obj[k];\n\t\t\t\t} else {\n\t\t\t\t\t// 当某个属性是复杂数据类型时，需要再次进行拷贝操作\n\t\t\t\t\t// 需要考虑数据到底是数组还是对象结构\n\t\t\t\t\tobj2[k] = obj[k].constructor === Array ? [] : {};\n\t\t\t\t\tdeepCopy(obj[k], obj2[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdeepCopy(obj, obj2);\n\t\t// obj.gf.name1 = 'lucy';\n\t\tconsole.log(obj);\n\t\tconsole.log(obj2);\n\n\n// 特殊点：这个功能没有明显得设置结束条件，原因为数据不可能为无限维度。\n```\n\n","tags":["JS"]},{"title":"37-闭包","url":"%2F2017%2F03%2F16%2FJS%2F37-%E9%97%AD%E5%8C%85%2F","content":"\n# 什么是闭包\n\n> 闭包就是能够读取其他函数内部变量的函数，\n>\n> 闭包(闭包函数)：**能够操作某些私有变量得函数称为闭包函数。**\n\n> 由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，\n\n> 因此可以把闭包简单理解成 “定义在一个函数内部的函数”。\n\n> 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n\n闭包的用途：\n\n- 可以在函数外部读取函数内部成员\n- 让函数内成员始终存活在内存中\n\n## 一些关于闭包的例子\n\n示例1：\n\n```javascript\nvar lis = document.getElementsByTagName('li');\n\n\t\tfor (var i = 0; i < lis.length; i++) {\n\t\t\t(function (j) {\n\t\t\t\t// 使用一个立即执行函数进行作用域得创建,j就是一个私有变量\n\t\t\t\t// var j = i;\n\t\t\t\tlis[i].onclick = function () {\n\t\t\t\t\t// i不能使用：取值为循环结束得值，如果可以得到循环过程中i的值，即可解决这个问题。\n\t\t\t\t\tconsole.log(j);\n\t\t\t\t};\n\t\t\t})(i);\n\t\t}\n\n```\n\n\n\n示例2：\n\n```javascript\n    var arr = [10, 20, 30]\n    for(var i = 0; i < arr.length; i++) {\n    arr[i] = function () {\n        console.log(i)\n    }\n    }\n```\n\n示例3：\n\n```javascript\n    console.log(111)\n\n    for(var i = 0; i < 3; i++) {\n    setTimeout(function () {\n        console.log(i)\n    }, 0)\n    }\n    console.log(222)\n```\n\n## 闭包的思考题\n\n思考题 1：\n\n```javascript\n    var name = \"The Window\";\n    var object = {\n    name: \"My Object\",\n    getNameFunc: function () {\n        return function () {\n        return this.name;\n        };\n    }\n    };\n\n    console.log(object.getNameFunc()())\n```\n\n\n思考题 2：\n\n```javascript\n    var name = \"The Window\";　　\n    var object = {　　　　\n    name: \"My Object\",\n    getNameFunc: function () {\n        var that = this;\n        return function () {\n        return that.name;\n        };\n    }\n    };\n    console.log(object.getNameFunc()())\n```\n\n","tags":["JS"]},{"title":"36-作用域、作用域链、预解析","url":"%2F2017%2F03%2F15%2FJS%2F36-%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%A2%84%E8%A7%A3%E6%9E%90%2F","content":"\n# 作用域、作用域链、预解析\n\n- 全局作用域\n- 函数作用域\n\n## 预解析：\n\n- 预解析\n    - 在每个作用域开启前均会发生预解析操作。\n    - 在当前作用域中的var变量声明，将声明提升到当前作用域顶端，赋值保留在原位置。\n    - 找当前作用域中的函数声明语句，将函数体整体提升当前作用域顶端，调用保留在原位置。\n    - 以上两步不分先后。\n\n\n- 作用域：\n    - 分类：全局作用域，局部作用于(函数作用域)。\n    - 作用：现在变量的访问范围。\n    - 作用域的访问规则(作用域链)：向上查找。\n\n\n- **没有块级作用域**\n\n```javascript\n    {\n    var foo = 'bar'\n    }\n\n    console.log(foo)\n\n    if (true) {\n    var a = 123\n    }\n    console.log(a)\n```\n\n作用域链示例代码：\n\n```javascript\n    var a = 10\n\n    function fn () {\n    var b = 20\n\n    function fn1 () {\n        var c = 30\n        console.log(a + b + c)\n    }\n\n    function fn2 () {\n        var d = 40\n        console.log(c + d)\n    }\n\n    fn1()\n    fn2()\n    }\n```\n\n- 内层作用域可以访问外层作用域，反之不行","tags":["JS"]},{"title":"35-函数进阶","url":"%2F2017%2F03%2F15%2FJS%2F35-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6%2F","content":"\n# 函数进阶\n\n## 函数的定义方式\n\n- 函数声明\n- 函数表达式\n- `new Function`\n\n\n## 函数声明\n\n\n```javascript\n    function fun () {\n\n    }\n```\n\n## 函数表达式(推荐)\n\n```javascript\n    var fun = function () {\n\n    }\n```\n\n## 构造函数创建方式：\n\n(书写较为繁琐，通常不推荐使用)\n\n```javascript\n    var fun = new Function('a', 'b','console.log(199, a, b);');\n    fun(200, 300);\n```\n\n## 函数声明与函数表达式的区别\n\n- 函数声明必须有名字\n- 函数声明会函数提升，在预解析阶段就已创建，声明前后都可以调用\n- 函数表达式类似于变量赋值\n- 函数表达式可以没有名字，例如匿名函数\n- 函数表达式没有变量提升，在执行阶段创建，必须在表达式执行之后才可以调用\n\n\n## 函数声明语句的问题：\n\n- 将函数声明语句书写在if..else中时，不同得浏览器展现得效果是不同得。\n\n    - 下面是一个根据条件定义函数的例子：\n\n```javascript\n    if (true) {\n    function f () {\n        console.log(1)\n    }\n    } else {\n    function f () {\n        console.log(2)\n    }\n    }\n```\n\n以上代码执行结果在不同浏览器中结果不一致。\n\n不过我们可以使用函数表达式解决上面的问题：\n\n- 这是函数表达式得设置方式\n\n```javascript\n    var f\n\n    if (true) {\n    f = function () {\n        console.log(1)\n    }\n    } else {\n    f = function () {\n        console.log(2)\n    }\n    }\n```\n- 小结论：\n\t- 推荐使用函数表达式进行函数操作。\n\t- 如果习惯使用函数声明语句，可以在特殊场景中更换为函数表达式即可。\n    \n## 函数的调用方式\n\n- 普通函数\n- 构造函数\n- 对象方法\n\n\n## 函数内 `this` 指向的不同场景\n\n\n函数的调用方式决定了 `this` 指向的不同：\n\n| 调用方式   | 非严格模式   | 备注                |\n| ------ | ------- | ----------------- |\n| 普通函数调用 | window  | 严格模式下是 undefined  |\n| 构造函数调用 | 实例对象    | 原型方法中 this 也是实例对象 |\n| 对象方法调用 | 该方法所属对象 | 紧挨着的对象            |\n| 事件绑定方法 | 绑定事件对象  |                   |\n| 定时器函数  | window  |                   |\n\n这就是对函数内部 this 指向的基本整理，写代码写多了自然而然就熟悉了。\n\n## 函数也是对象\n\n\n- 所有函数都是 `Function` 的实例\n\n\n## call、apply、bind\n\n> 那了解了函数 this 指向的不同场景之后，我们知道有些情况下我们为了使用某种特定环境的 this 引用，\n\n> 这时候时候我们就需要采用一些特殊手段来处理了，例如我们经常在定时器外部备份 this 引用，然后在定时器函数内部使用外部 this 的引用。\n\n> 然而实际上对于这种做法我们的 JavaScript 为我们专门提供了一些函数方法用来帮我们更优雅的处理函数内部 this 指向问题。\n\n> 这就是接下来我们要学习的 call、apply、bind 三个函数方法。\n\n\n### call\n\n\n- 1. call()  用于调用函数，参数1 可以修改this的指向\n    - 只有本次调用时this会被修改\n```javascript\n        var fun = function(a,b){\n            console.log(this,a,b);\n        }\n        fun(100,200);\n        fun.call({name:'jack'},200,300);\n```        \n`call()` 方法调用一个函数, 其具有一个指定的 `this` 值和分别地提供的参数(参数的列表)。\n\n\n- 注意：该方法的作用和 `apply()` 方法类似，只有一个区别，就是 `call()` 方法接受的是若干个参数的列表，而 `apply()` 方法接受的是一个包含多个参数的数组。\n\n语法：\n\n```javascript\n    fun.call(thisArg[, arg1[, arg2[, ...]]])\n```\n\n参数：\n\n- `thisArg`\n  + 在 fun 函数运行时指定的 this 值\n  + 如果指定了 null 或者 undefined 则内部 this 指向 window\n\n- `arg1, arg2, ...`\n  + 指定的参数列表\n\n\n### apply\n\n\n- 2. apply() - 用于调用函数，参数1可以修改this的指向\n        - 只有本次调用时this会被修改。\n    - 与call的区别：\n        - 后续的实参值需要以数组形式传入\n```javascript\n    var fun = function(a,b){\n        console.log(this,a,b);\n    };\n    fun(100,200);\n    fun.apply({age:18},[100,200]);\n    fun();\n    fun.apply();\n```\n`apply()` 方法调用一个函数, 其具有一个指定的 `this` 值，以及作为一个数组（或类似数组的对象）提供的参数。\n\n\n- 注意：该方法的作用和 `call()` 方法类似，只有一个区别，就是 `call()` 方法接受的是若干个参数的列表，而 `apply()` 方法接受的是一个包含多个参数的数组。\n\n\n语法：\n\n```javascript\n    fun.apply(thisArg, [argsArray])\n```\n\n参数：\n\n- `thisArg`\n- `argsArray`\n\n`apply()` 与 `call()` 非常相似，不同之处在于提供参数的方式。\n`apply()` 使用参数数组而不是一组参数列表。例如：\n\n```javascript\n    fun.apply(this, ['eat', 'bananas'])\n```\n\n\n### bind\n\n\n> bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。\n\n> 当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。\n\n> 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。\n\n语法：\n\n```javascript\n    fun.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\n参数：\n\n- thisArg\n  + 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。\n\n- arg1, arg2, ...\n  + 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。\n\n返回值：\n\n返回由指定的this值和初始化参数改造的原函数拷贝。\n\n- 3. bind() - 用于创建函数副本，可以帮定副本内的this指向和某些实参\n    - 3.1 this的绑定操作\n    - 参数1：用于绑定函数副本中的this，无法在通过call或者apply进行修改\n    - 返回值：返回的函数副本\n```javascript\n        var fun = function(){\n            console.log(this);\n        };\n        fun();      //会调用函数,执行代码\n        fun.call(); //会调用函数,执行代码\n        fun.apply();//会调用函数,执行代码\n        var fun2 = fun.bind({name :'jack'})//不会调用函数，而是返回函数副本\n        console.log(fun2);\n        fun2();//this为绑定的对象\n        fun2.call({age:18});//this为绑定的对象，无法修改\n        fun2.apply({age:18});//this为绑定的对象，无法修改\n```\n- 3.2绑定后续实参\n    - 当使用bind绑定参数后，副本中的对应实参就是固定值了，调用时传参表示后续参数\n```javascript\n        var fun = function (a, b, c) {\n            console.log(a, b, c);\n        };\n        var fun2 = fun.bind(null, 100);\n        fun2(200, 300);\n```\n\n示例：\n```javascript\n// 例子：使用某些功能时，如果某些参数长期设置为固定值，可以使用bind方式进行绑定\n\t\tvar btn = document.getElementById('btn');\n\t\t/*btn.addEventListener('click', function () {\n\t\t\tconsole.log('这是点击事件1');\n\t\t});\n\t\tbtn.addEventListener('click', function () {\n\t\t\tconsole.log('这是点击事件2');\n\t\t});\n\t\tbtn.addEventListener('click', function () {\n\t\t\tconsole.log('这是点击事件3');\n\t\t});\n\t\tbtn.addEventListener('click', function () {\n\t\t\tconsole.log('这是点击事件4');\n\t\t});*/\n\n\t\tvar btnClick = btn.addEventListener.bind(btn, 'click');\n\t\tbtnClick(function () {\n\t\t\tconsole.log('这是点击事件1');\n\t\t});\n\t\tbtnClick(function () {\n\t\t\tconsole.log('这是点击事件2');\n\t\t});\n\t\tbtnClick(function () {\n\t\t\tconsole.log('这是点击事件3');\n\t\t});\n\t\tbtnClick(function () {\n\t\t\tconsole.log('这是点击事件4');\n\t\t});\n\t\t// bind - ie9以下不支持，但是常用.\n```\n#### 小结\n\n- call 和 apply 特性一样\n  + 都是用来调用函数，而且是立即调用\n  + 但是可以在调用函数的同时，通过第一个参数指定函数内部 `this` 的指向\n  + call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可\n  + apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递\n  + 如果第一个参数指定了 `null` 或者 `undefined` 则内部 this 指向 window\n\n- bind\n  + 可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数\n  + 它和 call、apply 最大的区别是：bind 不会调用\n  + bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递\n    * 1. 在 bind 的同时，以参数列表的形式进行传递\n    * 2. 在调用的时候，以参数列表的形式进行传递\n    * 那到底以谁 bind 的时候传递的参数为准呢还是以调用的时候传递的参数为准\n    * 两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部\n\n\n## 函数的其它成员\n\n\n- arguments\n  + 实参集合\n- caller\n  + 函数的调用者\n- length\n  + 形参的个数\n- name\n  + 函数的名称\n\n```javascript\n    function fn(x, y, z) {\n    console.log(fn.length) // => 形参的个数\n    console.log(arguments) // 伪数组实参参数集合\n    console.log(arguments.callee === fn) // 函数本身\n    console.log(fn.caller) // 函数的调用者\n    console.log(fn.name) // => 函数的名字\n    }\n\n    function f() {\n    fn(10, 20, 30)\n    }\n\n    f()\n```\n\n### 高阶函数\n\n- 函数可以作为参数\n  - 参数：\n  - 使用场景：当函数内的某些数据不确定时，采用参数。\n        \n  - 形参和实参：\n    - 书写位置：形参书写在函数体的小括号中，相当于一个局部变量\n    - 实参书写在函数调用中，用于以值传递的方式给形参赋值\n\n- 函数可以作为返回值\n    - 返回值：\n        - 函数根据功能分为两类。获取操作和设置操作\n        - 获取操作必须设置返回值，设置操作不需要设置返回值。\n\n#### 作为参数\n\n\n```javascript\n    function eat (callback) {\n    setTimeout(function () {\n        console.log('吃完了')\n        callback()\n    }, 1000)\n    }\n\n    eat(function () {\n    console.log('去唱歌')\n    })\n```\n\n\n#### 作为返回值\n\n\n```javascript\n    function genFun (type) {\n    return function (obj) {\n        return Object.prototype.toString.call(obj) === type\n    }\n    }\n\n    var isArray = genFun('[object Array]')\n    var isObject = genFun('[object Object]')\n\n    console.log(isArray([])) // => true\n    console.log(isArray({})) // => true\n```\n\n\n#### 函数的属性\n\n\n> 函数的属性：\n\n- 1. length - 用于获取形参个数\n```javascript\n    var fun = function (a,b,c){};\n    console.log(fun.length);\n```       \n\n- 2. prototype - 用于获取原型对象\n    - 这个属性是给构造函数准备的，普通函数不使用\n\n- 3. caller - 用于表示函数的调用位置\n    - 返回值：\n        - 全局调用函数，返回null\n        - 在某个函数内调用当前函数，返回调用位置\n```javascript\n        var fun = function(){\n            console.log(fun.caller);\n        };\n        var fun2 = function(){\n            fun();\n        };\n        fun2();\n```\n\n- 4. arguments属性 - 相当于函数内的arguments伪数组对象\n    - 这个属性官方已经不推荐使用了，推荐使用arguments对象结构\n```javascript\n        var fun = function(){\n            console.log(arguments);\n            console.log(fun.arguments);\n        }\n        fun(1,2,3);\n```\n\n- 4.1 arguments的使用\n    - 作用：用于获取函数传入的所有实参\n    - 返回值：伪数组对象(没有数组的方法)\n    - 常用的使用场景：模拟函数重载(根据实参的个数不同，设置不同的功能)   \n``` javascript        \n    //例如，函数传1个参数，直接打印，两个参个求和，3个参数求最大值\n    var fun = function(){\n        if(arguments.length === 1){\n            console.log(arguments[0]);\n        }else if(arguments.length === 2){\n            console.log('和为:' + (arguments[0] + arguments[1]));\n        }else if (arguments.length === 3){\n            var ag1 = arguments[0];\n            var ag2 = arguments[1];\n            var ag3 = arguments[2];\n\n            var max = ag1 > ag2 ? ag1 : ag2;\n            console.log(max > ag3 ? max : ag3);\n        }\n    };\n    fun(100);\n    fun(100,200);\n    fun(100,200,350);\n```\n\n- 4.2 arguments.callee - 用于获取当前函数\n    - 官方不推荐使用这个属性，直接使用名字即可\n```javascript \n    var fun = function(){\n        console.log(arguments.callee);\n    };\n    fun();\n```\n\n\n## 函数的其他使用方式(函数闭包)\n\n- 函数的使用方式：\n\t- 1 基本使用形式：函数声明语句，函数表达式\n\t- 2 立即执行函数(自调用函数)\n```javascript\n\t\t//\t\t- (function () {})(); \n\t\t//\t\t- 注意：最后要加;\n\t\t//\t\t- 作用：在书写位置执行一次，用于减少全局变量得使用\n\t\t//\t\t- 使用场景：会将每个独立的功能外使用立即执行函数包裹。（多个功能代码，多人得代码）\n\t\t//    - 常用的参数：\n\t\tvar count = 100;\n\t\t(function () {\n\t\t\t(function () {\n\t\t\t\t(function (window, document, count) {\n\t\t\t\t\t// var win = window;\n\t\t\t\t\twindow.count;\n\t\t\t\t\t// window得属性中，document属性使用是最多的\n\t\t\t\t\t// 为了减少对window对象属性得访问次数，可以将document进行相同设置\n\n\t\t\t\t\t// 如果在具体操作时还需要使用某些内容，也可以按照上面得方式进行设置，例如count\n\t\t\t\t})(window, document, count);\n\n\t\t\t})();\n\t\t\t(function () {\n\n\t\t\t})();\n\t\t\tcount;\n\t\t\tvar num = 100;\n\t\t})();\n\n\t\t(function () {\n\t\t\tvar num = 100;\n\t\t})();\n```\n\n\n## 模块化操作\n\n\n```javascript\n// 模块：模块实际上就是'部分'\n\t\t// 模块化：将一团功能代码清晰得分割为多个部分就成为模块化。\n\n\t\t// 模块化的操作方式：\n\t\t//\t\t1 使用立即执行函数\n\t\t//\t\t\t\t- 将每个模块外使用立即执行函数包裹\n\t\t//\t\t\t\t- 需要将每个模块中得主体功能进行'暴露'操作:将主体功能设置给window的属性\n\t\t//\t\t\t\t- 通常还可以将每个模块得功能代码使用独立得文件保存\n\t\t//      使用这种模块化操作方式得问题：\n\t\t//\t\t\t\t* 依赖关系(例如game模块需要使用snake和food模块，我们就称game依赖于snake和food)\n\t\t//\t\t\t\t- 由于多个功能相互之间具有依赖关系,意味着文件得引入顺序需要考虑\n\n\t\t//\t\t2 使用requirejs进行模块化操作\n\t\t//\t\t\t\t- requirejs是一个js库，这个库跟jQuery没有关系\n\t\t//\t\t\t\t- 作用：用于进行模块化操作\n\t\t\n```\n\n","tags":["JS"]},{"title":"34-继承与多态","url":"%2F2017%2F03%2F14%2FJS%2F34-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%2F","content":"\n\n# 继承\n\n## 什么是继承\n\n- **继承：为了实现更好的数据共享。**\n    - 例如：继承指的是对象与对象之间的继承操作。（你有的我也想有）\n\n\n- 现实生活中的继承\n- 程序中的继承\n\n## 借用构造函数继承\n\n- 这种继承方式称为借用构造函数继承。\n    - 好处：可以继承构造函数体中的属性，可以传参\n    - 缺点：无法继承原型中的方法\n```javascript\n\n\t\tfunction People (name, age) {\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t}\n\t\tPeople.prototype.sayHi = function () {\n\t\t\tconsole.log('你好，我是' + this.name);\n\t\t};\n\n\n\t\tfunction Student (name, age, school) {\n\t\t\t// 在Student中this为s1，将this传入到People.call(this)中\n\t\t\t//   表示将People中的this指向s1，People中的属性都会设置给s1\n\t\t\tPeople.call(this, name, age);\n\n\t\t\t// 这种继承方式称为借用构造函数继承。\n\t\t\t//  好处：可以继承构造函数体中的属性，可以传参\n\t\t\t//  缺点：无法继承原型中的方法\n\t\t\tthis.school = school;\n\t\t}\n\t\tStudent.prototype.sayHi = function () {\n\t\t\tconsole.log('你好，我是' + this.name);\n\t\t};\n\t\tStudent.prototype.study = function () {\n\t\t\tconsole.log('每天代码1w行');\n\t\t};\n\n\t\tvar p1 = new People('jack', 18);\n\t\tvar s1 = new Student('rose', 21, '北大');\n\t\tconsole.log(s1.name, s1.age, s1.school)\n\n\n\t\tfunction fun (name, age) {\n\t\t\tconsole.log(name, age, this);\n\t\t}\n\t\t// 普通的函数内使用this，指向window\n\t\tfun('jack', 100);\n\t\t// call方法的参数1用于设置某个函数内的this指向\n\t\tvar obj = {name : 'jack'};\n\t\tfun.call(obj, 'rose', 21);\n```\n\n## 原型继承方法\n\n- 这种继承方式称为原型继承\n    - 好处：可以继承原型中的所有功能\n    - 缺点：属性虽然也可以继承，但是是固定值，没有意义\n\n```javascript\n   function People (name, age) {\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t}\n\t\tPeople.prototype.sayHi = function () {\n\t\t\tconsole.log('你好，我是' + this.name);\n\t\t};\n\t\tPeople.prototype.sayHi1 = function () {\n\t\t\tconsole.log('你好，我是' + this.name);\n\t\t};\n\t\tPeople.prototype.sayHi2 = function () {\n\t\t\tconsole.log('你好，我是' + this.name);\n\t\t};\n\t\tPeople.prototype.sayHi3 = function () {\n\t\t\tconsole.log('你好，我是' + this.name);\n\t\t};\n\n\t\tfunction Student (school) {\n\t\t\tthis.school = school;\n\t\t}\n\t\tStudent.prototype = new People('rose', 18);\n\n\t\tStudent.prototype.study = function () {\n\t\t\tconsole.log('每天代码1w行');\n\t\t};\n\n\t\t// var p1 = new People('jack', 18);\n\t\tvar s1 = new Student('北大');\n\t\tconsole.log(s1.name, s1.age, s1.school);\n\t\t\n\t\tvar s2 = new Student('清华');\n\t\tconsole.log(s2.name);\n```\n\n## 组合继承\n\n- 组合继承是最常用的一种继承方式\n    - 实际上就是将借用构造继承和原型继承一起使用了而已。\n```javascript\n   function People (name, age) {\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t}\n\t\tPeople.prototype.sayHi = function () {\n\t\t\tconsole.log('你好，我是' + this.name);\n\t\t};\n\n\t\tfunction Student (name, age, school) {\n\t\t\tPeople.call(this, name, age);\n\t\t\tthis.school = school;\n\t\t}\n\t\t// 由于使用了借用构造函数继承方式，原型继承就不需要传参数了，没有意义\n\t\tStudent.prototype = new People();\n\t\tStudent.prototype.constructor = Student;\n\t\tStudent.prototype.study = function () {\n\t\t\tconsole.log('每天代码1w行');\n\t\t};\n\n\t\t// var p1 = new People('jack', 18);\n\t\tvar s1 = new Student('jack', 21, '北大');\n\t\tconsole.log(s1.name, s1.age, s1.school);\n\t\ts1.sayHi();\n\t\tconsole.log(s1.constructor);\n\n\t\t\tconsole.log(s1);\n```\n- 要注意的点：\n    - 1 由于原型继承方式直接覆盖了Student的原型，需要手动设置constructor\n    - 2 由于覆盖，需要将原型中新的方法设置在继承操作的后面\n\n## 拷贝继承方式：\n\n```javascript\n\t//   1 单个对象的继承操作\n\t\tvar obj = {\n\t\t\tname : 'jack',\n\t\t\tage : 18,\n\t\t\tsayHi : function () {\n\t\t\t\tconsole.log('这是sayHi');\n\t\t\t}\n\t\t};\n\n\t\tvar obj2 = {\n\t\t\tschool : '北大',\n\t\t\tsayHehe : function () {\n\t\t\t\tconsole.log('这是sayHehe');\n\t\t\t}\n\t\t};\n\n\t\t// 遍历，依次设置每个属性\n\t\tfor (var k in obj) {\n\t\t\tobj2[k] = obj[k];\n\t\t}\n\n\t\tconsole.log(obj2);\n```\n\n## 构造函数之间的拷贝继承\n\n```javascript\nfunction People (name, age) {\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t}\n\t\tPeople.prototype.sayHi = function () {\n\t\t\tconsole.log('你好，我是' + this.name);\n\t\t};\n\n\t\tfunction Student (name, age, school) {\n\t\t\tPeople.call(this, name, age);\n\t\t\tthis.school = school;\n\t\t}\n\t\tStudent.prototype.study = function () {\n\t\t\tconsole.log('每天代码1w行');\n\t\t};\n\t\t// 我们希望可以得到构造函数People原型中的方法，就可以利用遍历方式，将People原型中的功能直接设置给Student的原型\n\t\tfor (var k in People.prototype) {\n\t\t\tStudent.prototype[k] = People.prototype[k];\n\t\t}\n\n\t\tvar s1 = new Student('jack', 18, '清华');\n\t\ts1.sayHi();\n```\n\n\n## 原型链继承方式\n\n```javascript\n\t\tfunction People (name, age) {\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t}\n\t\tPeople.prototype.sayHi = function () {\n\t\t\tconsole.log('这是sayHi');\n\t\t};\n\n\t\tfunction Student (name, age, school) {\n\t\t\tPeople.call(this, name, age);\n\t\t\tthis.school = school;\n\t\t}\n\n\t\t// 使用原型继承可以继承原型中得所有功能，但是会增加一些不必要得属性\n\t\t// Student.prototype = new People();\n\n\t\t// 为了去除不必要得属性，可以使用一个空函数进行功能得中转\n\t\tfunction Fun () {}\n\t\tFun.prototype = People.prototype;\n\n\t\tStudent.prototype = new Fun();\n\t\tStudent.prototype.constructor = Student;\n\t\tStudent.prototype.study = function () {\n\t\t\tconsole.log('这是study');\n\t\t};\n\n\t\tvar s1 = new Student('jack', 18, '黑马');\n\t\tconsole.log(s1);\n```\n\n\n## 构造函数和实例对象和原型对象之间的关系\n\n\n```javascript\n    function CreateObj () {\n\n\t\t}\n\t\tCreateObj.prototype.sayHi = function () {\n\t\t\tconsole.log('这是sayHi方法');\n\t\t};\n\t\tvar c1 = new CreateObj();\n```\n- 实例对象都具有__proto__属性，指向了原型对象。\n    - 构造函数都具有prototype属性，指向了原型对象。\n    - 原型对象都具有constructor属性，指向构造函数，这个属性可以被实例对象访问。\n\n![](/media/构造函数和实例对象和原型对象之间的关系.png)\n\n\n\n\n## 多态\n\n- 多态：多态在js中的使用较少。\n\n\t- 含义：一个功能针对不同的数据进行使用时，呈现得功能是不同的。\n\n- 由于js是弱类型语言，变量声明使用var，表示不用确定变量得类型。使用多态不适合\n\n\t- 而且操作较为繁琐，通常不使用。\n\n```javascript\n\n\t\t// 功能：打印传入得值\n\t\tfunction fun (value) {\n\t\t\t// console.log(value);\n\t\t\tif (typeof value === 'string') {\n\t\t\t\tconsole.log('哈哈哈，这是字符串' + value);\n\t\t\t} else if (typeof value === 'number') {\n\t\t\t\tconsole.log('这个value和100得和为：' + (value + 100));\n\t\t\t}\n\t\t}\n\t\tfun(100);\n\t\tfun('abc');\n\n```\n\n\n\n---","tags":["JS"]},{"title":"33-原型","url":"%2F2017%2F03%2F13%2FJS%2F33-%E5%8E%9F%E5%9E%8B%2F","content":"\n# 原型\n\n内容引导：\n\n- 使用 prototype 原型对象解决构造函数的问题\n- 分析 构造函数、prototype 原型对象、实例对象 三者之间的关系\n- 属性成员搜索原则：原型链\n- 实例对象读写原型对象中的成员\n- 原型对象的简写形式\n- 原生对象的原型\n  + Object\n  + Array\n  + String\n  + ...\n- 原型对象的问题\n- 构造的函数和原型对象使用建议\n\n\n## 更好的解决方案： `prototype`\n\n\nJavascript 规定，每一个构造函数都有一个 `prototype` 属性，指向另一个对象。\n这个对象的所有属性和方法，都会被构造函数的实例继承。\n\n这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 `prototype` 对象上。\n\n```javascript\nfunction Person (name, age) {\n  this.name = name\n  this.age = age\n}\n\nconsole.log(Person.prototype)\n\nPerson.prototype.type = 'human'\n\nPerson.prototype.sayName = function () {\n  console.log(this.name)\n}\n\nvar p1 = new Person(...)\nvar p2 = new Person(...)\n\nconsole.log(p1.sayName === p2.sayName) // => true\n```\n\n这时所有实例的 `type` 属性和 `sayName()` 方法，\n其实都是同一个内存地址，指向 `prototype` 对象，因此就提高了运行效率。\n\n\n## 构造函数、实例、原型三者之间的关系\n\n\n![](../media/构造函数-实例-原型之间的关系.png)\n\n- 任何函数都具有一个 `prototype` 属性，该属性是一个对象。\n\n```javascript\nfunction F () {}\nconsole.log(F.prototype) // => object\n\nF.prototype.sayHi = function () {\n  console.log('hi!')\n}\n```\n\n- 构造函数的 `prototype` 对象默认都有一个 `constructor` 属性，指向 `prototype` 对象所在函数。\n\n```javascript\nconsole.log(F.constructor === F) // => true\n```\n\n- 通过构造函数得到的实例对象内部会包含一个指向构造函数的 `prototype` 对象的指针 `__proto__`。\n\n```javascript\nvar instance = new F()\nconsole.log(instance.__proto__ === F.prototype) // => true\n```\n\n<p class=\"tip\">\n  `__proto__` 是非标准属性。\n</p>\n\n- 实例对象可以直接访问原型对象成员。\n```javascript\ninstance.sayHi() // => hi!\n```\n\n- instanceof - 实例\n```javascript\n        function People (name, age) {\n            this.name = name;\n            this.age = age;\n        }\n        People.prototype.sayHi = function () {\n            console.log('这是sayHi');\n        };\n\n        function Student (name, age, school) {\n            People.call(this, name, age);\n            this.school = school\n        }\n        Student.prototype = new People();\n        Student.prototype.constructor = Student;\n        Student.prototype.study = function () {\n            console.log('这是study');\n        };\n\n        var s1 = new Student('jack', 18, '北京');\n        \n        //instance - 实例\n        //instanceof - 检测，如果某个构造函数存在与某个实例对象的原型链中，即可返回true\n        console.log(s1 instanceof Student); //true\n        console.log(s1 instanceof People);  //true\n        console.log(se instanceof Object);  //true\n        \n```\n\n\n总结：\n\n- 任何函数都具有一个 `prototype` 属性，该属性是一个对象\n- 构造函数的 `prototype` 对象默认都有一个 `constructor` 属性，指向 `prototype` 对象所在函数\n- 通过构造函数得到的实例对象内部会包含一个指向构造函数的 `prototype` 对象的指针 `__proto__`\n- 所有实例都直接或间接继承了原型对象的成员\n\n\n\n\n\n## 属性成员的搜索原则：原型链\n\n- 原型链的作用\n  - 原型链式用来描述是对象和原型对象之间关系的方式\n\n- 对象的属性访问过程\n  - 沿原型链向上查找\n\n- 原型链的终点\n\t- Object.prototype\n  \n了解了 **构造函数-实例-原型对象** 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。\n\n每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性\n\n- 搜索首先从对象实例本身开始\n- 如果在实例中找到了具有给定名字的属性，则返回该属性的值\n- 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性\n- 如果在原型对象中找到了这个属性，则返回该属性的值\n\n也就是说，在我们调用 `person1.sayName()` 的时候，会先后执行两次搜索：\n\n- 首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。\n- ”然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。\n- ”于是，它就读取那个保存在原型对象中的函数。\n- 当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。\n\n而这正是多个对象实例共享原型所保存的属性和方法的基本原理。\n\n总结：\n\n- 先在自己身上找，找到即返回\n- 自己身上找不到，则沿着原型链向上查找，找到即返回\n- 如果一直到原型链的末端还没有找到，则返回 `undefined`\n\n\n## 实例对象读写原型对象成员\n\n\n读取：\n\n- 先在自己身上找，找到即返回\n- 自己身上找不到，则沿着原型链向上查找，找到即返回\n- 如果一直到原型链的末端还没有找到，则返回 `undefined`\n\n值类型成员写入（`实例对象.值类型成员 = xx`）：\n\n- 当实例期望重写原型对象中的某个普通数据成员时实际上会把该成员添加到自己身上\n- 也就是说该行为实际上会屏蔽掉对原型对象成员的访问\n\n引用类型成员写入（`实例对象.引用类型成员 = xx`）：\n\n- 同上\n\n复杂类型修改（`实例对象.成员.xx = xx`）：\n\n- 同样会先在自己身上找该成员，如果自己身上找到则直接修改\n- 如果自己身上找不到，则沿着原型链继续查找，如果找到则修改\n- 如果一直到原型链的末端还没有找到该成员，则报错（`实例对象.undefined.xx = xx`）\n\n\n## 更简单的原型语法\n\n\n我们注意到，前面例子中每添加一个属性和方法就要敲一遍 `Person.prototype` 。\n为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：\n\n```javascript\nfunction Person (name, age) {\n  this.name = name\n  this.age = age\n}\n\nPerson.prototype = {\n  type: 'human',\n  sayHello: function () {\n    console.log('我叫' + this.name + '，我今年' + this.age + '岁了')\n  }\n}\n```\n\n在该示例中，我们将 `Person.prototype` 重置到了一个新的对象。\n这样做的好处就是为 `Person.prototype` 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 `constructor` 成员。\n\n所以，我们为了保持 `constructor` 的指向正确，建议的写法是：\n\n```javascript\nfunction Person (name, age) {\n  this.name = name\n  this.age = age\n}\n\nPerson.prototype = {\n  constructor: Person, // => 手动将 constructor 指向正确的构造函数\n  type: 'human',\n  sayHello: function () {\n    console.log('我叫' + this.name + '，我今年' + this.age + '岁了')\n  }\n}\n```\n\n## 原生对象的原型\n\n<p class=\"tip\">\n  所有函数都有 prototype 属性对象。\n</p>\n\n- Object.prototype\n- Function.prototype\n- Array.prototype\n- String.prototype\n- Number.prototype\n- Date.prototype\n- ...\n\n练习：为数组对象和字符串对象扩展原型方法。\n\n## 原型对象的问题\n\n- 共享数组\n- 共享对象\n\n如果真的希望可以被实例对象之间共享和修改这些共享数据那就不是问题。但是如果不希望实例之间共享和修改这些共享数据则就是问题。\n\n一个更好的建议是，最好不要让实例之间互相共享这些数组或者对象成员，一旦修改的话会导致数据的走向很不明确而且难以维护。\n\n## 原型对象使用建议\n\n- 私有成员（一般就是非函数成员）放到构造函数中\n- 共享成员（一般就是函数）放到原型对象中\n- 如果重置了 `prototype` 记得修正 `constructor` 的指向","tags":["JS"]},{"title":"32-构造函数","url":"%2F2017%2F03%2F13%2FJS%2F32-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F","content":"\n# 构造函数\n\n内容引导：\n\n- 构造函数语法\n- 分析构造函数\n- 构造函数和实例对象的关系\n  + 实例的 constructor 属性\n  + instanceof 操作符\n- 普通函数调用和构造函数调用的区别\n- 构造函数的返回值\n- 构造函数的静态成员和实例成员\n  + 函数也是对象\n  + 实例成员\n  + 静态成员\n- 构造函数的问题\n\n\n## 更优雅的工厂函数：构造函数\n\n- 一种更优雅的工厂函数就是下面这样，构造函数：\n\n```javascript\n    function Person (name, age) {\n    this.name = name\n    this.age = age\n    this.sayName = function () {\n        console.log(this.name)\n    }\n    }\n    var p1 = new Person('Jack', 18)\n    p1.sayName() // => Jack\n\n    var p2 = new Person('Mike', 23)\n    p2.sayName() // => Mike\n```\n\n## 解析构造函数代码的执行\n\n> 在上面的示例中，`Person()` 函数取代了 `createPerson()` 函数，但是实现效果是一样的。\n这是为什么呢？\n>\n>我们注意到，`Person()` 中的代码与 `createPerson()` 有以下几点不同之处：\n\n- 没有显示的创建对象\n- 直接将属性和方法赋给了 `this` 对象\n- 没有 `return` 语句\n- 函数名使用的是大写的 `Person`\n\n而要创建 `Person` 实例，则必须使用 `new` 操作符。\n以这种方式调用构造函数会经历以下 4 个步骤：\n\n1. 创建一个新对象\n2. 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）\n3. 执行构造函数中的代码\n4. 返回新对象\n\n- 下面是具体的伪代码：\n\n```javascript\n    function Person (name, age) {\n    // 当使用 new 操作符调用 Person() 的时候，实际上这里会先创建一个对象\n    // var instance = {}\n    // 然后让内部的 this 指向 instance 对象\n    // this = instance\n    // 接下来所有针对 this 的操作实际上操作的就是 instance\n\n    this.name = name\n    this.age = age\n    this.sayName = function () {\n        console.log(this.name)\n    }\n\n    // 在函数的结尾处会将 this 返回，也就是 instance\n    // return this\n    }\n```\n\n## 构造函数和实例对象的关系\n\n> 使用构造函数的好处不仅仅在于代码的简洁性，更重要的是我们可以识别对象的具体类型了。\n\n> 在每一个实例对象中的\\__proto\\__中同时有一个 `constructor` 属性，该属性指向创建该实例的构造函数：\n\n```javascript\n    console.log(p1.constructor === Person) // => true\n    console.log(p2.constructor === Person) // => true\n    console.log(p1.constructor === p2.constructor) // => true\n```\n\n> 对象的 `constructor` 属性最初是用来标识对象类型的，\n但是，如果要检测对象的类型，还是使用 `instanceof` 操作符更可靠一些：\n\n```javascript\n    console.log(p1 instanceof Person) // => true\n    console.log(p2 instanceof Person) // => true\n```\n\n总结：\n\n- 构造函数是根据具体的事物抽象出来的抽象模板\n- 实例对象是根据抽象的构造函数模板得到的具体实例对象\n- 每一个实例对象都具有一个 `constructor` 属性，指向创建该实例的构造函数\n  + 注意： `constructor` 是实例的属性的说法不严谨，具体后面的原型会讲到\n- 可以通过实例的 `constructor` 属性判断实例和构造函数之间的关系\n  + 注意：这种方式不严谨，推荐使用 `instanceof` 操作符，后面学原型会解释为什么\n\n## 构造函数的问题\n\n使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题：\n```javascript\n    function Person (name, age) {\n    this.name = name\n    this.age = age\n    this.type = 'human'\n    this.sayHello = function () {\n        console.log('hello ' + this.name)\n    }\n    }\n\n    var p1 = new Person('zxx', 18)\n    var p2 = new Person('Jack', 16)\n```\n\n> 在该示例中，从表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。\n>\n>那就是对于每一个实例对象，`type` 和 `sayHello` 都是一模一样的内容，\n>\n>每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。\n```javascript\n    console.log(p1.sayHello === p2.sayHello) // => false\n```\n- 对于这种问题我们可以把需要共享的函数定义到构造函数外部：\n\n\n```javascript\n    function sayHello = function () {\n    console.log('hello ' + this.name)\n    }\n\n    function Person (name, age) {\n    this.name = name\n    this.age = age\n    this.type = 'human'\n    this.sayHello = sayHello\n    }\n\n    var p1 = new Person('zxx', 18)\n    var p2 = new Person('Jack', 16)\n\n    console.log(p1.sayHello === p2.sayHello) // => true\n```\n\n> 这样确实可以了，但是如果有多个需要共享的函数的话就会造成全局命名空间冲突的问题。\n\n> 你肯定想到了可以把多个函数放到一个对象中用来避免全局命名空间冲突的问题：\n\n```javascript\n    var fns = {\n    sayHello: function () {\n        console.log('hello ' + this.name)\n    },\n    sayAge: function () {\n        console.log(this.age)\n    }\n    }\n\n    function Person (name, age) {\n    this.name = name\n    this.age = age\n    this.type = 'human'\n    this.sayHello = fns.sayHello\n    this.sayAge = fns.sayAge\n    }\n\n    var p1 = new Person('zxx', 18)\n    var p2 = new Person('Jack', 16)\n\n    console.log(p1.sayHello === p2.sayHello) // => true\n    console.log(p1.sayAge === p2.sayAge) // => true\n```\n至此，我们利用自己的方式基本上解决了构造函数的内存浪费问题。\n但是代码看起来还是那么的格格不入，那有没有更好的方式呢？\n\n## 小结\n\n- 构造函数语法\n- 分析构造函数\n- 构造函数和实例对象的关系\n  + 实例的 constructor 属性\n  + instanceof 操作符\n- 构造函数的问题\n\n","tags":["JS"]},{"title":"31-创建对象","url":"%2F2017%2F03%2F12%2FJS%2F31-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F","content":"\n# 创建对象\n\n- 我们可以直接通过 `new Object()` 创建：\n\n```javascript\n    var person = new Object()\n    person.name = 'Jack'\n    person.age = 18\n\n    person.sayName = function () {\n    console.log(this.name)\n    }\n```\n每次创建通过 `new Object()` 比较麻烦，所以可以通过它的简写形式对象字面量来创建\n```javascript\n    var person = {\n    name: 'Jack',\n    age: 18,\n    sayName: function () {\n        console.log(this.name)\n    }\n    }\n```\n- 对于上面的写法固然没有问题，但是假如我们要生成两个 `person` 实例对象呢？\n```javascript\n    var person1 = {\n    name: 'Jack',\n    age: 18,\n    sayName: function () {\n        console.log(this.name)\n    }\n    }\n\n    var person2 = {\n    name: 'Mike',\n    age: 16,\n    sayName: function () {\n        console.log(this.name)\n    }\n    }\n```\n- 通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。\n\n## 简单方式的改进：工厂函数\n\n- 我们可以写一个函数，解决代码重复问题：\n\n```javascript\n    function createPerson (name, age) {\n    return {\n        name: name,\n        age: age,\n        sayName: function () {\n        console.log(this.name)\n        }\n    }\n    }\n```\n然后生成实例对象：\n\n```javascript\nvar p1 = createPerson('Jack', 18)\nvar p2 = createPerson('Mike', 18)\n```\n\n> 这样封装确实爽多了，通过工厂模式我们解决了创建多个相似对象代码冗余的问题，\n\n> 但却没有解决对象识别的问题（即怎样知道一个对象的类型）。","tags":["JS"]},{"title":"30-面向对象","url":"%2F2017%2F03%2F12%2FJS%2F30-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F","content":"\n# JavaScript 面向对象编程\n\n## 面向对象介绍\n\n- 面向对象简介：\n  - 面向对象是一种编程思想，面向过程也是一种编程思想。\n\n- 面向：专注于\n  - 面向过程：我们以前书写的代码大部分都是面向过程的，专注于功能操作的细节，每个步骤都需要自己进行处理。\n\n- 面向对象(工具)：我们以前也进行过面向对象的操作，例如，使用内置对象的功能，使用jQuery的功能。\n\n\n- 面向过程就像我们自己在家做饭：买菜，洗菜，切菜，炒菜，放调料，称出来，刷锅\n- 面向对象就像我们去饭馆吃饭：找到心仪的饭馆，吃就可以了(交钱)\n\n\n- 注意：能不能说面向对象比面向过程好呢？不能，两种编程思想不具有可比性。\n\n\n## 面向对象的特性：\n\n- javascript原生不支持面向对象，es6\n- 可以通过其他操作去模拟面向对象。\n\n  - 封装性 - 对象(工具)封装\n  - 继承性 - 为了实现功能的复用\n  - 多态性 - 增强功能使用的灵活性 \n  \n\n## 什么是对象\n\n> Everything is object （万物皆对象）\n\n对象到底是什么，我们可以从两次层次来理解。\n\n- **(1) 对象是单个事物的抽象。**\n\n> 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。\n\n- **(2) 对象是一个容器，封装了属性（property）和方法（method）。**\n\n> 属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。\n\n\n> 在实际开发中，对象是一个抽象的概念，可以将其简单理解为：**数据集或功能集**。\n\n> ECMAScript-262 把对象定义为：**无序属性的集合，其属性可以包含基本值、对象或者函数**。\n> 严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都\n映射到一个值。\n\n\n> 提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。\n\n\n## 什么是面向对象\n\n> 面向对象不是新的东西，它只是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。\n\n![](../media/664ba37eeee9f4623c06c066867f1d38_r.jpg)\n> 面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。\n\n它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\n\n> 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。\n\n因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。\n\n面向对象与面向过程：\n\n- 面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊\n- 面向对象就是找一个对象，指挥得结果\n- 面向对象将执行者转变成指挥者\n- 面向对象不是面向过程的替代，而是面向过程的封装\n\n\n\n\n扩展阅读：\n\n- [维基百科 - 面向对象程序设计](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)\n- [知乎：如何用一句话说明什么是面向对象思想？](https://www.zhihu.com/question/19854505)\n- [知乎：什么是面向对象编程思想？](https://www.zhihu.com/question/31021366)\n\n\n### 程序中面向对象的基本体现\n\n> 在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。\n自定义的对象数据类型就是面向对象中的类（ Class ）的概念。\n\n我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。\n\n假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个对象表示：\n\n```javascript\n  var std1 = { name: 'Michael', score: 98 }\n  var std2 = { name: 'Bob', score: 81 }\n```\n\n\n而处理学生成绩可以通过函数实现，比如打印学生的成绩：\n\n```javascript\n  function printScore (student) {\n    console.log('姓名：' + student.name + '  ' + '成绩：' + student.score)\n  }\n```\n\n> 如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，\n而是 `Student` 这种数据类型应该被视为一个对象，这个对象拥有 `name` 和 `score` 这两个属性（Property）。\n> 如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 `printScore` 消息，让对象自己把自己的数据打印出来。\n\n- 抽象数据行为模板（Class）：\n```javascript\n  function Student (name, score) {\n    this.name = name\n    this.score = score\n  }\n\n  Student.prototype.printScore = function () {\n    console.log('姓名：' + this.name + '  ' + '成绩：' + this.score)\n  }\n```\n\n- 根据模板创建具体实例对象（Instance）：\n```javascript\n  var std1 = new Student('Michael', 98)\n  var std2 = new Student('Bob', 81)\n```\n\n- 实例对象具有自己的具体行为（给对象发消息）：\n\n```javascript\n  std1.printScore() // => 姓名：Michael  成绩：98\n  std2.printScore() // => 姓名：Bob  成绩 81\n```\n> 面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。\nClass 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念，\n\n> 而实例（Instance）则是一个个具体的 Student ，比如， Michael 和 Bob 是两个具体的 Student 。\n\n所以，面向对象的设计思想是：\n\n- 抽象出 Class\n- 根据 Class 创建 Instance\n- 指挥 Instance 得结果\n\n面向对象的抽象程度又比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。","tags":["JS"]},{"title":"29-回顾掌握","url":"%2F2017%2F03%2F11%2FJS%2F29-%E5%9B%9E%E9%A1%BE%E6%8E%8C%E6%8F%A1%2F","content":"\n# 重新介绍 JavaScript\n\nJavaScript 是什么\n\n- 解析执行：轻量级解释型的，或是 JIT 编译型的程序设计语言\n- 语言特点：动态，头等函数 (First-class Function)\n  - 又称函数是 JavaScript 中的一等公民\n- 执行环境：在宿主环境（host environment）下运行，浏览器是最常见的 JavaScript 宿主环境\n  - 但是在很多非浏览器环境中也使用 JavaScript ，例如 node.js\n- 编程范式：基于原型、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如：函数式编程）编程风格\n\n## JavaScript 与浏览器的关系\n\n![](../media/browser-js.png)\n\n\n## JavaScript 的组成\n\n\n| 组成部分       | 说明                |\n| ---------- | ----------------- |\n| Ecmascript | 描述了该语言的语法和基本对象    |\n| DOM        | 描述了处理网页内容的方法和接口   |\n| BOM        | 描述了与浏览器进行交互的方法和接口 |\n\n## JavaScript 可以做什么\n\n\n> Any application that can be written in JavaScript, will eventually be written in JavaScript.  \n> 凡是能用 JavaScript 写出来的，最终都会用 JavaScript 写出来\n\n- [知乎 - JavaScript 能做什么，该做什么？](https://www.zhihu.com/question/20796866)\n- [最流行的编程语言 JavaScript 能做什么？](https://github.com/phodal/articles/issues/1)\n\n\n## JavaScript 发展历史\n\n\n> [JavaScript 标准参考教程 - JavaScript 语言的历史](http://javascript.ruanyifeng.com/introduction/history.html)\n\n- JavaScript 的诞生\n- JavaScript 与 Ecmascript 的关系\n- JavaScript 与 Java 的关系\n- JavaScript 的版本\n- JavaScript 周边大事记\n\n\n## JavaScript 执行过程\n\n\nJavaScript 运行分为两个阶段：\n\n- 预解析\n  + 全局预解析（所有变量和函数声明都会提前；同名的函数和变量函数的优先级高）\n  + 函数内部预解析（所有的变量、函数和形参都会参与预解析）\n    * 函数\n    * 形参\n    * 普通变量\n- 执行\n\n先预解析全局作用域，然后执行全局作用域中的代码，\n在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码。\n\n---","tags":["JS"]},{"title":"28-js原生轮播图","url":"%2F2017%2F03%2F10%2FJS%2F28-%E8%BD%AE%E6%92%AD%E5%9B%BE%2F","content":"\n# 轮播图\n\n## 简单轮播图\n\n1.\t结构分析\n2.\t按钮高亮以及排他\n3.\t移动图片：\n\t渐渐的移动图片，用到animate函数\n\n```javascript\n\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n            list-style: none;\n        }\n        img {\n            vertical-align: middle;/*去掉图片上下三像素缝隙*/\n        }\n        .outer {\n            width: 490px;\n            height: 170px;\n            padding: 5px;\n            margin: 100px auto;\n            border: 1px solid #ccc;\n        }\n        .inner {\n            width: 490px;\n            height: 170px;\n            overflow: hidden;\n            position: relative;\n        }\n        ul {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 510%;\n        }\n        ul li {\n            float: left;\n        }\n        ol {\n            position: absolute;\n            bottom: 10px;\n            right: 10px;\n        }\n        ol li {\n            float: left;\n            width: 16px;\n            height: 16px;\n            text-align: center;\n            line-height: 16px;\n            border: 1px solid #ccc;\n            margin: 0 5px;\n            cursor: pointer;\n            background-color: #fff;\n        }\n        .current {\n            color: #fff;\n            background-color: orange;\n        }\n    </style>\n    <script>\n        window.onload = function () {\n            //需求：鼠标进入哪个ol中的li，移动ul;\n                    //思路: 1.点亮盒子;   2.移动ul;\n\n            //获取相关元素\n            var outer = document.getElementById(\"outer\");\n            var inner = outer.firstElementChild || outer.firstChild;\n            var imgWidth = inner.offsetWidth;\n            var ol = inner.lastElementChild || inner.lastChild;\n            var ul = ol.previousElementSibling || ol.previousSibling;\n            var olLiArr = ol.children;\n\n            //for循环绑定事件：//思路: 1.点亮盒子;   2.移动ul;\n            for(var i=0;i<olLiArr.length;i++){\n                //自定义属性绑定索引值\n                olLiArr[i].index = i;\n                olLiArr[i].onmouseover = function () {\n                    //思路: 1.点亮盒子;   2.移动ul;\n                    //1.点亮盒子;(排他思想)\n                    for(var j=0;j<olLiArr.length;j++){\n                        olLiArr[j].className = \"\";\n                    }\n                    this.className = \"current\";\n\n                    //2.移动ul;\n                        //a.鼠标放在ol中的第一个li上，ul向左移动0;\n                        //b.鼠标放在ol中的第二个li上，ul向左移动1张图片的宽;\n                        //c.鼠标放在ol中的第三个li上，ul向左移动2张图片的宽;\n                        //....\n                        //n.鼠标放在ol中的第n个li上，ul向左移动li对应\"索引值\"张图片的宽;\n                    var sss = this.index*imgWidth;\n                    animate(ul,-sss);\n                }\n            }\n        }\n        //匀速动画封装\n        function animate(ele,target) {\n            //要用定时器，先清除定时器;\n            clearInterval(ele.timer);\n            //设置定时器;\n            ele.timer = setInterval(function () {\n                //1.获取步长;\n                var step = target > ele.offsetLeft? 10: -10;\n                //2.赋值\n                ele.style.left = ele.offsetLeft + step + \"px\";\n                //3.目标位置和当前位置不足或者等于一个步长就清除定时器i;\n                if(Math.abs(target-ele.offsetLeft) <= Math.abs(step)){\n                    //清除定时器之前，直接设置目标位置\n                    ele.style.left = target+\"px\";\n                    clearInterval(ele.timer);\n                }\n            },10);\n        }\n    </script>\n</head>\n<body>\n\n    <div class=\"outer\" id=\"outer\">\n        <div class=\"inner\">\n            <ul>\n                <li><img src=\"images/01.jpg\"/></li>\n                <li><img src=\"images/02.jpg\"/></li>\n                <li><img src=\"images/03.jpg\"/></li>\n                <li><img src=\"images/04.jpg\"/></li>\n                <li><img src=\"images/05.jpg\"/></li>\n            </ul>\n            <ol>\n                <li class=\"current\">1</li>\n                <li>2</li>\n                <li>3</li>\n                <li>4</li>\n                <li>5</li>\n            </ol>\n        </div>\n    </div>\n\n\n</body>\n</html>\n```\n\n## 左右焦点图\n\n1.\t结构分析\n2.\t左右箭头的显示与隐藏\n3.\t点击左箭头与右箭头（下标判断）\n\n```javascript\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n    <title>无标题文档</title>\n    <style type=\"text/css\">\n        body, ul, ol, li, img {\n            margin: 0;\n            padding: 0;\n            list-style: none;\n        }\n\n        #box {\n            width: 490px;\n            height: 170px;\n            padding: 5px;\n            position: relative;\n            border: 1px solid #ccc;\n            margin: 100px auto 0;\n            overflow: hidden;\n        }\n\n        .ad {\n            width: 490px;\n            height: 170px;\n            overflow: hidden;\n            position: relative;\n        }\n\n        #box img {\n            width: 490px;\n        }\n\n        .ad ol {\n            position: absolute;\n            right: 10px;\n            bottom: 10px;\n        }\n\n        .ad ol li {\n            width: 20px;\n            height: 20px;\n            line-height: 20px;\n            border: 1px solid #ccc;\n            text-align: center;\n            background: #fff;\n            float: left;\n            margin-right: 10px;\n            cursor: pointer;\n            _display: inline;\n        }\n\n        .ad ol li.current {\n            background: yellow;\n        }\n\n        .ad ul li {\n            float: left;\n        }\n\n        .ad ul {\n            position: absolute;\n            top: 0;\n            width: 2940px;\n        }\n\n        .ad ul li.current {\n            display: block;\n        }\n\n        #arr {\n            /*display: none;*/\n        }\n\n        #arr span {\n            width: 40px;\n            height: 40px;\n            position: absolute;\n            left: 5px;\n            top: 50%;\n            margin-top: -20px;\n            background: #000;\n            cursor: pointer;\n            line-height: 40px;\n            text-align: center;\n            font-weight: bold;\n            font-family: '黑体';\n            font-size: 30px;\n            color: #fff;\n            opacity: 0.3;\n            border: 1px solid #fff;\n        }\n\n        #arr #right {\n            right: 5px;\n            left: auto;\n        }\n    </style>\n    <script>\n        window.onload = function () {\n            //需求: 点击右侧按钮，移动ul;\n            //(自定义索引值，点击后自增/自减，逻辑左侧和右侧相反);\n\n            //获取元素;\n            var ul = document.getElementById(\"imgs\");\n            var left = document.getElementById(\"left\");\n            var right = document.getElementById(\"right\");\n            var imgWidth = document.getElementById(\"ad\").offsetWidth;\n\n            //右侧按钮，点击以后自定义的索引值自增;\n            var index = 0;//自定义索引值;\n            right.onclick = function () {\n                //自增\n                index++;\n                //判断：不能超过5个;\n                if(index === 5){\n                    index = 4;//变回原来的值;\n                    alert(\"已经是最后一张\");\n                    return;\n                }\n                //移动ul；\n                var sss = imgWidth*index;\n                animate(ul,-sss);\n            }\n\n\n            //左侧逻辑相反\n            left.onclick = function () {\n                //自减\n                index--;\n                //判断：不能等于-1;\n                if(index === -1){\n                    index = 0;//变回原来的值;\n                    alert(\"已经是第一张\");\n                    return;\n                }\n                //移动ul；\n                var sss = imgWidth*index;\n                animate(ul,-sss);\n            }\n\n\n        }\n\n        //匀速动画封装\n        function animate(ele,target) {\n            //要用定时器，先清除定时器;\n            clearInterval(ele.timer);\n            //设置定时器;\n            ele.timer = setInterval(function () {\n                //1.获取步长;\n                var step = target > ele.offsetLeft? 10: -10;\n                //2.赋值\n                ele.style.left = ele.offsetLeft + step + \"px\";\n                //3.目标位置和当前位置不足或者等于一个步长就清除定时器i;\n                if(Math.abs(target-ele.offsetLeft) <= Math.abs(step)){\n                    //清除定时器之前，直接设置目标位置\n                    ele.style.left = target+\"px\";\n                    clearInterval(ele.timer);\n                }\n            },10);\n        }\n    </script>\n</head>\n<body>\n\n    <div id=\"box\" class=\"all\">\n        <div class=\"ad\" id=\"ad\">\n            <ul id=\"imgs\">\n                <li><img src=\"images/1.jpg\"/></li>\n                <li><img src=\"images/2.jpg\"/></li>\n                <li><img src=\"images/3.jpg\"/></li>\n                <li><img src=\"images/4.jpg\"/></li>\n                <li><img src=\"images/5.jpg\"/></li>\n            </ul>\n        </div>\n        <div id=\"arr\">\n            <span id=\"left\"><</span>\n            <span id=\"right\">></span>\n        </div>\n    </div>\n\n</body>\n</html>\n```\n\n\n## 无缝轮播图\n\n1. 需要添加假图片\n2. 真图片与假图片之间互相切换。\n\n```javascript\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n    <title>无标题文档</title>\n    <style type=\"text/css\">\n        * {\n            padding: 0;\n            margin: 0;\n            list-style: none;\n            border: 0;\n        }\n\n        .all {\n            width: 500px;\n            height: 200px;\n            padding: 7px;\n            border: 1px solid #ccc;\n            margin: 100px auto;\n            position: relative;\n        }\n\n        .screen {\n            width: 500px;\n            height: 200px;\n            overflow: hidden;\n            position: relative;\n        }\n\n        .screen li {\n            width: 500px;\n            height: 200px;\n            overflow: hidden;\n            float: left;\n        }\n\n        .screen ul {\n            position: absolute;\n            left: 0;\n            top: 0px;\n            width: 3000px;\n        }\n\n        .all ol {\n            position: absolute;\n            right: 10px;\n            bottom: 10px;\n            line-height: 20px;\n            text-align: center;\n        }\n\n        .all ol li {\n            float: left;\n            width: 20px;\n            height: 20px;\n            background: #fff;\n            border: 1px solid #ccc;\n            margin-left: 10px;\n            cursor: pointer;\n        }\n\n        .all ol li.current {\n            background: yellow;\n        }\n\n        #arr {\n            display: none;\n        }\n        #arr span {\n            width: 40px;\n            height: 40px;\n            position: absolute;\n            left: 5px;\n            top: 50%;\n            margin-top: -20px;\n            background: #000;\n            cursor: pointer;\n            line-height: 40px;\n            text-align: center;\n            font-weight: bold;\n            font-family: '黑体';\n            font-size: 30px;\n            color: #fff;\n            opacity: 0.3;\n            border: 1px solid #fff;\n        }\n\n        #arr #right {\n            right: 5px;\n            left: auto;\n        }\n\n    </style>\n    <script>\n        window.onload = function () {\n            //案例3：无缝滚动;\n                //原理：复制第一张到添加到ul的最末尾最末尾，\n                // 当第二轮从第一张滑向第二种的时候瞬间闪动到第一张，\n                // 在动第一张滑向第二张;\n\n            //需求1: 复制第一张图片添加到ul的最末尾，生成很多li添加到ol中，把第一张点亮;\n            //需求2: 鼠标进入ol中的，点亮盒子，移动ul;(案例1)\n            //需求3: 鼠标点击右侧按钮，点亮盒子，移动ul;(案例2和无缝滚动原理)\n            //需求4: 左侧按钮(类比右侧按钮逻辑)\n            //需求5: 定时器的添加;(类比右侧按钮逻辑)\n\n\n            //获取相关元素\n            var outer = document.getElementById(\"all\");\n            var screen = document.getElementById(\"screen\");\n            var imgWidth = screen.offsetWidth;\n            var ul = document.getElementById(\"ul\");\n            var ulLiArr = ul.children;\n            var ol = document.getElementById(\"ol\");\n            var arr = document.getElementById(\"arr\");\n            var left = document.getElementById(\"left\");\n            var right = document.getElementById(\"right\");\n\n            //需求1: 生成很多li添加到ol中，把第一张点亮，复制第一张图片添加到ul的最末尾;\n            for(var i=0;i<ulLiArr.length;i++){\n                var newLi = document.createElement(\"li\");\n                newLi.innerHTML = i+1;\n                ol.appendChild(newLi);\n            }\n            //把ol中的第一个li点亮\n            var olLiArr = ol.children;\n            olLiArr[0].className = \"current\";\n            //复制ul中的第一个li添加到ul的最末尾;\n            var li = ulLiArr[0].cloneNode(true);\n            ul.appendChild(li);\n\n\n            //需求2: 鼠标进入ol中的，点亮盒子，移动ul;(案例1)\n            for(var i=0;i<olLiArr.length;i++){\n                //自定义属性绑定索引值\n                olLiArr[i].index = i;\n                olLiArr[i].onmouseover = function () {\n//                    alert(this.innerHTML-1);\n                    //1.点亮盒子   2.移动ul;\n\n                    //bug: 鼠标进入没有同步square和key的值;\n                    square = key = this.index;\n\n                    //1.点亮盒子(排他思想)\n                    for(var j=0;j<olLiArr.length;j++){\n                        olLiArr[j].className = \"\";\n                    }\n                    this.className = \"current\";\n                    //2.移动ul\n                    var sss = imgWidth*this.index;\n                    animate(ul,-sss);\n                }\n            }\n\n\n            //需求3: 鼠标点击右侧按钮，点亮盒子，移动ul;(案例2和无缝滚动原理)\n\n            //自定义变量代替索引值要定义两个：因为图片和小方块的个数不一样；\n            var square = 0;//小方块的索引值\n            var key = 0;//图片的索引值\n            //绑定事件\n            right.onclick = autoPlay;\n\n\n            //需求4: 左侧按钮(类比右侧按钮逻辑)\n                //左侧按钮和右侧按钮逻辑相反\n            left.onclick = function () {\n                //索引值自减\n                square--;\n                key--;\n                //不能让square和key无限制自减;\n                //square最小值为0; 等于-1要把他设置为4(最后一个);\n                if(square === -1){\n                    square = olLiArr.length-1;//最大索引值\n                }\n                //key最小值为0；等于-1要把ul瞬间闪动到最后一张(索引值为5)，然后滑动到第五张;\n                if(key === -1){\n                    //瞬间闪动到最后一张\n                    ul.style.left = -imgWidth*(ulLiArr.length-1)+\"px\";\n                    key = ulLiArr.length-2;//滑向倒数第二张;索引值为4;\n                }\n\n                //点亮盒子，移动ul\n                for(var j=0;j<olLiArr.length;j++){\n                    olLiArr[j].className = \"\";\n                }\n                olLiArr[square].className = \"current\";//指定索引值的小方块变亮;\n                //移动ul\n                var sss = imgWidth*key;//图片的索引值;\n                animate(ul,-sss);\n            }\n\n            //需求5: 定时器的添加;(类比右侧按钮逻辑)\n                //定时器逻辑和右侧按钮相同，那么封装起来;\n            var timer = setInterval(autoPlay,1000);\n            //鼠标进入停止定时器，移开开启定时器;\n            //鼠标进入显示移开要隐藏;\n            outer.onmouseover = function () {\n                arr.style.display = \"block\";\n                //停止定时器\n                clearInterval(timer);\n            }\n            outer.onmouseout = function () {\n                arr.style.display = \"none\";\n                //开启定时器\n                timer = setInterval(autoPlay,1000);\n            }\n            //右侧按钮逻辑的封装\n            function autoPlay() {\n                //点击右侧按钮，索引值自增;\n                square++;\n                key++;\n                //key和square不能无限制自增;\n                //square到5的时候就要清0了;\n                if(square === olLiArr.length){\n                    square = 0;\n                }\n                //无缝滚动原理:第二轮从第一张滑向第二张的时候，瞬间闪动到第一张，在滑向第二张;\n                //key的值最多到5，因为只有6张图片;等于6的时候瞬间闪动到第一张，在从第一张滑向第二张;\n                if(key === ulLiArr.length){\n                    //瞬间闪动到第一张：\n                    ul.style.left = 0;\n                    //滑向第二张;\n                    key = 1;//第二张索引值为1;(下面点亮盒子，移动ul)\n                }\n\n                //1.点亮盒子   2.移动ul;\n                for(var j=0;j<olLiArr.length;j++){\n                    olLiArr[j].className = \"\";\n                }\n                //当前的变化不能用this，要用square做索引值；\n                olLiArr[square].className = \"current\";\n\n                // 2.移动ul;\n                var sss = imgWidth*key;//图片的索引值是key；\n                animate(ul,-sss);\n            }\n        }\n        //匀速动画封装\n        function animate(ele,target) {\n            //要用定时器，先清除定时器;\n            clearInterval(ele.timer);\n            //设置定时器;\n            ele.timer = setInterval(function () {\n                //1.获取步长;\n                var step = target > ele.offsetLeft? 10: -10;\n                //2.赋值\n                ele.style.left = ele.offsetLeft + step + \"px\";\n                //3.目标位置和当前位置不足或者等于一个步长就清除定时器i;\n                if(Math.abs(target-ele.offsetLeft) <= Math.abs(step)){\n                    //清除定时器之前，直接设置目标位置\n                    ele.style.left = target+\"px\";\n                    clearInterval(ele.timer);\n                }\n            },10);\n        }\n    </script>\n</head>\n<body>\n    <div class=\"all\" id='all'>\n        <div class=\"screen\" id=\"screen\">\n            <ul id=\"ul\">\n                <li><img src=\"images/1.jpg\" width=\"500\" height=\"200\"/></li>\n                <li><img src=\"images/2.jpg\" width=\"500\" height=\"200\"/></li>\n                <li><img src=\"images/3.jpg\" width=\"500\" height=\"200\"/></li>\n                <li><img src=\"images/4.jpg\" width=\"500\" height=\"200\"/></li>\n                <li><img src=\"images/5.jpg\" width=\"500\" height=\"200\"/></li>\n            </ul>\n            <ol id=\"ol\">\n\n            </ol>\n            <div id=\"arr\">\n                <span id=\"left\"><</span>\n                <span id=\"right\">></span>\n            </div>\n        </div>\n    </div>\n</body>\n</html>\n```","tags":["JS"]},{"title":"27-动画运动","url":"%2F2017%2F03%2F09%2FJS%2F27-%E5%8A%A8%E7%94%BB%E8%BF%90%E5%8A%A8%2F","content":"\n# 动画制作\n\n## 匀速运动\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n\n    <style lang=\"\">\n        *{\n            margin: 0px;\n            padding: 0px;\n        }\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: aqua;\n            position: absolute;\n        }\n    </style>\n\n</head>\n<body>\n    <button id=\"btn\">按钮</button> \n    <div id=\"box\"></div>\n\n    <script>\n        var btn = document.getElementById('btn');\n        var box = document.getElementById('box');\n        var timer = null;\n        //元素的运动设置方式(匀速运动效果)\n        btn.onclick = function(){\n            timer = setInterval(function(){\n                //获取元素当前位置\n                var current = box.offsetLeft;\n                //设置步长\n                var step = 10;\n                //设置运动条件.如果不满足条件 结束运动\n                if(current < 400){\n                    //套用运动公式：元素的位置(新) = 元素的位置(旧)+步长\n                    current = current + step;\n                    //将新位置设置给left属性\n                    box.style.left = current + 'px';\n                }else{\n                    //设置定时器的清除操作\n                    clearInterval(timer);\n                }\n            },20);\n        }\n    </script>\n\n</body>\n</html>\n```\n\n## 变速运动\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n\n    <style lang=\"\">\n        div {\n            margin: 0px;\n            padding: 0px;\n            width: 200px;\n            height: 200px;\n            background-color: aqua;\n            position: absolute;\n            top: 50px;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"box\"></div>\n    <button id=\"btn\">按钮</button>\n    <script>\n        var box = document.getElementById('box');\n        var btn = document.getElementById('btn');\n        var timer = null;\n        //元素的运动设置方式(变速运动效果)\n        btn.onclick = function(){\n            //清除旧的定时器，防止加问题\n            clearInterval(timer);\n            //开始新的定时器\n            timer = setInterval(function(){\n                //获取元素当前位置\n                var current = box.offsetLeft;\n                //设置运动步长：(目标位置 - 当前位置)/10\n                var step = (800 - current) / 10;\n                //可以对step进行取整\n                step = Math.ceil(step);\n                //套用公式：元素位置(新) = 元素的位置(旧) + 步长\n                current = current + step;\n                //将新位置给left属性\n                box.style.left = current + 'px';\n                //清除定时器\n                if(current === 400){\n                    clearInterval(timer);\n                }\n            },20)\n        }\n    </script>\n\n</body>\n</html>\n```\n\n","tags":["JS"]},{"title":"26-定时器","url":"%2F2017%2F03%2F08%2FJS%2F26-%E5%AE%9A%E6%97%B6%E5%99%A8%2F","content":"\n# 定时器\n\n## 延时定时器 timeout\n\n> 延时定时器可以让代码延迟一段时间之后才执行（定时炸弹）\n\n### 设置延时定时器\n\n```javascript\n    //语法：setTimeout(callback, time);\n    //参数1：回调函数，时间到了就会执行。\n    //参数2：延时的时间，毫秒形式\n    //返回：定时器的id，用于清除\n    //示例：\n    var timer = setTimeout(function(){\n        //1秒后将执行的代码。\n    }, 1000);\n```\n\n### 清除延时定时器\n\n```javascript\n    //语法：clearTimeout(timerId)\n    //参数：定时器id\n    //示例：\n    clearTimeout(timer);//清除上面定义的定时器\n```\n```javascript\n        <body>\n            <button id=\"btn\">停止</button>\n            <script>\n                var btn = document.getElementById('btn');\n                // timeout定时器的设置方式：\n                var timer = null;\n                timer = setTimeout(function () {\n                    console.log('代码执行啦');\n                }, 3000);\n\n                btn.onclick = function () {\n                    clearTimeout(timer);\n                };\n            </script>\n        </body>\n```\n\n## 间歇定时器 interval\n\n> 间歇定时器让定时器每隔一段时间就会执行一次，并且会一直执行，直到清除定时器为止.\n\n### 设置间歇定时器\n\n```javascript\n    //语法：var intervalID = setInterval(func, delay);\n    //参数1：重复执行的函数\n    //参数2：每次间隔的毫秒数\n    //返回：定时器的id，用于清除\n    //示例：\n    var timer = setInterval(function(){\n        //重复执行的代码。\n    }, 1000);\n\n```\n### 清除间歇定时器 \n\n```javascript\n    //语法：clearInterval(intervalID)\n    //参数：定时器id\n    //示例：\n    clearInterval(timer);//清除上面定义的定时器\n```\n```javascript\n    <body>\n        <button id=\"btn\">按钮</button>\n        <script>\n            var btn = document.getElementById('btn');\n\n            var timer = null;\n            timer = setInterval(function () {\n                console.log('我执行啦');\n            }, 1000);\n\n            btn.onclick = function () {\n                clearInterval(timer);\n\n                // 特殊点：\n                //  两种清除方式可以交换使用，没有必要，必须对应使用。\n                // clearTimeout(timer);\n            };\n        </script>\n    </body>\n```    \n","tags":["JS"]},{"title":"25-异步任务","url":"%2F2017%2F03%2F07%2FJS%2F25-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%2F","content":"\n# 异步任务\n\n- 以前说js的代码是按顺序从上向下执行的，但并不是所有的代码均会遵循这个规则。\n\n ## 同步任务（排队）：\n 以前我们任务的会从上向下执行的任务\n\n- 异步任务：js中有的功能执行较为耗时，或执行时间不确定，这种情况将功能设置为异步任务(常见的异步任务：定时器,事件)\n\n- 所有的异步任务执行均晚于同步任务，需要等待具体的执行时机(定时器事件到了，事件就被触发了)\n```javascript\n        console.log('这是页面中第一句代码');\n                setTimeout(function () {\n        console.log('这是定时器内打印的内容2');\n                }, 2000);\n        setTimeout(function () {\n                    console.log('这是定时器内打印的内容1');\n                }, 1000);\n        console.log('这是定时器后打印的内容');\n```\n```javascript\n             for(var i = 0; i < 10; i++){\n                 setTimeout (function (){\n                     console.log(i);\n                 },0);\n             }\n             console.log(i);\n             console.log(i);\n             console.log(i);\n```","tags":["JS"]},{"title":"24-offset系列","url":"%2F2017%2F03%2F07%2FJS%2F24-offset%E7%B3%BB%E5%88%97%2F","content":"\n# offset系列\n- 三大系列都是DOM元素的一些属性;\n\n- scrollWidth/Heiht/Top/Left\n- offsetWidth/Heiht/Top/Left/Parent\n- clientWidth/Heiht/Top/Left/clientX/clientY\n\n    - width/height: 代指检测盒子的宽高;（padding+border+width/height,内容超出）\n    - top/left: 调用者不同功能不同;\n\n## offset系列：都是DOM对象的一些属性\n\n```javascript\n        //offset系列：都是DOM对象的一些属性;\n        var div = document.getElementsByTagName(\"div\")[0];\n        //console.dir(div);\n\n        //offsetWidth/Height = width/height+padding+border;\n        //不会受到margin和内容影响\n\n        console.log(div.offsetWidth);//数字类型;\n        console.log(typeof div.offsetHeight);//数字类型;\n\n```\n\n- 总结：\n  - 如果一个盒子没有padding和border我们就可以用offsetWidth/Height\n                //获取盒子非行内式的宽高;\n\n### offsetTop/Left\n\n    - offsetTop/Left: 1.如果父系盒子有定位，那么就是距离最近的父系盒子带有定位的距离;\n    - offsetTop/Left: 2.如果父系盒子都没有定位，那么以浏览器为准(不是body);\n```javascript\n        //获取元素\n        var box3 = document.getElementsByClassName(\"box3\")[0];\n\n        //console.log(box3.offsetTop);//都没有定位130，以浏览器为基准;\n        //console.log(box3.offsetLeft);//都没有定位130，以浏览器为基准;\n\n        console.log(box3.offsetTop);//都没有定位130，以浏览器为基准;\n        console.log(box3.offsetLeft);//都没有定位130，以浏览器为基准;\n```\n\n- 总结:\n    - 1.获取盒子在父盒子中的位置;(自绝父相情况下获取top/left值)\n    - 2.获取盒子在整个页面的坐标;\n\n### offsetParent\n\n- offsetParent: 1.(有定位)获取距离最近的父系盒子中带有定位的盒子;\n- offsetParent: 2.(无定位)获取body;\n\n- 总结：我们宁可使用\nparentNode;（他找直接父节点）\n\n        \n## style.left和offsetLeft的区别\n\n- 一、最大区别在于offsetLeft可以返回没有定位盒子的距离左侧的位置。而style.left不可以\n```javascript\n        console.log(box3.offsetLeft);//130;数字\n        console.log(box3.style.left);// \"\"\n```\n- 二、offsetleft 返回的是数字，而 style.left 返回的是字符串，除了数字外还带有单位：px。\n```javascript\n        console.log(box3.offsetLeft);//   111\n        console.log(box3.style.left);//   \"111px\"\n```\n\n- 三、offsetleft 只读，而 style.left 可读写。（只读是获取值，可写是赋值）\n```javascript\n        box3.offsetLeft = \"222px\";//只读\n        box3.style.left = \"222px\";//可写\n```\n\n-  四、如果没有给 HTML 元素指定过 left 样式，则style.left 返回的是空字符串。\n\n\n- 总结;\n    - 1.获取值offset;(没有定位都可以获取，获取的是数字)\n","tags":["JS"]},{"title":"23-location与navigator与history对象","url":"%2F2017%2F03%2F06%2FJS%2F23-location%E4%B8%8Enavigator%E4%B8%8Ehistory%E5%AF%B9%E8%B1%A1%2F","content":"\n# location对象\n\n> location对象也是window的一个属性，本身也是一个对象\n>\n> location其实对应的就是浏览器中的地址栏。\n\n## 常用属性和方法\n\n### location.href:控制地址栏中的地址\n\n```javascript\n    location.href = 'http://www.baidu.com';//让页面跳转到百度首页\n```\n### location.assign:跳转\n\n```javascript\n    location.assign('index.html');\n```\n\n### location replace() 跳转，替换当前页面\n\n> assign:跳转\n\n```javascript\n    location.replace('index.html');\n```\n\n### location.reload()：让页面重新加载\n\n```javascript\n    location.reload(true);//true表示强制刷新，相当于ctrl+F5，\n    location.reload(false);//false表示普通刷新，相当于F5\n```\n\n### location的其他属性\n\n```javascript\n    console.log(window.location.hash);//哈希值 其实就是锚点\n    console.log(window.location.host);//服务器 服务器名+端口号\n    console.log(window.location.hostname);//服务器名\n    console.log(window.location.pathname);//路径名\n    console.log(window.location.port);//端口\n    console.log(window.location.protocol);//协议\n    console.log(window.location.search);//参数\n```\n\n## navigator对象\n\n> window.navigator的一些属性可以获取客户端的一些信息\n\nnavigator对象也是window的属性\n\n```javascript\n    navigator.userAgent;   // 用户代理字符串：浏览器版本\n\n            console.log(navigator.platform);\n            console.log(navigator.userAgent); // 用户代理字符串\n\n```\n\n> history 对象\n```javascript\n    \t//后退：\n        history.back();\n        history.go(-1);\n        //前进：\n        history.forward();\n        history.go(1);\n```\n\n","tags":["JS"]},{"title":"22-BOM","url":"%2F2017%2F03%2F02%2FJS%2F22-BOM.window%E5%AF%B9%E8%B1%A1%2F","content":"\n# BOM\n\n> BOM（Browser Object Model）：浏览器对象模型，提供了一套操作浏览器功能的工具。\n\nBOM包含的内容很多，但是很多东西都不太常用，在BOM中需要大家掌握的就一个东西，那就是定时器 。\n\n## window对象\n\n- window对象的基本介绍\n    - window对象是js在浏览器环境中的顶级对象\n\t- window对象中的功能有很多，根据功能划分为多个对象，而这些对象也是window的属性\n\n\n1. window对象是一个全局对象，也可以说是JavaScript在浏览器环境中的顶级对象\n\n2. 像document、alert()、console这些都是window的属性，其实BOM中基本所有的属性和方法都是属性window的。\n\n3. 所有定义在全局作用域中的变量、函数、都是window对象的属性和方法\n\n4. window对象下的属性和方法调用的时候可以省略window\n\n## window.onload\n\n> window.onload事件会在窗体加载完成后执行，通常我们称之为入口函数。\n```javascript\n    window.onload = function(){\n        //里面的代码会在页面加载完成后执行。\n        //页面加载完成包括结构的加载、还有图片、文件的加载完成。\n    }\n```\n如果有图片加载，那么代码一定要写到window.onload里面，否则会出现图片没有加载完成，获取到的宽度和高度不对的情况。\n\n浏览器会对页面的加载做优化，在加载图片的时候，图片的引入会延迟。\n\n## window.open与window.close\n\n> window.open() 打开一个窗口\n\n```javascript\n    //语法：window.open(url, [name], [features]);\n    //参数1：需要载入的url地址\n    //参数2：新窗口的名称\n        //_self:在当前窗口打开\n        //_blank:在新的窗口打开\n    //参数3：窗口的属性，指定窗口的大小\n    //返回值：会返回刚刚创建的那个窗口，用于关闭\n    //示例：\n    var newWin = window.open(\"http://www.baidu.com\",\"_blank\", \"width=300,height=300\");\n```\n> window.close() 关闭窗口\n```javascript\n    newWin.close()；//newWin是刚刚创建的那个窗口\n    window.close();//把当前窗口给关闭了\n```\n\n","tags":["JS"]},{"title":"21-事件流","url":"%2F2017%2F03%2F01%2FJS%2F21-%E4%BA%8B%E4%BB%B6%E6%B5%81%2F","content":"\n# 事件流\n\n## 事件冒泡\n\n当一个元素的事件被触发时，同样的 **事件将会在该元素的所有祖先元素中依次被触发**。这一过程被称为 **事件冒泡**。\n\n### 传递的顺序为由内向外。\n\n  - 1.事件冒泡是默认的事件传递方式  \n  - 2.执行顺序\n\n\n- 说白了就是：当我们触发了子元素的某个事件后，父元素对应的事件也会触发。\n\n通常情况，**事件冒泡**对于我们来说是没有问题的，我们直接不管就行了，但是如果当事件冒泡给我们带来影响的时候，我们需要阻止事件冒泡。\n\n### 阻止事件冒泡\n\n- **阻止事件冒泡**有浏览器兼容性问题\n\n- 正常浏览器\n\n```javascript\n        link.onclick = function (event) {\n        \tevent = event || window.event;\n        \t//stop :停止  propagation：传播\n        \tevent.stopPropagation();\n    }\n```\n\n\n\n### 阻止事件传播\n\n> **stopPropagation()**\n\n```javascript\n\t\tbox.onclick = function(){\n                console.log('box');\n            };\n            text.onclick = function(){\n                e.stopPropagation();\n                console.log('text');\n            };\n        };\t\n```\n\n## 取消标签的默认事件效果\n\n### 方式有两种:\n\n- return false;\n- e.preventDefault()\n\n推荐使用return false;\n\n```javascript\n        var link = document.getElementById('link');\n        link.onclick = function(e){\n            console.log('这是a标签的事件');\n            //取消标签的默认事件效果方式有两种，推荐使用return false;\n            //return false;\n            e.preventDefault()\n        }\n```\n\n\n\n## 事件捕获\n\n**事件捕获**是火狐浏览器提出来的，IE678不支持事件捕获（基本上，我们都是用事件冒泡）\n\n事件的处理将从DOM层次的根开始，而不是从触发事件的目标元素开始，**事件被从目标元素的所有祖先元素依次往下传递** 。这种事件的传递方式称为事件捕获。\n\n```javascript\n        //当addEventListener第三个参数为true时，表示事件捕获\n        arr[i].addEventListener(\"click\", function () {\n            console.log(this);\n        },true);\n```\n\n- 由于事件捕获不是默认的方式，需要采addEventListener进行设置\n- 使用参数3 表示事件采用事件冒泡或事件捕获的形式执行\n- true 表示捕获，false表示事件冒泡，默认为false\n\n**事件捕获的执行顺序：**\n\n- 与事件冒泡相反,由内向外。\n\n\n\n## 事件的三个阶段\n\n- js中进行事件执行监听的‘人’只有一个，这个人是js中的事件机制\n\n\n- 任意的元素触发事件后都会经历3个阶段.依次为\n\n\n- 我们设置的事件冒泡或事件捕获只是决定了某个事件在哪个阶段会被执行\n  - 事件的捕获阶段   （人过来了）\n  - 事件的目标阶段   （触发自己的事件）\n    - 当前目标阶段  (人在做事情)\n  - 事件的冒泡阶段 (人走了)\n\n事件有三个阶段，首先发生的是捕获阶段，然后是目标阶段，最后才是冒泡阶段，对于捕获和冒泡，我们只能干预其中的一个，通常来说，我们可能会干预事件冒泡阶段，而不去干预事件捕获阶段。\n\n```javascript\n//true表示事件捕获， false表示事件冒泡，默认为false\nbox1.addEventListener('click',function(){\n            console.log('box1');\n        },true);\n        \n        box2.addEventListener('click',function(){\n            console.log('box2');\n        },true);\n        \n        box3.addEventListener('click',function(){\n            console.log('box3');\n        },true);\n```\n\n## 事件委托\n\n​**概念：** 将内部元素的事件设置给父级元素(将内部元素的事件委托给父级元素设置)\n\n- **作用：**\n  -  1.可以减少事件的设置个数，对内部元素的事件进行统一管理\n  -  2.可以解决动态创建的元素没有事件的问题\n\n\n## 常见的事件\n\n- 常见的鼠标事件\n\n        onmousedown: 鼠标按下事件\n\n        onmouseup:   鼠标弹起事件\n\n        onclick:     单击事件\n\n        ondblclick： 双击事件\n\n        onmouseover：鼠标经过事件\n\n        onmouseout： 鼠标离开事件\n\n        onmousemove：鼠标移动事件\n\n        onfocus：    鼠标获得焦点事件\n\n        onblur：     鼠标失去焦点事件\n\n- 常见的键盘事件\n\n        onkeydown:   键盘按下时触发\n\n        onkeyup:     键盘弹起时触发\n\n对于鼠标事件，事件对象中有一系列的XY记录了鼠标的位置信息。而键盘事件中，事件对象有一个event.keyCode属性，记录了按下去的键的键盘码。\n\n# 事件对象\n\n## 事件对象的概述\n\n> 在触发某个事件的时候，都会产生一个事件对象Event，这个对象中包含所有与事件相关的一些信息，包括触发事件的元素，事件的类型以及其他与事件相关的信息。\n\n当我们进行事件触发后，某些特殊的信息是我们自己无法得到的（坐标等信息...）\n\njs的事件会给我们提供这些信息，我们只需要利用某些方式得到后进行使用即可。\n\n由于得到的数据是一组值，为对象结果，所以也称为**事件对象。**\n\n- 鼠标事件触发时，事件对象中会包含鼠标的位置信息。\n\n- 键盘事件触发时，事件对象中会包含按下的键相关的信息。\n\n  ​\n\n>       每一个事件在触发时，都会产生一个事件对象。\n>\n>       你见或者不见，我就在那里，不悲不喜。\n>\n>       你爱或者不爱，爱就在那里，不增不减。\n>\n>       你用或者不用，我都会给你，不离不弃。 \n\n\n\n- 接收的方式：\n  - 1.在事件处理程序的形参位置接收一个参数，这种方式ie9以下不支持\n  - 2.在ie以下可以使用一个window.event对象进行操作\n\n\n## 获取事件对象\n\n> 既然事件对象中存储了这么多的信息，我们首先需要做的就是获取到这个事件对象。获取事件对象的时候，存在浏览器的兼容问题。\n\n\n\n对于现代浏览器，获取事件对象非常的简单，只需要在注册事件的时候，指定一个形参即可。这个形参就是我们想要获取到的事件对象。\n\n```javascript\n        btn.onclick = function(event){\n            //event就是事件对象，里面包含了事件触发时的一些信息。\n            console.log(event);\n        }\n```\n\n- 对于IE678来说，获取事件对象则是另一种方式，在事件里面，通过window.event来获取事件对象\n\n```javascript\n        btn.onclick = function(){\n            //IE678通过window.event获取事件对象\n            var event = window.event;\n            console.log(event);\n        }\n```\n- 兼容性封装\n```javascript\n            btn.onclick = function(event){\n            //只要用到了事件对象，就要记得处理浏览器兼容性\n            event = event || window.event;\n        }\n\n```\n\n\n## 事件对象的常用属性\n\n\n事件对象中有很多很多的属性，但是很多属性并不常用。我们经常用到的是**鼠标位置信息**和**键盘码**相关的信息。\n\n\n - 记录了鼠标位置信息的相关属性\n```javascript\n\nclientX与clientY：光标相对于可视区左上角的水平位置和垂直位置。\n\n<script>\n        var box = document.getElementById('box');\n        //在页面任意位置点击鼠标时，获取鼠标坐标，将元素box移动到点击位置\n        //mousemove   鼠标移动时触发事件\n        document.onmousemove = function(e){\n            //clientX   针对页面可视区域的横坐标\n            //clientY   针对页面可视区域的纵坐标\n            console.log(e.clientX,e.clientY);\n            box.style.left = e.clientX + 'px';\n            box.style.top = e.clientY + 'px';\n        }\n</script>\n```\n\n- 记录了键盘码的属性\n\n```javascript\nevent.keyCode:键盘按下的那个键的键盘码\n```\n\n## 放大镜效果（练习）\n\n放大镜在开发中是一个很常见的特效，但是所有的放大镜的实现效果都是一样\n\nmousemove事件：鼠标移动时会触发这个事件。\n```javascript\n        document.onmousemove = function(){\n            console.log(\"鼠标移动事件在触发\");  \n        };\n```\n- 获取鼠标在盒子中的位置：\n```javascript\n        var spaceX = getPage(event).x - box.offsetLeft;\n        var spaceY = getPage(event).y - box.offsetTop;\n```","tags":["JS"]},{"title":"20-注册事件","url":"%2F2017%2F03%2F01%2FJS%2F20-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%2F","content":"\n# 注册事件的两种方式\n\n## on+事件名称\n\n  onclick、onmouseover这种on+事件名称的方式注册事件几乎所有的浏览器都支持。\n\n- 注册事件：\n\n```javascript\n        box.onclick = function(){\n            //事件处理程序\t\n        }\n```\n- 移除事件：\n\n```javascript\n        box.onclick = null;\t\n```\non+事件名称注册事件的缺点：\n\n同一个元素同一类型的事件，只能注册一个，如果注册了多个，会出现覆盖问题。\n\n```javascript\n<body>\n      <button id=\"btn\">按钮</button>\n      <script>\n          var btn = document.getElementById('btn');\n//使用普通方式设置的事件会出现覆盖的问题\n          btn.onclick = function(){\n              console.log('这是第一个事件代码');\n          };//这段就会被第二个覆盖掉\n          btn.onclick = function(){\n              console.log('这是第二个事件代码');\n          };\n\n\n\n//普通事件的移除方式；\n        btn.onclick = function(){\n            console.log('这是第一个事件代码');\n        }\n        btn.onclick = null;\n\n      </script>\n</body>\n```\n\n\n\n## 注册事件的新方式\n\n- **addEventListener与-removeEventListener**\n      现代浏览器支持的注册事件的新方式，这种方式注册的事件不会出现覆盖问题。\n\n- addEventListener的语法\n\n```javascript\n\t设置方式：\n元素.addEventListener() 添加事件监听\n参数：\n\t1.事件类型名称，字符串形式  不加on\n\t2.事件处理程序，函数\n特点：多次进行设置操作，不会出现覆盖的问题\n\n        btn.addEventListener('click',function(){\n            console.log('这是点击事件1');\n        });\n        var  fun = function(){\n            console.log('这是点击事件2');\n        }\n        btn.addEventListener('click',fun);\n```\n注意：如果想要让你注册的事件能够移除，不能使用匿名函数。\n\n```javascript\n移除事件操作：\n元素.removeEventListener();\n移除时必须与设置时的参数完全一样(事件处理程序必须设置为命名形式)\n        btn.removeEventListener('click',fun);\n        //如果想让注册的事件能移除，不能用匿名函数。\n        box.addEventListener(\"click\", fn1, false);\n```\n\n- removeEventListen的语法\n\n```javascript\n        //第一个参数：事件类型\n        //第二个参数：事件处理程序\n        //第三个参数：false\n        removeEventListener(type, fun, useCapture);\n```\n## attachEvent与detachEvent\n\n  - IE678不支持addEventListener与removeEventListen两个方法，但是支持attachEvent与detachEvent  \n\n    - ie中提供了一组方法用于进行事件操作\n\n    - 下面这种方法虽然是ie提出的，但是ie的新版本11已经不支持了。\n\n```javascript\n        var btn = document.getElementById('btn');\n        //addEventListentById组功能在ie9以下不支持\n        //ie中提供了一组方法用于进行事件操作\n        //下面这种方法虽然是ie提出的，但是ie的新版本11已经不支持了。（只有ie浏览器11  以下才生效）\n\n\n\t\t// 这组方法仅仅作为了解即可。\n\t\t// 1 添加事件\n\t\tbtn.attachEvent('onclick', function () {\n\t\t\tconsole.log('这是第一个点击事件');\n\t\t});\n\t\tvar fun = function () {\n\t\t\tconsole.log('这是第二个点击事件');\n\t\t};\n\t\tbtn.attachEvent('onclick', fun);\n\n\t\t// 2 移除事件：必须保证参数完全相同\n\t\tbtn.detachEvent('onclick', fun);\n    \n```\n\n\n\n### attachEvent的用法：\n\n```javascript\n        //type:事件类型   需要加上on   onclick  onmouseenter\n        //fun:事件处理程序\n        attachEvent(type, fun)\n```\n\n### detachEvent的用法\n\n```javascript\n        //type:事件类型   需要加上on   onclick  onmouseenter\n        //fun:事件处理程序\n        detachEvent(type, fun)\n```\n\n\n","tags":["JS"]},{"title":"19-节点","url":"%2F2017%2F03%2F01%2FJS%2F19-%E8%8A%82%E7%82%B9%2F","content":"\n# 节点\n\n## 节点的概念\n\n- 页面创建后，DOM会根据HTML文档结构生成文档树（又称节点树），HTML文档中的每个标签、文本、属性均为 ‘树’ 中的一个部分，这些组成部分称为 **节点**。\n\n- 节点根据形式不同，又有不同的分类，例如标签称为**元素节点**，文本称为**文本节点**，等等。\n\n- 节点树的根据 ‘树’ 中不同节点之间的关系，给我们提供了一套访问方式，用于**方便对页面内容的操作**。\n\n## 节点的属性\n\n- 节点分类：\n    - 常见节点：元素节点、文本节点、属性节点   注释节点（不常用）\n\n\n- 节点常用的属性\n  - nodeType:  节点类型，数值形式\n  - 1 代表元素节点 （常用）\n  - 2 代表属性节点\n  - 3 代表文本节点\n\n\n- nodeName: 节点名称\n  - 元素节点的nodeName为标签名\n\n- nodeValue: 节点值\n  - 元素节点的nodeValue为null\n\n```javascript\n\t节点的三个属性\n\t// 标签：页面元素，元素节点\n\tvar box = document.getElementById('box');\n\t// 节点的属性：\n\t// 1 nodeType，用于检测节点的类型\n\tconsole.log(box.nodeType);\n\n\t// 2 nodeName，对于元素节点来说结果是大写的标签名称\n\tconsole.log(box.nodeName); // 'DIV'\n\n\t// 3 nodeValue，对于元素节点来说，nodeValue为null\n\tconsole.log(box.nodeValue);\n```\n\n    ​\n\n## 节点访问关系\n\n节点访问关系一共分两类：上下级关系(父子关系)和同级关系(兄弟关系)。\n\n### 父节点\n\n```javascript\n        node.parentNode // 父节点\n```\n\n### 子节点\n\n```javascript\n        childNodes         // 获取所有的子节点，伪数组\n        children           // 获取所有的子元素，伪数组（最常用）\n        firstChild         // 第一个子节点\n        firstElementChild  // 第一个子元素节点 有兼容性问题\n        lastChild          // 最后一个子节点\n        lastElementChild   // 最后一个子元素节点 有兼容性问题\n```\n\n```javascript\n        var box = document.getElementById('box');\n        // 由于fa是box的父节点，可以使用parentNode属性访问\n        // console.log(box.parentNode);\n    \n        // childrenNodes 获取所有子节点 获取结果包含文本节点\n        // console.log(box.children);\n        \n        // children  非常常用，必须掌握\n        // children  获取所有子元素节点\n        console.log(box.children);\n\n        // firstChild  第一个子节点\n        // console.log(box.firstChild);\n\n        // lastChild 最后一个子节点\n        // console.log(box.lastChild);\n\n        // firstElementChild  第一个元素子节点   ie9以下不支持\n        // console.log(box.firstElementChild);\n        // console.log(box.children[0]);\n\n        // lastElementChild  最后一个元素子节点  ie9以下不支持\n        // console.log(box.lastElementChild);\n        console.log(box.children[box.children.length - 1]);\n\n```\n\n\n### 同级节点（兄弟节点）\n\n```javascript\n        //这四个属性均作为了解，因为他们都有一些问题。\n        nextSibling // 下一个同级节点\n        nextElementSibling // 下一个同级元素节点 有兼容性问题\n        previousSibling // 上一个同级节点\n        previousElementSibling // 上一个同级元素节点 有兼容性问题\n\n\n        var li = document.getElementById('li');\n        // nextSibling 下一个兄弟节点 会获取到文本节点\n        console.log(li.nextSibling);\n\n        // nextElementSibling下一个兄弟元素 ie9 以下不支持\n        console.log(li.nextElementSibling);\n\n        // previousSibling上一个同级节点 会获取到文本节点\n        console.log(li.previousSibling);\n\n        // previousElementSibling上一个同级元素节点 ie9 以下不支持\n        console.log(li.previousElementSibling);\n\n        //上面四个属性如果无法获取到对应节点，则返回null\n```\n\n\n### 移动节点\n\n#### appendChild 追加子节点\n\n    - 语法：parent.appendChild(newChild)\n        - parent： 父节点（要添加到的位置）\n        - newChild：新节点（要添加的节点）\n    - 作用：把newChild添加到parent中所有子节点的最后面。\n        - 如果添加的是页面中本来就存在的元素，是一个剪切的效果，原来的就不在了。\n\n```javascript\n        var demo = document.getElementById(\"demo\");\n        var box = document.getElementById(\"box\");\n        box.appendChild(demo);\n```\n\n#### insertBefore 插入子节点\n\n- 语法：parent.insertBefore(newChild, refChild);\n\n- 参数：\n    - parent：父节点（要添加到的位置）\n    - newChild：新节点（要添加的节点）\n    - refChild：参考节点（新节点添加到哪一个节点的前面）。\n\n```javascript\n        var ul = document.getElementById(\"list\");\n        var li = document.createElement(\"li\");\n        li.innerHTML = \"这是一个li\";\n        // 就是添加到子节点的最前面。\n        ul.insertBefore(li, ul.children[0]);\n```\n\n\n\n## 创建元素节点（3种方式）\n\n### document.write（基本不用）\n\n\n        可以生成新的节点，但是不推荐使用。\n\n**注意：如果在页面加载完毕后，使用document.write进行内容写入操作，会将之前的页面给覆盖掉**\n\n\n#### innerHTML\n\n- innerHTML也可以创建节点。\n\n- 使用innerHTML会出现的问题：\n\n  - 覆盖原内容。\n  - 效率问题。\n\n- console.time() 与 console.timeEnd() 的使用。\n```javascript\n        console.time();\n        代码段...\n        console.timeEnd();\n```\n\n\n#### document.createElement\n\n- 语法：document.createElement(tagName);\n  - 功能：创建一个元素节点\n  - 返回：元素节点（标签）\n  - 参数：要创建的标签的名称，字符串类型\n\n**注意：使用document.createElement创建的元素需要添加到页面中才会显示。**\n\n#### 删除节点\n\n  - 语法：parent.removeChild(child);\n  - 功能：有父盒子调用，删除里面的一个子元素。\n  - 参数：child 要移除的子节点\n\n\n#### 克隆节点\n\n  - 语法：node.cloneNode(deep)\n  - 功能：克隆一个节点\n  - 参数：deep\n\n- false：默认值，表示浅复制：只会复制节点本身，不会复制节点的内部内容。\n- true：深复制，会复制标签，以及标签内的所有内容 \n\n1. 克隆出来的节点跟原来的节点没有关系\n2. 不要给要克隆的节点设置id\n\n\n","tags":["JS"]},{"title":"18-表单属性与事件","url":"%2F2017%2F02%2F27%2FJS%2F18-%E8%A1%A8%E5%8D%95%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BA%8B%E4%BB%B6%2F","content":"\n# 表单属性与事件\n\n## 表单的常用属性\n\n- 内容操作\n```javascript\n        var text = document.getElementById('text'); // 输入框\n        var txt = document.getElementById('txt');   // 文本域\n        var opt = document.getElementById('opt');   // 下拉菜单选项\n        // 1 value 用于操作大部分表单元素的值\n        console.log(text.value);\t\t// 获取内容\n        text.value = '我是设置的新内容';  // 设置内容\n\n        // 2 特殊：文本域，可以使用value和innerHTML、innerText ，但是推荐value，比较统一\n        console.log(txt.value); \n        txt.value = '我是新的内容';\n        console.log(txt.innerHTML);\n        txt.innerHTML = '我是新的内容';\n\n        // 3 特殊：下拉菜单选项option，只能使用innerHTML、innerText进行内容设置，value不是用于内容设置\n        opt.value = '我是value的内容';\n        opt.innerHTML = '而我才是显示的内容';\n\n```\n\n## 复选框选中属性\n\n```javascript\n        var cb = document.getElementById('cb'); // 复选框\n        // checked 属性，用于进行复选框选中属性操作\n        // 设置为布尔类型，true表示选中，false表示取消选中\n        cb.checked = true;\n        // 注意：如果设置的值为非布尔值，会进行隐式转换，不常用，了解即可\n```\n\n## 下拉菜单选中属性\n\n```javascript\n        var opt = document.getElementById('opt'); // 下拉菜单选项\n        // selected 属性，用于进行选中属性操作\n        // 设置为布尔类型，true表示选中，false表示取消选中\n        opt.selected = true;\n        // 注意：如果设置的值为非布尔值，会进行隐式转换，不常用，了解即可\n```\n\n## 禁用属性\n\n```javascript\n        var ipt = document.getElementById('ipt'); // 复选框\n        // disabled 属性，用于进行禁用属性操作\n        // 设置为布尔类型，true表示禁用，false表示启用\n        ipt.disabled = true;\n        // 注意：如果设置的值为非布尔值，会进行隐式转换，不常用，了解即可\n```\n\n## 输入框常用事件\n\n```javascript\n        <input type=\"text\" id=\"ipt\" value=\"我是输入框的默认内容\">\n        <script>\n            var ipt = document.getElementById('ipt');\n            // 获取焦点事件 focus\n            ipt.onfocus = function () {\n                // 检测，如果内容为默认提示词，去除\n                if (this.value === '我是输入框的默认内容') {\n                    this.value = '';\n                }\n            };\n            // 失去焦点事件 blur\n            ipt.onblur = function () {\n                // 如果为空，还原为默认提示词\n                if (this.value === '') {\n                    this.value = '我是输入框的默认内容';\n                }\n            };\n        </script>\n```","tags":["JS"]},{"title":"17-兼容性问题","url":"%2F2017%2F02%2F27%2FJS%2F17-%E5%85%BC%E5%AE%B9%E6%80%A7%2F","content":"\n# 兼容性\n\n当一个属性(方法)不能被所有浏览器(5大浏览器)支持时，我们就称这个属性(方法)具有兼容性问题。\n- 兼容性问题在js中存在很多，大部分为历史遗留原因。我们的目标不是解决js中所有的兼容性问题，而是要清楚什么是兼容性问题，以及兼容性问题的解决方式(套路)即可。\n\n## innerText的兼容性问题\n\n    - innerText用于对元素进行文本内容操作，但他具有一些兼容性问题(见MDN - MDN有问题，innerText属性在ie中没有兼容性问题)。\n    - 与innerText对应的属性为textContent，textContent使用方式与innerText相同，但不支持ie678。\n    - 我们会发现现在我们有了两个功能相同的属性，虽然分别使用时不支持一部分浏览器，但组合在一起时可以涵盖所有浏览器。\n        - 这时我们就可以利用两者进行兼容性操作了。\n\n兼容性操作：谁能用，就用谁。\n```javascript\n        var getText = function (element) {\n        if (typeof element.innerText !== 'undefined') {\n            return element.innerText;\n        } else {\n            return element.textContent;\n        }\n        };\n```\n\n## 样式获取的兼容性问题\n\n- 以前我们使用过style方式可以直接对元素的样式进行操作，但只是设置。style方式其实也可以进行样式获取，但同样只能获取行内样式。\n\n```javascript\n        <style>\n        div {\n            width : 100px;\n        }\n        </style>\n        <div id=\"box\" style=\"height:100px;\">div的内容</div>\n        <script>\n        var box = document.getElementById('box');\n        console.log(box.style.width); // '' width没有设置为行内样式\n        console.log(box.style.height); // '100px' height设置为行内样式\n        \n        box.style.backgroundColor = 'red'; // 使用style方式设置的样式同样为行内样式，可以获取\n        console.log(box.style.backgroundColor); // 'red'\n        </script>\n```\n - 开发中，我们不可能将所有的样式均设置为行内样式。如果希望获取任意位置设置的样式，可以使用方法getComputedStyle()。\n\n - getComputedStyle()\n\n    - 功能：用于获取某个元素计算后(最终生效的)的样式\n    - 参数：要进行样式获取的元素(DOM对象)\n    - 返回值：所有样式的集合(对象，类似元素的style属性，需要再次访问某个样式名称)\n\n```javascript\n        <style>\n        div {\n            width : 100px;\n        }\n        </style>\n        <div id=\"box\" style=\"height:100px;\">div的内容</div>\n        <script>\n        var box = document.getElementById('box');\n        console.log(getComputedStyle(box).width); // '100px' \n        console.log(getComputedStyle(box).height); // '100px' \n        </script>\n```\n- 此方法虽然好用，但是ie9以下不支持(见MDN)，对应功能为一个属性currentStyle，使用方式与getComputedStyle()相同，同样可以进行兼容性操作：\n\n```javascript\n\n        var getStyle = function (element, styleName) {\n        if (element.currentStyle) {\n            return element.currentStyle[styleName];\n        } else {\n            return getComputedStyle(element)[styleName];\n        }\n        }\n```\n\n","tags":["JS"]},{"title":"16-事件","url":"%2F2017%2F02%2F27%2FJS%2F16-%E4%BA%8B%E4%BB%B6%2F","content":"\n# 事件\n- 事件的作用：让用户可以与网页进行交互操作（触发 - 响应 机制）\n\n## 事件三要素(三个组成部分)\n\n- 事件源：(被)触发事件的元素\n- 事件类型：例如 click 表示点击事件\n- 事件处理程序：事件触发后要执行的代码（函数形式\n\n## 事件的基本使用\n\n - 注意：在使用事件时需要在事件类型名称前加on，例如点击事件为onclick\n\n ```javascript\n        var box = document.getElementById('box');\n        box.onclick = function() {\n        console.log('代码会在box被点击后执行');  \n        };\n ```\n## 事件中的this使用\n\n- 观察以下示例代码\n```javascript\n        var btn = document.getElementById('btn');\n        btn.onclick = function () {\n        btn.innerText = '修改了btn的内容';\n        };\n```\n- 通过事件可以发现，事件实际上是方法形式，在方法中可以使用this代表调用者(btn)。\n    - 示例中，点击事件内部修改了btn的内容，而btn等同与this，所以可以使用this在事件中替代事件源。\n\n- 观察以下示例：\n```javascript\n          // 假定页面中有多个li，要求给每个li设置点击事件，点击后打印本li的内容\n          var lis = document.getElementsByTagName('li');\n          for (var i = 0; i < lis.length; i++) {\n          lis[i].onclick = function () {\n              console.log(lis[i].innerText); // 报错\n           };\n           }\n```\n- 以上写法中我们发现代码似乎是合理的，但却出现了报错，原因在于事件内i的取值有问题。\n    - 此时可以在事件内使用this来表示事件源，方便又好用。\n\n    - 小结：在循环添加事件时，事件中不能使用循环变量！全部使用this替代即可。\n\n\n## 取消标签默认事件\n\n许多标签具有默认的事件效果，例如a标签，默认点击后会进行跳转。如果不希望执行跳转，可以在自定义事件代码最后设置return false。\n```javascript\n        var link = document.getElementById('link');\n        link.onclick = function () {\n        console.log('这是要执行的代码');\n        return false; // 阻止a标签的跳转\n        };\n```\n\n## 移入mouseover移出mouseout事件\n\n- js中的事件类型有很多，除点击外，还有鼠标的移入mouseover和移出mouseout事件\n\n```javascript\n            var box = document.getElementById('box');\n            box.onmouseover = function () {\n            console.log('鼠标移入到box中了');\n            };\n            box.onmouseout = function () {\n            console.log('鼠标从box中移出了');\n            };\n```","tags":["JS"]},{"title":"15-Web API 简单介绍","url":"%2F2017%2F02%2F26%2FJS%2F15-Web%20API%E4%BB%8B%E7%BB%8D%2F","content":"\n# WebAPI\n\n## API的概念\n\n- API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。\n\n- **接口：**\n    - 生活中的接口，例如：\n        - 电源接口：提供电\n        - 网线接口：提供网络\n        - usb接口：提供设备连接功能\n\n\n- **总结：**\n    - 能够 提供某种能力 的事物，称为接口\n        - 任何开发语言都有自己的API\n        - API的特征输入和输出(I/O)\n        - API的使用方法(console.log( ))\n\n- **API：**\n\n    - 能够 提供编程能力（让编程更方便的能力） 的事物称为应用程序编程接口（API）\n    - API 实际上是 '环境' 预先提供 的一些 函数 (方法)\n\n\n## Web API的概念\n\n- 浏览器提供的一套**操作浏览器功能和页面元素(标签)**的方法(BOM和DOM)\n\n- 此处的Web API特指浏览器提供的API(一组方法)。\n\n    - [相关链接：MDN-Web API](https://developer.mozilla.org/zh-CN/docs/Web/API)\n\n    - [相关链接：MDN](https://developer.mozilla.org/zh-CN/)\n\n    - 例如：通过查询MDN学习document.getElementById()方法的使用\n    - [其他网站：相关链接:W3school](http://www.w3school.com.cn/)\n\n - **JavaScript的组成**\n    - ECAMScript\n    - DOM\n    - BOM\n\n- **ECMAScript - JavaScript的核心**\n\n    - 定义了javascript的语法规范\n\n    - JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关\n\n- BOM - 浏览器对象模型（Browser  Object  Model）\n\n    - 一套操作浏览器功能的API\n\n    - 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等\n\n- DOM - 文档对象模型（Document  Object  Model）\n\n    - 一套操作页面元素的API\n\n    - DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作\n\n## DOM的概念\n\n**DOM的概念**\n - **文档对象模型**（Document Object Model，简称DOM）.\n    用于对文档中的内容进行操作，为了方便操作，它会根据文档的内容层级自动生成 '树状模型结构'，所以DOM又被称为文档树模型.\n\n- 是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。\n    - Document Object Model的历史可以追溯至1990年代后期微软与Netscape的“浏览器大战”，双方为了在JavaScript与JScript一决生死，于是大规模的赋予浏览器强大的功能。微软在网页技术上加入了不少专属事物，既有VBScript、ActiveX、以及微软自家的DHTML格式等，使不少网页使用非微软平台及浏览器无法正常显示。DOM即是当时蕴酿出来的杰作。\n\n - **DOM又称为文档树模型**\n    - 文档：一个网页可以称为文档\n    - 节点：网页中的所有内容都是节点（标签、属性、文本、注释等）\n    - 元素：网页中的标签\n    - 属性：标签的属性\n\n## DOM经常进行的操作\n\n- **DOM经常进行的操作**\n\n    - **获取节点**\n    - **对元素进行操作(设置其属性或调用其方法)(属性操作，节点操作，访问关系)**\n    - **动态创建节点**\n    - **事件机制(什么时机做相应的操作)**\n\n## 获取页面元素\n\n- 为什么要获取页面元素?\n\n    - 例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，才进行后续操作.\n\n- 当我们想对页面元素设置效果时(例如：显示、隐藏等)，需要先获取到该部分对应的元素，才能进行后续操作。\n\n### 根据id获取元素getElementById\n\n> 基本用法\n```javascript\n\n        var div = document.getElementById('main');\n        console.log(div);\n\n        // 获取到的数据类型 HTMLDivElement，对象都是有类型的\n        // HTMLDivElement <-- HTMLElement <-- Element  <-- Node  <-- EventTarget\n        \n```\n### 根据id获取元素的特殊方式\n\n```javascript\n            // 由于浏览器的特殊实现方式，允许用户直接使用id名称访问元素，但是不是标准的方式，不推荐使用。\n\n            //.log在浏览器控制台打印出信息\n                console.log(box);\n            //.dir可以显示一个对象所有的属性和方法\n                console.dir(box);\n```\n- 详细说明：\n    - 参数：id名称，字符串类型。\n    - 返回值\n        - 当页面中不存在对应参数id对应的标签时，返回null。\n        - 当获取到对应的页面元素时，返回对应的DOM对象。\n\n- DOM对象：\n    - 我们发现，获取到页面元素后，结果是一种对象形式，这种形式的目的是为了方便使用API。\n    - **注意**：由于id名具有唯一性，部分浏览器支持直接使用id名访问元素，但不是标准方式，不推荐使用\n\n\n### 根据标签名获取元素getElementsByTagName\n\n   - 当我们希望同时操作页面中的多个页面元素时\n\n> 基本用法（2种）\n```javascript\n\n        // 获取页面中所有div：\n        var divs = document.getElementsByTagName('div');\n        for (var i = 0; i < divs.length; i++) {\n        var div = divs[i];\n        console.log(div);\n        }\n\n```\n\n### 从指定的标签box内部获取所有的div\n\n```javascript\n        // 获取指定标签内部的所有div\n        var box = document.getElementsById('box');\n        var divs = box.getElementsByTagName('div');\n        for(var i = 0; i < divs.length; i++){\n            console.log(divs[i]);\n        }\n```\n- 详细说明：\n    - 参数：标签名，字符串形式，不区分大小写（要求统一使用小写）。\n    - 返回值：\n        - 由获取到的所有DOM对象组成的伪数组。\n        - 当没有获取到元素时，返回空数组。\n- 总结：\n     - getElementById() 用于获取单个元素\n     - getElementsByTagName() 用于获取多个元素\n     - 注意getElementsByTagName()获取结果为伪数组。\n\n\n### 样式设置操作\n\n- **style方式**\n\n```javascript\n        //对元素进行操作，要先进行获取\n        var box = document.getElementById('box');\n        //使用style方式设置样式在标签的行内生效(行内样式)\n        box.style.width = '100px';\n        box.style.height ='100px';\n        //注意background-color 这种形式的样式在js中需要改为驼峰命名法\n        // font-size 变成 fontSize .. \n        box.style.backgroundColor = 'red';\n\n```\n- 详细说明：\n    - 设置的值为字符串类型\n        - 如果有单位，必须带单位。\n        - 颜色的书写方式可以为多种形式：rgb，rgba，16进制，单词形式。\n    - 使用style方式设置的样式显示在标签行内（行内样式）。\n\n\n### 根据类名获取元素getElementsByClassName\n\n- 类名操作：\n\n    - 修改标签的className属性相当于直接修改标签的类名\n\n```javascript\n        var mains = document.getElementsByClassName('main');\n        for (var i = 0; i < mains.length; i++) {\n        var main = mains[i];\n        console.log(main);\n        }\n```\n```javascript\n        //使用类名设置样式的好处，样式的复用更方便\n        //js中接直接通过元素的className属性进行操作即可\n        var box = document.getElementById('box');\n        box.className = 'colorRed';\n\n```\n例：\n\n```javascript\n        function getByClass (leiMing, element) {\n            element = element || document.body;\n            if (typeof document.getElementsByClassName === 'function') {\n                return element.getElementsByClassName(leiMing);\n            } else {\n                var resultArr = [];\n                // 1 根据标签名获取element中的所有标签\n                var tags = element.getElementsByTagName('*');\n                // 2 检测类名是否为box\n                var tempArr, j;\n                for (var i = 0; i < tags.length; i++) {\n                    // 需要准确的检测tags[i]的className属性中是否含有box的部分\n                    tempArr = tags[i].className.split(' ');\n                    // 遍历tempArr中的每个部分是否含有box\n                    for (j = 0; j < tempArr.length; j++) {\n                        // 如果类名中含有为box的部分，将tags[i]保存到结果数组中\n                        if (tempArr[j] === leiMing) {\n                            resultArr.push(tags[i]);\n                            break;\n                        }\n                    }\n                }\n                return resultArr;\n            }\n        }\n```\n\n### 文本操作 \n\n#### innerHTML 和innerText\n\n- innerHTML 和innerText  设置后会对元素内容进行覆盖\n- innerHTML 操作 可以操作纯文本以及标签 \n- innerText操作；只能设置为纯文本，不会生成结构。\n```javascript\n\n        box.innerHTML = '这是文本<p>标签内部的内容</p>';\n        console.log(box.innerHTML);\n\n\n        box.innerText = '这是文本<p>这是p标签内部的内容</p>';\n        console.log(box.innerText);\n```\n\n##### innerHTML\n\n- 好处：\n\n  - 1.可以指定位置创建元素\n\n  - 2.创建复杂结构时非常方便\n\n    - 需要进行基本的字符串处理：\n\n      - 1.删除换行 \n\n      - 2.使用转义符\n\n        ​\n\n - 缺点：\n\n- 1.会对内部的结构造成覆盖\n    - 使用+=的方式貌似可以解决覆盖问题。单实际上只是长得一样，并不是同一个标签\n\n    - 影响是，如果内部元素具有时间，时间就不存在了\n\n>       console.log(box.innerHTML);\n>\n>       box.innerHTML+='这是新内容'; \n\n\n- 2 执行的效率较低 - 860ms\n\n```javascript\n        console.time('innerHTML');\n            for (var i = 0; i < 1000; i++) {\n             box.innerHTML += '<div></div>';\n            }\n        console.timeEnd('innerHTML');\n```\n\n## 属性操作\n\n\n### 非表单元素的属性\n\n- href、title、id、src、className\n\n```javascript\n        var link = document.getElementById('link');\n        console.log(link.href);\n        console.log(link.title);\n\n        var pic = document.getElementById('pic');\n        console.log(pic.src);\n```\n\n### 标签行内自定义属性 \n\n```javascript\n        <div id=\"box\" data-hehe=\"a\"></div>\n        var box = document.getElementById('box');\n        // 获取行内属性：\n        console.log(box.getAttribute('data-hehe'));\n        // 设置行内属性：\n        box.setAttribute('data-hehe', '新内容');\n        // 移除行内属性：\n        box.removeAttribute('data-hehe');\n```\n\n- **注意**：上述方法可以操作标签行内的任意属性（自带的和自定义的），但是自带属性没必要这样操作。\n\n","tags":["JS"]},{"title":"12-Date类型对象","url":"%2F2017%2F02%2F24%2FJS%2F12-Date%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%2F","content":"\n# Date类型对象\n\n## Date类型对象介绍\n\n- Date类型对象是JavaScript提供的日期和时间的操作接口。它可以表示的时间范围是，1970年1月1日00:00:00前后的各1亿天（单位为毫秒）。\n- Date  是系统内置的构造函数，若想要操作时间，必须创建Date类型对象。\n\n\n## 创建Date类型对象\n\n- 方式1：【常用】\n    - 语法\n    > `var 变量名 = new Date(); ` // 创建当前时间对象\n    > 代码\n    >\n    >`var date = new Date();`\n    >\n    >`console.log(date);`\n    >\n\n- 方式2：【常用】\n    - 语法\n    > `var 变量名 = new Date(stringdate); ` // 创建指定的时间对象\n    >\n    >// 参数 stringdate, 字符串格式→ 'year-month-date hh:mm:ss'   或  'year/month/date hh:mm:ss'\n\n    > 代码\n\n    > `var date = new Date('2018/10/16 12:12:12');`\n    >\n    >`var date2 = new Date('2018-10-16 12:12:12');`\n    >\n    >`console.log(date);`\n    >\n    >`console.log(date2);`\n    >\n\n- 方式3：\n    - 语法\n    > `var 变量名 = new Date(value);  // 创建1970年开始value毫秒后的时间对象\n    >\n    > `// 参数 value, 数字，指的是毫秒数``\n    >\n\n    > 代码\n\n    > `var date = new Date(99999999999);`\n    >\n    >`console.log(date);`\n    >\n- 方式4：\n    - 语法 \n    > var 变量名 = new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);\n    >\n    > `// 参数 year、month、day、hour、minutes、seconds、milliseconds 都是数字，分别指的是年、月、日、时、分、秒、毫秒`\n    >\n    >`// 特别注意： month的范围是 [0-11]`\n\n    > 代码\n\n    > `var date = new Date(2018,9,16,12,12,12,12);`\n    >\n    >`console.log(date);`\n\n    \n## 常用的Date类型对象方法\n\n\n### 获取 和 设置 年月日\n\n\n```javascript\n        日期对象.getFullYear() / 日期对象.setFullYear(数字) // 年\n\n        日期对象.getMonth() / 日期对象.setMonth(数字)   // 月\n        注意：获取月份是从0开始的\n\n        日期对象.getDate() / 日期对象.setDate(数字)  //日\n```\n\n\n### 获取 和 设置 时分秒\n\n\n```javascript\n        日期对象.getHours()  /  日期对象.setHours(数字)  // 时\n\n        日期对象.getMinutes()  /  日期对象.setMinutes(数字) // 分\n\n        日期对象.getSeconds()  /  日期对象.setMinutes(数字) // 秒\n\n        对象. getMilliseconds()  / 对象.setMilliseconds(数字) // 毫秒\n```\n\n### 获取 星期数\n\n> 日期对象.getDay();   // 0-6（周日0到周六6） 不能够设置，原因是周天是由今天的日期决定的。\n\n\n- 获取1970年至指定时间的 总毫秒数\n\n> 日期对象.getTime()  /  日期对象.setTime(数字); ","tags":["JS"]},{"title":"14-String类型对象","url":"%2F2017%2F02%2F24%2FJS%2F14-String%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%2F","content":"\n# String字符串对象\n\n## 字符串的不可变性\n\n```javascript\n        var str = 'abc';\n        str = 'hello';\n        // 当重新给str赋值的时候，数据'abc'不会被修改，依然在内存中\n        // 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变\n        // 由于字符串的不可变，在大量拼接字符串的时候会有效率问题\n```\n\n### 基本包装对象\n\n - 思考：为什么基本数据类型字符串，可以像对象一样使用？\n\n ```javascript\n        // 普通字符串\n        var str = 'abc';   // 普通字符串不是对象\n        var len = str.length; // 但是为什么可以像对象一样使用点出东西？\n        alert(len); //3\n\n        //把字符串包装成对象 → 基本包装类型\n        var strObj = new String('abc');  // 把字符串包装成对象\n        var len = strObj.length;  // 因为是对象，所以可以点出东西。\n        alert(len); //3\n```\n\n## 字符串对象常用的方法\n\n- 字符串所有的方法，都 不会修改字符串本身(字符串是不可变的)，操作完成会 返回一个新的字符串\n  - 以下方法，可以自己尝试查手册或文档使用\n\n- 获取字符串中的单个字符\n\n```javascript\n    字符串.charAt(index);\n    字符串[index];      // 推荐使用 \n```\n    \n### 字符串的拼接concat 和 截取slice\n\n```javascript\n        // 拼接\n        字符串.concat(str1,str2,str3...);\n        拼接符 +     //推荐使用\n\n        // 截取\n        字符串.slice(star,end);\n```\n\n### 查询字符是否在字符串中存在\n\n\n```javascript\n        字符串.indexOf(); \n        字符串.lastIndexOf();\n```\n\n### 去除空白符trim\n\n\n```javascript\n        字符串.trim();  // 去除字符串两边的空格\n```\n\n### 字母字符大小写转换toUpperCase/toLowerCase\n\n\n```javascript\n        字符串.toUpperCase(); \t// 转换大写 重点\n        字符串.toLowerCase(); \t// 转换小写 重点\n```\n\n### 字符串替换replace\n\n\n```javascript\n        字符串.replace(newStr,oldStr);\n```\n\n### 字符串分割split\n\n\n```javascript\n        字符串.split(sp);  // 把一个字符串分割成字符串数组。\n```\n\n\n### 还有很多方法\n\n    - 查用MDN文档 或 离线手册 学习内置对象的属性 或 方法。\n","tags":["JS"]},{"title":"13-Array类型对象","url":"%2F2017%2F02%2F24%2FJS%2F13-Array%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%2F","content":"\n# Array类型对象\n\n## 数组创建方式\n\n### 方式1：构造函数Array\n\n```javascript\n// 语法：\n        var 数组名 = new Array(数据,数据,数据);\n        // 代码：\n        var names = new Array('张三','李四','王五','赵六');\n```\n\n### 方式2：数组字面量【推荐使用方式】\n\n```javascript\n        // 语法：\n        var 数组名 = [数据,数据,数据];  // 数组字面量\n        // 代码：\n        var names = ['张三','李四','王五','赵六'];\n```\n\n## 数组对象常用的方法\n\n### 向前后数组中添加元素unshift\n\n```javascript\n        //  向数组的开头添加一个或更多元素，并返回新的长度。【原数组会发生变化】 \n        数组名.unshift(newelement1,newelement2,....,newelementX);\n        // 向数组的末尾添加一个或更多元素，并返回新的长度 【原数组会发生变化】\n        数组名.push(newelement1,newelement2,....,newelementX); \n```\n\n### 从数组前后删除元素shift\n\n```javascript\n        // 删除并返回数组的第一个元素 【原数组会发生变化】\n        数组名.shift();\n        // 删除并返回数组的最后一个元素 【原数组会发生变化】\n        数组名.pop();\n```\n\n### 数组任意位置的添加、删除splice\n\n```javascript\n        // 向/从数组中添加/删除项目，然后返回被删除的项目。【原数组会发生变化】\n        数组名.splice(index,howmany,item1,.....,itemX)\n```\n\n\n### 数组元素的查询indexOf\n\n\n```javascript\n        // 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1\n        数组名.indexOf(searchElement); 【用的较多】\n        // 返回指定元素在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找\n        数组名.lastIndexOf(searchElement);\n```\n\n\n### 数组的反转 和 排序reverse\n\n\n```javascript\n        // 颠倒数组中元素的顺序。 【原数组会发生变化】\n        数组名.reverse();\n\n        // 对数组的元素进行排序 \n        数组名.sort();   // 默认排序顺序是根据字符串Unicode编码 【了解】\n\n        数组名.sort(function(a,b){    //【重点】\n        return a - b;   // 升序（从小到大）\n        })\n\n        数组名.sort(function(a,b){    //【重点】\n        return b - a;   // 降序（从大到小）\n        })\n```\n\n### 数组截取slice\n\n```javascript\n        // 从已有的数组中返回选定的元素。【截取后，不会改变原数组，而是返回新的数组】\n        数组名.slice(start,end);\n```\n\n### 数组元素的拼接join\n\n```javascript\n        // 用于把数组中的所有元素放入一个字符串。\n        数组名.join(separator);\n```\n\n### 数组的其他方法(forEach)\n\n```javascript\n        // 数组遍历\n        数组名.forEach(function(value,index,currentArray){\n        console.log(value);\n        });\n\n        // 过滤出符合筛选条件的元素，返回一个新的数组\n        数组名.filter(function(value,index,currentArray){\n            return 条件;    // 如：return value >= 1000;\n        });\n\n        // 验证数组中的每一个元素是否都符合指定的条件,返回布尔值\n        数组名.every(function(value,index,currentArray){\n        return 条件;    // 如：return value >= 1000;\n        });\n\n        // 验证数组中的元素，是否有符合指定条件的，返回布尔值\n        数组名.some(function(value,index,currentArray){\n        return 条件;  // 如：return value >= 1000;\n        });\n\n        // 遍历数组中的每一个元素，更改后存入一个新的数组中，返回一个新的数组\n        数组名.map(function(value,index,currentArray){\n        return 操作;   // 如：return value * 2;\n        });\n```\n\n### 清空数组\n\n```javascript\n        var arr = [22,33,44,55];\n        // 方式1 推荐 \n        arr = [];\n        // 方式2 \n        arr.length = 0;\n        // 方式3\n        arr.splice(0, arr.length);\n```\n\n\n## 栈和队列\n\n### 数据结构-栈和队列\n\n- 在js中没有栈 和 队列的概念，但是js可以通过数组的方法来模拟\n\n#### 栈\n\n- 特点：先进后出-FILO（First In Last Out）电梯\n\n- 代码：\n```javascript\n        var userNames = [];\n        // 先进\n        console.log(userNames); // []\n        userNames.push('张三');\n        console.log(userNames); // [\"张三\"]\n        userNames.push('李四');\n        console.log(userNames); // [\"张三\", \"李四\"]\n        userNames.push('王五');\n        console.log(userNames); // [\"张三\", \"李四\", \"王五\"]\n\n        // 后出\n        userNames.pop();   \n        console.log(userNames); // [\"张三\", \"李四\"]\n        userNames.pop();   \n        console.log(userNames); // [\"张三\"]\n        userNames.pop();       \n        console.log(userNames); // []\n```\n\n#### 队列\n\n    - 特点：先进先出-FIFO（ First  In  First  Out）排队买票\n- 代码：\n\n```javascript\n        var userNames = [];\n        // 先进\n        console.log(userNames); // []\n        userNames.push('张三');\n        console.log(userNames); // [\"张三\"]\n        userNames.push('李四');\n        console.log(userNames); // [\"张三\", \"李四\"]\n        userNames.push('王五');\n        console.log(userNames); // [\"张三\", \"李四\", \"王五\"]\n\n        // 先出出\n        userNames.shift();   \n        console.log(userNames); // [\"李四\", \"王五\"]\n        userNames.shift();   \n        console.log(userNames); // [\"王五\"]\n        userNames.shift();       \n        console.log(userNames); // []\n```\n\n\n\n\n","tags":["JS"]},{"title":"11-内置对象","url":"%2F2017%2F02%2F23%2FJS%2F11-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F","content":"\n# 内置对象\n-  内置对象、宿主对象、自定义对象的区别？\n\n## 内置对象\n\n    - 系统所提供的对象如：Object、Array、Math、Date等等。\n\n## 宿主对象\n\n    - JS所运行的环境提供的对象比如：BOM中的Window、DOM中的document；\n\n## 自定义对象\n\n     - 自定义构造函数所创建的对象。\n     \n**如何学习内置对象？**\n- 手册\n    > MDN\n    > W3C在线或离线手册\n\n- 如何学习一个对象中的方法？\n    > 1. 方法的功能\n    > 2. 方法的参数和类型\n    > 3. 方法的返回值\n    > 4. 写一个demo\n\n## Math对象\n\n\n**Math对象**\n\n- 1.Math本身就是一个对象（实例），不需要通过构造函数去创建，该对象中集合了很多关于数学运算的方法。也就是说，对于后期的一些复杂一些的数学运算，不需要自己动手去运算，直接调用Math对象中的方法实现即可。\n\n- 2.方法\n    - Math对象常用属性和方法\n    - Math.abs(数字);\t获取一个数字的绝对值\n    - Math.round(数字);   四舍五入\n    - Math.PI;    π\n    - Math.ceil(数字);    向上取整\n    - Math.floor(数字);  向下取整\n    - Math.random();    随机数(0,1);\n    - Math.max(数字,数字,数字...);    求最大数\n    - Math.min(数字,数字,数字...);     求最小数\n","tags":["JS"]},{"title":"10-基本数据类型和引用数据类型","url":"%2F2017%2F02%2F23%2FJS%2F10-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F","content":"\n# 两种数据类型在内存中的分布和区别\n\n- 基本数据类型\n    - 指的是 简单的数据类型，也叫值类型，有数字Number、字符串String、布尔Boolean、未定义Undefined、空Null。\n\n- 引用数据类型 \n    - 指的是 复杂的数据类型， 也叫引用类型，有数组Array、函数Function、对象等\n\n\n## 基本类型数据传递给函数的参数时\n\n\n- 基本类型数据在复制时（一个变量名赋值给另一个新的变量名），会在栈区申请一块的空间存放一个新的数据，并且新的变量名会指向新的数据。\n```javascript\n        var num = 123;\n        function fn(n){\n        n = 1000;\n        }\n        fn(num);\n        console.log(num); //?\n```\n\n## 引用类型数据传递给函数的参数时\n\n- 引用类型数据在复制时（一个变量名赋值给另一个新的变量名），会在栈区申请一块的空间存放堆区中的引用类型数据的地址，并且新的变量名会指向栈区中存放地址的空间。\n```javascript\n        var obj = {userName:'张三',age:18};\n\n        function fn(o){\n        o.age = 20;\n        }\n        fn(obj);\n        console.log(obj.age); //?\n```\n\n\n## 内存中有两个区：栈区、堆区\n\n\n- 注意：js中没有堆和栈，在这里只是为了理解基本数据类型和引用数据类型的区别 或 方便以后学习其他编程语言（如：C、C++、Java）\n\n- 栈区：用来存放变量名和基本数据类型的数据 和  引用类型数据的地址。\n\n- 堆区：用来存放引用数据类型的数据\n","tags":["JS"]},{"title":"09-对象","url":"%2F2017%2F02%2F22%2FJS%2F09-%E5%AF%B9%E8%B1%A1%2F","content":"\n # 对象\n\n ## 对象的概念\n\n- 从生活角度，万物皆对象；\n- 从数据角度，对象就是一组无序数据的集合，它封装了属性和方法。\n- 任何事物都可以被抽象成对象, 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。\n\n- 编程角度\n    - 对象是一个容器，封装了  【属性】  和  【方法】 \n        - 属性：对象的静态特征\n        - 方法：对象的动态特征，一般指的是对象的一种功能（用匿名函数表示）或行为\n\n\n## 类的概念\n\n（了解对象之前先了解类的概念以及类和对象的关系）\n\n  - 类是抽象的模板。\n    - 【ECMAScript6.0之前没有类的概念，但是ES6之前可以通过函数可以模拟出类，该函数被称为 构造函数】\n    > ECMAScript 核心语法   ES3.0  ES5.0  ES6.0\n    >\n    > DOM   文档对象模型\n    >\n    > BOM   浏览器对象模型\n    >\n\n\n## 类和对象的关系\n\n- 类是对象的模板，对象是类的实例。\n\n  - 所以，创建对象之前、应该先创建类\n - 对象是具体的实例。\n    - 类和对象的关系：就像月饼模子 和 月饼的关系。  类是对象的模板，对象是类的一个实例。\n\n\n## this的指向问题\n\nthis的指向问题只要是构造函数被调用时因为调用方式不同this指向不同。\n\n- ①当构造函数被当做一个普通的函数调用时，构造函数体内的this关键字指向windows对象。\n\n- ②当构造函数用{new构造函数名(实参);}的方式调用构造函数创建对象时，this指向当前所创建的构造函数名（类名）类型的对象。\n\n\n## 对象的创建方式（三种）\n\n\n- 使用Object类创建一个对象（因为Object类是所以对象的祖宗类 我们不用在创建新的类可以用祖宗类直接创建对象）\n\n  - 语法结构\n   - 方式1：通过 new关键字调用系统提供 Object构造函数\n\n    > ​\t`var obj  = new Object( );`//创建一个对象\n    >\n    >`var 变量名 = {}; `//字面量，是对new Object(); 的一个简写 推荐使用 \n    >\n\n  - 语法结构\n\n    > var obj = { };\n    >\n    > var obj = { 键：值，键：值，......}\n    >\n    >例如：\n    >\n    >`var wuKong = {`\n    >\n    >​\t`nume：\"孙悟空\"；`\n    >\n    >​\t`age：500；`\n    >\n    >​\t`attack：function( ){ `\n    >\n    >​\t`console.log(this.name+\"发动的攻击\")}`\n    >\n    >`}`\n\n - 自定义构造函数\n\n  - 作用：模拟一个类来创建对象\n\n  - 语法结构\n\n    > `function 类名(形参，形参，.......){`// 构造函数命名首字母要大写（帕斯卡命名法）\n    >\n    >//this表示通过new创建的哪个当前的对象\n    >\n    > ​\t`this.键名 = 形参；`\n    >\n    > ​\t`this.键名 = 形参；`\n    >\n    > ​\t`this.函数名 = function( ){`\n    >\n    > ​\t函数体；类中用函数实现的一种功能\n    >\n    > ​\t`}`\n    >\n    > `}`\n    >\n    > `var dx1 = new 构造函数名(实参,实参...);`\n\n  - 普通函数和构造函数的区别\n\n    - 命名规则不一样。\n\n      - 构造函数使用帕斯卡命名\n\n      - 普通函数使用驼峰命名法\n\n    - 调用方式不一样。\n\n      - 普通函数，直接调用。\n\n      - 构造函数，需要通过 new关键字调用\n - 系统提供的构造函数  和 自定义构造函数的区别\n\n    - 系统提供的构造函数创建的对象，叫做 内置对象。【现阶段重点就是使用内置对象】。\n\n    - 自定义构造函数创建的对象，叫做 自定义对象。【后面js高级会深入讲解和使用】\n\n## new关键字\n\n### new关键字的执行过程\n\n - 作用：通过调用构造函数创建对象\n\n - new关键字的执行过程：\n    - ①在内存中创建了一个空的Object类型的对象（看不见）\n    - 让this关键字指向这个空的对象（看不见）\n    - ③通过this给这个对象添加属性和方法（看的见）\n    - ④将对象 返回给用new关键字调用构造函数的 调用者(看不见)。\n        - 备注：Object在JS中是祖宗类（构造函数），所有不同类型的对象，都直接或间接的继承于它。\n\n# 对象的操作【重要】\n\n- 对象组织数据的方式是： 键值对。\n    - 键，指的是属性名或方法名，命名规范和变量名一样。\n    - 值，指的是实际的数据。\n\n- 设置属性和方法\n    - 对象名.键名 = 值;【重点】\n    - 对象名['键名'] = 值;\n\n    > 代码：\n```javascript\n    var dog1 = {};\n    dog1.name = '旺财'; // 属性\n    dog1.age = 1;    // 属性\n    dog1.call = function () { // 方法\n    alert(this.name + '在汪汪叫...')\n    }\n    // 注意，方法要用函数来表示\n```\n\n## 获取属性 和 调用方法\n\n- 访问对象中的属性和方法：\n\n    - 对象.键名; 【重点】\n    - 对象[‘键名’];\n\n    > 代码：\n\n```javascript\n    var dog1 = {};\n    dog1.name = '旺财'; // 属性\n    dog1.age = 1;    // 属性\n    dog1.call = function () {  // 方法\n    alert(this.name + '在汪汪叫 ...')\n    }\n    // 注意，方法要用函数来表示\n    dog1.call(); // 调用\n    console.log(dog1.name);\n    console.log(dog1.age);\n```\n\n### 删除属性和方法\n\n- delete 对象.键名;  【重点】\n- delete 对象['键名'];\n\n> 代码：\n```javascript\n        var dog1 = {\n            name:'旺财',\n            age:1,\n            call:function(){\n            alert(this.name + '在汪汪叫...')\n            }\n        };\n        //删除之前访问\n        console.log(dog1.name); //旺财\n        //删除\n        delete dog.name;\n        //删除之后访问\n        console.log(do1.name); //undefiend\n        //检测对中是否还要name属性\n        console.log(dog1.hasOwnProperty('name'));  //false;\n```\n\n### 检测属性或方法\n - 检测一个对象中是否存在某个属性或方法：\n    - 对象.hasOwnProperty('键名');  // 返回boolean值，false表示不存在，true表示存在\n\n    > 代码：\n```javascript\n        var dog1 = {\n            name:'旺财',\n            age: 1,\n            call:function(){\n            alert(this.name + '在汪汪叫...')\n            }\n        };\n        var r1 = do1.hasOwnProperty('age');\n        console.log(r1); // true\n        var r2 = do1.hasOwnProperty('gender');\n        console.log(r2); // false\n        var r3 = do1.hasOwnProperty('call');\n        console.log(r3); // true\n        var r4 = do1.hasOwnProperty('eat');\n        console.log(r4); // false\n```\n\n\n### 对象中属性的遍历\n    \n - 遍历对象中的键值对\n\n>语法：遍历方式  for-in\n\n  > `for (var 键名 in 对象名){`\n  >\n  > `\t对象名[key]；`//key 是对象中的每一个键\n  >\n  > `}`\n\n- 例：\n\n  > `var obj = {name : \" 张三 \"，age ：17};`\n  >\n  > `for ( var key in obj ){`\n  >\n  > ​\t`obj[key];`    \t\t    \t\t遍历对象中所有键\n  >\n  > ​\t`console.log( obj[key] ); `\t打印\n  >\n  > `}`\n\n\n## 检测对象的类型\n\n### 检测对象的类型\n\n\n- 检测一个对象的数据类型\n\n    - 对象是引用数据类型，检测对象时不要用typeof去检测，要用instanceof\n> 对象 instanceof 构造函数名;    // 返回boolean值，true表示属于，false表示不属于\n\n> 代码\n\n```javascript\n        /*\n            创建构造函数 Person\n        */\n        function Person(name,age,gender){\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        }\n        // 创建一个Person类型的对象 p1\n        var p1 = new Person('张三',17,'男');\n        // 检测对象p1是否属于Person\n        console.log(p1 instanceof Person);  //true\n```\n\n\n\n\n\n  ","tags":["JS"]},{"title":"08-函数","url":"%2F2017%2F02%2F21%2FJS%2F08-%E5%87%BD%E6%95%B0%2F","content":"\n# 函数\n\n## 概念\n\n  - 函数就是功能，也是引用类型的数据。\n简单理解就是一个 功能，功能可以反复调用。\n- 函数的作用\n  - 封装性，将执行代码封闭在一个独立的执行环境中。可以反复调用，减少代码冗余\n\n### 类型\n\n- function\n\n### 函数创建\n\n- 函数创建有两种方式\n\n- 函数表达式；\n\n  >var 函数名 = function( ){};\n\n- 函数声明\n\n    > function 函数名( ){\n    >\n    > 函数名和变量名的命名规则规范一样\n    >\n    > ​\t\t函数体；\n    >\n    > }\n  - 【注意】：函数创建完后，函数体中的代码不会执行，只用调用时才会执行\n    > 调用函数 ↓ \n    >\n    > 函数名(); \n\n  - 代码：\n    > 创建\n    >\n    >`function getEven() {`\n    >\n    >`for (var i = 1; i <= 100; i++) {`\n    >\n    >`if (i % 2 == 0) {`\n    >\n    > `console.log(i);`\n    >\n    >`}`\n    >\n    >`}`\n    >\n    >`}`\n    >\n    >`cosnole.log('地方1');`\n    >\n    >`getEven();` // 调用\n    >\n    >`cosnole.log('地方2');`\n    >\n    >`getEven(); `// 调用\n    >\n    >`cosnole.log('地方3');`\n    >\n    >`getEven();` // 调用\n    >\n\n\n### 调用\n\n- 函数名( );或 函数名(数据，数据...);\n\n### 参数\n\n- 参数可用分为形参和实参\n  - 形参：创建函数时小括号( )中定义的标识符。就是形参。\n  - 实参：调用函数时小括号( )中传入的实际的数据就是实参。\n\n- 语法：\n    >`function 函数名(形参,形参,形参...) {`//形参，就是一个占位符，命名规则和规范和变量一样.\n    >\n    >`函数体`\n    >\n    >`}`\n    >\n    >`函数名(数据,数据,数据...); `\n    >\n    >//实参，就是实际的数据\n\n - 代码: \n    >创建函数\n    >\n    >`function getSum(n,m) {`\n    >\n    >`var sum = 0;`\n    >\n    >`for (var i = n; n<=m; n++) {`\n    >\n    >`sum = sum + n;`\n    >\n    >`}`\n    >\n    >`console.log(sum);`\n    >\n    >`}`\n    >\n    >// 调用\n    >\n    >`getSum(1,100);`\n\n\n### 返回值\n\n- 关键字：\treturn\n  - 作用：\t可以终止函数的执行,可以将数据返回给调用者.\n      - 调用者  可以用变量接收函数返回的结果\n  - 语法：      \n    > // return 关键字，要在函数体内使用\n    >\n    >function 函数名(形参,形参,形参) {\n    >\n    >//① 函数体内没有return时; 函数默认返回undefined\n    >\n    >//② return 数据;  //终止函数，并返回数据。\n    >\n    >//③ return;   //终止函数，并返回undefined\n    >\n    >}\n\n  - 代码：\n    >`function getSum(n,m) {`\n    >\n    >`var sum = 0;`\n    >\n    >`for (var i = n; n<=m; n++) {`\n    >\n    >`sum = sum + n;`\n    >\n    >`}`\n    >\n    >`return sum;`\n    >\n    >`}`\n    >\n    > // 调用函数\n    >\n    >` var r1 = getSum(100,200);`// 函数把结果给了 r1\n    // 用户可以任意使用函数的结果 \n    >\n    >`document.write('<h1>' + r1 + '</h1>');`\n    >\n    >`document.write('<h2>' + r1 + '</h2>');`\n    >\n    >`document.write('<h3>' + r1 + '</h3>');`\n    >\n    >`console.log(r1);`\n\n\n\n\n\n# 函数体中arguments\n\n- 函数体内的一个数组，存放了所有实参。（就是调用函数时，当实参是一个数组，函数体可以直接用arguments来存放实参，不需要定义形参）。\n- aruments，函数体内提供的一个伪数组。aruments中存放了所有的实参\n- aruments的使用：\n    > `function 函数名(){`\n    >\n    >`//arguments.length;  参数的个数`\n    >\n    >` //arguments[索引];   //获取一个实参`\n    >\n    >`}`\n\n- 全局变量的特殊情况\n    > `function fn() {`\n    >\n    > ` a = 123;//隐式全局变量`\n    >\n    >`}`\n    >\n    >`fn();`\n    >\n    >`alert(a); `// ?\n\n\n## 函数创建方式2\n\n\n - ①函数声明\n\n    > `function 函数名() {`     \n    >\n    >` // 函数体 `\n    >\n    >`}`\n - ②函数表达式\n    > `var 变量名 = function() {`\n    >\n    >`//函数体`\n    >\n    >`}`\n\n\n### 函数声明 和 函数表达式的区别？\n\n  > `fn();`// ?  答案：打印1\n  >\n  > `function fn () {`\n  >\n  > `alert('1');`\n  >\n  > `}`\n  >\n  \n\n\n\n  >`fn();`// ?  报错 不是一个函数\n  >\n  >`var fn = function() {`\n  >\n  >`alert('你好');`\n  >\n  >`}`\n  >\n\n### 匿名函数 和 自调用函数\n\n  - 函数也是一种数据类型。属于引用数据类型（Function）\n  - 匿名函数就是 没有名字的函数。在js中匿名函数需要 配合运算符使用\n\n\n- 函数创建的第二种方式：函数表达式\n    > `var 变量名 = function() {`\n    >\n    >`//函数体;`\n    >\n    >`}`\n\n\n### 自调用函数（自调用函数）\n\n\n- 自执行函数就是匿名函数 创建后马上调用执行\n```javascript\n      //匿名函数 【常用的方式】 \n      (function(){\n      //函数体\n        })();\n\n\n\n      //匿名函数 【常用的方式】\n      (function(形参,形参){\n      //函数体\n      })();\n```\n- 自调用函数的优点   \n  - ①模拟块级作用域；\n\n  - ②避免全局变量污染（命名冲突） \n\n\n### 函数作为函数的参数\n\n\n- 回调函数的参数\n  - 形参，函数定义时的标识符。\n  - 实参，函数调用时传入的实际的数据。\n  - 函数也是一种数据类型，类型是 Function\n```javascript\n    function fn(f){\n      f();\n    }\n\n    fn(function(){\n      alert('执行');\n    });\n```\n\n**自我总结**\n - 本质归根结底是还是形参和实参的关系。 无非是把一个函数当做实参传递给了一个形参！\n\n\n# 预解析\n\n## 预解析→执行之前的预备过程\n- 什么是预解析?\n    > 程序准备→执行。程序在执行之前，有个预备过程。 预备过程要做的事就是预解析。预备过程要做两件事，分别是：\n     - 把用 var关键字所声明的变量名（ 仅仅是变量名），提升到当前执行环境（作用域）的顶部。\n\n     - 把用 函数声明所创建的函数（ 函数整体），提升到当前执行环境（作用域）的顶部。\n- 预解析有两步；\n\n  ①把var关键字创建的变量名（仅仅是变量名）提升到当前作用域的顶部。\n\n  ②把函数声明方式创建的整个函数体提升到当前作用域的顶部。\n\n# 作用域\n- 什么是作用域？\n    - 变量可访问的范围。\n\n## 全局作用域—函数之外的环境。\n  - 什么全局作用域\n    - 函数之外的执行环境。\n\n  - 全局变量：\n    - 在全局作用域中用var关键字创建的变量.\n    - 访问范围：程序的任何地方\n\n\n### 局部作用域—函数体内的环境。\n  - 什么是局部作用域\n     - 函数体内的执行环境\n\n    - 局部变量:  \n      - 在局部作用域中定义的变量称为局部变量。函数定义的形参,以及     在 函数体中用var关键字定义的变量\n\n- 局部变量只能在本函数体中使用。\n\n\n### 块级作用域\n\n\n- js中没有块级作用域（我们用匿名函数和自执行函数模拟块级作用域）在分支结构或循环结构中创建的变量，仅仅只能在本分支或循环结构中使用。\n\n# 作用域链\n\n- 指的是访问一个变量时，会先从本作用域中去找，若没找到，则向上一层作用域中去找，以此类推就构成了作用域链.\n```javascript\n  var a = 1;\n  function fn1(){\n    var a = 2;\n    var b = '2b';\n    function fn2(){\n      var a = 3;\n      function fn3(){\n        var a = 4;\n        console.log(a);   //a的值 ?4\n        console.log(b);    //b的值 ?'2b'\n      }\n      fn3();\n      \n    }\n    fn2();\n  }\n  fn1();\n```\n\n\n\n","tags":["JS"]},{"title":"07-数组","url":"%2F2017%2F02%2F20%2FJS%2F07-%E6%95%B0%E7%BB%84%2F","content":"\n# 数组\n\n## 概念\n\n- 数组是一组有序的数据集合\n- 有序是：下标（索引值）是有序的（从0开始）\n- 数组也是一种数据，是属于引用类型的数据。\n- 数组的优点：可以存储一组数据交给一个变量统一管理，并且可以方便的维护和操作。\n- 概念：数组是一组 有序的 数据的集合\n\n## 数组的操作\n\n- 方式1：通过构造函数\n\n  > var 变量名 = new Array(); \n  >\n   - 空的数组   相当于  var 变量名 = []; \n  > var 变量名 = new Array(数据,数据,数据,数据); \n   - 相当于 var 变量名 = [数据,数据,数据,数据]\n\n    - 代码：\n  > `var userNames = new Array();`\n  >\n  > `var userNames = new Array('张三','李四','王五','赵六')`\n\n\n- 方式2：数组字面量【推荐使用】\n  >  var 变量名 = [];  \n  > \n  >空的数组\n  >\n  > var 变量名 = [数据,数据,数据,数据];\n  >\n  > 有数据 的数组\n    - 代码：\n  > `var userNames = [];`\n  >\n  > `var userNames = ['张三','李四','王五','赵六']`\n- 小细节\n    - 若小括号中只有一个数字时，表示数组在内存中连续申请了n个空间，每个空间的默认值是 undefined。\n    > var 变量 = new Array(数字); \n    >\n    - 如：代码：\n    >\n\t  > `var userNames = new Array(4)`\n\n\n## 访问和设置数组的元素\n\n- 访问数组中的元素\n\n- 语法：数组名[下标];    下标 也叫 索引.下标是从 0    1     2      3   ...\n\n- 获取数组中的元素。\n    - 代码：\n  >`var userNames = ['张三','李四','王五','赵六'];`\n  >\n  >\n  >`console.log(userNames[1]);`//获取李四\n  >\n  >`console.log(userNames[4]);`\n  >\n  >  ↑  undefined\n\n- 设置（修改）数组中的元素\n\n    - 代码：\n  >`var userNames = ['张三','李四','王五','赵六']; `// 修改李四 为 LiSi\n  >\n  >`userNames[1] = 'LiSi';`\n  >\n  >`console.log(userNames);`\n  >// ['张三','LiSi','王五','赵六']\n\n\n## 数组的length属性\n\n - 通过 length 获取数组中元素的个数 【重点】\n - 语法：数组名.length;\n    - 代码：\n    > `var userNames = ['张三','李四','王五','赵六'];`\n    > \n    >` console.log(userNames.length); `// 4\n\n- 通过length 设定数组的长度\n- 语法：数组名.length = 数字;\n    - 代码1：\n  >`var userNames = ['张三','李四','王五','赵六'];`\n  >\n  >`userNames.length = 6;`// 因为数组长度为6，所以新增了两个空间.\n    - 代码2：\n  >`var userNames = ['张三','李四','王五','赵六'];`\n  >\n  >`userNames.length = 4;`// 因为数组长度为4，所以减了两个空间.\n\n- 通过length清空数组\n  > `var userNames = ['张三', '李四', '王五', '赵六'];`\n  >\n  > `console.log(userNames);`// 清空之前 ['张三', '李四', '王五', '赵六']\n  >\n  > `userNames.length = 0;`\n  >\n  >`console.log(userNames); `// 清空之后 []\n\n- 向数组最后追加新元素\n- 语法： 数组名[数组名.length] = 数据;\n  > `var userNames = ['张三', '李四', '王五', '赵六'];`\n  >\n  >`userNames[数组名.length] = '陈七';`\n  >\n  >`console.log(userNames);`//['张三', '李四', '王五', '赵六','陈七']\n\n\n- 赋值：\n\n  > ​\t1.\tvar arr = [];\n  >\n  > ​\t\tarr[0] = \"张三\"；\t\n  >\n  > ​\t\tarr[1] = \"李四\"；\n  >\n  > ​\t2. \tvar arr = [\"张三\",\"李四\"]；\n  >\n  > ​\t3.\tvar arr = new Arrary[\"张三\",\"李四\"];\n\n- 获取数组中的数据                数组名[下标];\n\n- 长度=数组中数据的个数     数组名.length；\n\n- 添加数据                                数组名[数组名.length]=值；\n\n- 修改数据                                数组名[下标]=值;\n\n  ​\n\n## 冒泡排序\n\n- 冒泡排序：\n    -  比较的趟数：数据的个数 - 1； （多趟）\n    - 每趟比较的次数：数据的个数 - 当前趟数\n\n```javascript\n    var nums = [40,8,15,18,12];\n      for(var i =1;i<nums.length;i++ ){  //描述重复的趟数\n        //console.log(i);\n        for(var j = 0;j<nums.length-i;j++){ //每趟比较的次数\n            if(nums[j]>nums[j+1]){//比较大小，是否交换位置\n            var temp = nums[j];\n              \n              nums[j] = nums[j+1];\n              \n              nums[j+1] = temp;\n              \n              }\n          }\n      }\n      console.log(nums);\n  ```\n\n","tags":["JS"]},{"title":"06-流程控制","url":"%2F2017%2F02%2F19%2FJS%2F06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F","content":"\n# 流程控制\n\n## 表达式和语句\n\n - 表达式\n  一个表达式可以产生一个值，有可能是运算、函数调用、有可能是字面量。表达式可以放在任何需要值的地方。\n  表达式是程序最基本的组部分，每个表达式具有一个结果（也就是有一个返回值）\n\n  - 语句\n  语句可以理解为一个行为，循环语句和判断语句就是典型的语句。一个程序有很多个语句组成，一般情况下;分割一个一个的语句\n\n\n- 表达式种类：\n  - 一元表达式：var num = 100\n    - num++;\n    - !\"asd\";\n    - typeof22;\n  - 二元表达式:  1+1;\n    -  2>3;\n    - \"a\"==\"b\";\n\n- 语句是完整的行为：一个程序是由多个语句组成的，语句通常没有返回值。\n  - 例如：alert(\"我是弹出提示框\")；\n\n\n## 顺序结构\n\n  顺序结构就是程序默认的执行循序（自上而下，从内到外）。程序默认就是由上到下顺序执行的\n\n## 分支结构\n\n- 根据不同的情况，执行对应代码\n\n  - 1.单if语句\n\n  ​\tif条件当为布尔表达式\n\n  ​\tif(布尔表达式){}；\n\n  - 如果没有设置条件为布尔表达式，会对结果进行隐式转换为布尔类型。\n        \n    >  `if (条件表达式) {`\n    >\n    >  ` 执行语句`\n    >    \n    >  ` }`\n - 2.if...else...语句\n    >  `if (条件表达式){`\n    >\n    >  `   成立执行语句`\n    >\n    >  `} else {`\n    >\n    >  `   否则执行语句`\n    >\n    >  `}`\n\n  - 3.if...else   if...ele   if...else\n    >  `if (条件表达式1) {`\n    >\n    >  `   成立执行语句`\n    >\n    >  `}else if (条件表达式2) {`\n    >\n    >  `   成立执行语句`\n    >\n    >  `}else if (条件表达式3) {`\n    >\n    >  `   否则执行语句`\n    >\n    >  `}else{`\n    >\n    >  `   最后默认执行语句`\n    >\n    >  `}`\n\n  4.switch 语句\n\n  - 通常switch语句用于对一个变量的值进行检测使用。\n\n  - 判断方式：条件值和某个case后的值全等（注意.是全等比较），才可以执行对应代码。\n\n  - 不需要默认的执行顺序，执行一种情况后就结束程序则在每个case后添加break；\n\n    > `switch(条件值){`\n    >\n    > ​\t`case 值 1；`\n    >\n    > ​\t\t`代码段1；`\n    >\n    > ​\t\t`break；`\n    >\n    > ​\t\t`case 值 2；`\n    >\n    > ​\t\t`代码段2；`\n    >\n    > ​\t\t`break；`\n    >\n    > ​\t`default：`\n    >\n    > ​\t\t`default的代码；`\n    >\n    > `}；`\n\n  - break关键字和continue的区别\n\n    - break：终止当前整个循环；\n    - continue：结束当前这一次的循环，并开始下一下循环。\n\n  - break可以省略，如果省略，代码会继续执行下一个case\n  switch 语句在比较值时使用的是全等操作符, 因此不会发生类型转换（例如，字符串'10' 不等于数值 10）\n\n  - 5.三元运算符\n\n  - 表达式1（比较运算符）表达式2？表达式：表达式2；\n  - 三元表达式是对if……else语句的一种简化写法\n\n##  循环结构\n\n\n  - 1.while循环\n\n    - 语法结构：（注意：当while的条件值为true时，会重\t复的执行内部代码段，直到条件值为false时不再执行内部代码）\n\n  >`while(条件表达式){`\n  >\n  >​\t`代码段；`\n  >\n  >`}`\n  >\n  >如果一个while循环的条件值为true，是一个死循环\n\n  ​\n\n- 2.do...while循环\n\n  - 语法结构：（注意：执行方式为，先执行循环内的代码，然后进行第一次判断）与while循环的区别：while是先判断，在执行，do...while是无论如何都会先执行一次，再判断。\n\n  > `do{`\n  >\n  > ​\t`代码段；`\n  >\n  > `} while(条件表达式)`\n  >\n  > 如果一个do…while循环的条件值恒为true，是一个死循环\n\n  ​\n\n  3.for 循环\n\n  > `for(var i = 1; i < n ; i++){`\n  >\n  > ​\t`代码段；`\n  >\n  > `};`\n  >\n  > ① i=1;② i<n; ③ i++; ④ 代码段； \n  >\n  > 执行顺序为：①→②→④→③→②→④→③循环\n\n  - for嵌套循环：将多个循环套在一起使用的结构\n\n    - 注意：多个循环变量的命名不能相同。\n\n\n  > `for (var i=1;i<n;i++){`\n  >\n  > ​\t代码段；这个循环执行n次\n  >\n  > ​\t`for (var j=0;j<m;j++){`\n  >\n  > ​\t内循环单独可以执行m次，放在外循环中可以执行n*m次\n  >\n  > ​\t内部的循环执行次数=外循环的执行次数*内部循环单独执行的次数\n  >\n  > ​\t\t`代码段；`\n  >\n  > ​\t`}`\n  >\n  > `}`\n\n **布尔类型的隐式转换**\n\n - 流程控制语句会把后面的值隐式转换成布尔类型\n  - 转换为true   非空字符串  非0数字  true 任何对象\n转换成false  空字符串  0  false  null  undefined\n\n 思考：\n> `var a = !!'123';`\n>\n> `结果是什么？ `","tags":["JS"]},{"title":"05-数据类型转换","url":"%2F2017%2F02%2F19%2FJS%2F05-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F","content":"# 数据类型转换\n\n   - 介绍：在程序中，任何类型的数据之间都可以参与运算符的。比如数字可以和字符串参与运算，字符串可以和布尔值参与参数等等。\n\n\t总而言之，任何不同类型的数据之间可以参与任何不同的运算。\n\n  - 如：案例，接收用户说输入的年龄，在用户年龄原有的基础之上加5.\n  ` var age = prompt('请输入你的年龄'); //加入用户输入的是10`\n  `age = age + 5;  `\n  `console.log(age);  //结果是 105，为什么？如何解决？ `\n   \n   注意：基本数据类型进行转换，只能通过功能获取到转换后的结果，但是原值不会发生改变的。\n\n## 将数据类型转换成字符串\n\n  注意：其他数据转字符串，实质就是给其他数据两边加上字符串的特性（单引号或双引号）\n\n\n### 1.强制转换\n\n明确告诉程序，要进行数据类型转换\n\n  - **变量tostring();方法**\n\n    `var num = 100；`\n\n    `console.log(num.toString());//100`\n\n    `console.log(num);//100`\n\n    ​\n\n  - **String(数据)方法**\n\n    `var num = 100; `\n\n    `console.log(string(num));`\n\n    `console.log(num);`\n\n  String()功能存在的目的是为了弥补tostring()的不足（null和undefined不能作为变量调用toString()方法进行字符串的强制转换）\n\n  ​\n\n## 2.隐式转换\n\n偷偷的对数据进行类型转换\n\n  任何数据和字符串相加，其他非字符串类型的数据会自动转换为字符串。\n\n  其实就是看不见的用String(数据)转换。\n\n\n### 什么叫做隐式转换？\n  \n\n\t隐式转换，也被称为自动转换。就是在程序运行过程中，不需要我们手动转换，数据会根据运算情况自动的转换为其他类型的数据。\n\n### 将数据的类型转换伪数组类型\n\n  对数值类型的转换规则，从左往右检测。遇到不是数就停止。\n\n  **1.强制转换**\n\n  **Number(数据)**\n\n  `console.log(Number(\"100\"));\t`\t\t\t// 100\n\n  `console.log(Number(\"\"));\t`\t\t\t// 0 为空，不加空格\n\n  `console.log(Number(“ ”));`\t\t\t// 0\t\t为空，加空格\n\n  `console.log(Number(“true”));\t`\t\t// 1\n\n  `console.log(Number(“false”));`\t\t// 0\n\n  `console.log(Number(“null”));\t`\t\t// 0\n\n  `console.log(Number(“undefined”));`  // NaN\n\n  如果进行数值类型转换，出现了NaN时表示转换失败。\n\n  **parseInt(数据)**\n\n  `console.log(parseInt (“100”));`\t\t\t// 100\n\n  `console.log(parseInt (“100a1d2d2”));`\t// 100   \n\n  `console.log(parseInt (“100.1”));`\t\t// 100  取整\n\n  `console.log(parseInt (“d100”));`\t\t\t// NaN\n\n  `console.log(parseInt (“”));`\t\t\t\t// 0   为空，不加空格\n\n  `console.log(parseInt (“ ”));`\t\t\t//NaN\n\n  `console.log(parseInt (“true”));`\t\t\t// NaN\n\n  `console.log(parseInt (“false”));`\t\t// NaN\n\n  `console.log(parseInt (“null”));`\t\t\t// NaN\n\n  `console.log(parseInt (“undefined”));`\t// NaN\n\n  **parseFloat(数据)  （与parseInt的区别在于可以取出小数的部分）**\n\n  `console.log(parseFloat (“100”));`\t\t// 100\n\n  `console.log(parseFloat (“100a1d2d2”)); `\t// 100   \n\n  `console.log(parseFloat (“100.1”));`\t\t// 100.1 \n\n  `console.log(parseFloat (“d100.12”));`\t// NaN\n\n\n\n\n \n### 其他数据转字符串 String\n\n  任何数据和字符串做相加运算时，其他非字符串数据会自动的转换为String类型的数据。就相当于悄悄的，看不见的用String(其他数据)转换为字符串。\n  ```javascript\n      var result1 = true + '我'; // 布尔值 true 自动转换为字符串 'true'\n      console.log(result1); // 'true我'\n  ```\n\n\n### 其他数据转数字 Number\n\n  ​\t在做算术运算时（除了和字符串做相加操作外）其他非数字类型的数据会自动转换为Number类型，其实就是看不见的用Number(数据)转换；\n  ```javascript\n      var result1 = '2' - 1; //字符串 '2' 自动转换为数字 2\n      console.log(result1); // 1;\n\n      var result2 = '3a' - 1;  //字符串 '3a' 自动转换为数字 NaN\n      console.log(result2); // NaN\n  ```\n\n  ​\t在任何数据和NaN做算术运，结果是在都是NaN（除了和字符串相加操作外），包括NaN和本身运算。\n\n\n### 其他数据转布尔 Boolean\n\n\n  在取反、选择语句 和 循环语句中的条件表达式中，其他数据会自动的转换为布尔值。就相当于悄悄的，看不见的用Boolean(其他数据)转换为布尔值。\n  ```javascript\n      console.log(!1);  //false ; 数字1 转换为boolean值为 true,对true取反就是false\n      consoel.log(!(1>=2)); //true\n  ```\n\n### 使用 + - * / % 可以实现隐式转换\n\n\n  `console.log(“100” – 0 );`\n\n  `console.log(“100” * 1 );`\n\n  `console.log(“100” / 1 );`\n\n  `console.log(“100” % Infinity);`\n\n  `console.log(+ “100” );`\n\n  **注意：使用（+加操作进行赋值的转换：需要将+前至于数据，前面不能有其他数据，否则会转换成字符串）。\n\n\n### 将数据的数据类型转换为布尔类型\n\n\n  **1.强制转换**\n\n  Boolean(数据)\n\n  `console.log(Boolean(“1233”));`\t\t// true\n\n  `console.log(Boolean(100));`\t\t\t// true \n\n  **将“”、0、NaN、null、undefined转换层布尔类型为false，其他数据的转换结果均为true。**\n\n  `console.log(Boolean(“0”));`\t\t\t//true\n\n  `console.log(Boolean(0));`\t\t\t// false\n\n  `console.log(Boolean(“”));\t`\t\t\t// false\n\n  `console.log(Boolean(NaN));`\t\t\t// false\n\n  `console.log(Boolean(null));`\t\t\t// false\n\n  `console.log(Boolean(undefined));`\t// false\n\n\n\n","tags":["JS"]},{"title":"04-运算符","url":"%2F2017%2F02%2F19%2FJS%2F04-%E8%BF%90%E7%AE%97%E7%AC%A6%2F","content":"\n# 运算符\n\n## 算术运算符\n\n （ + - * / % ）先乘除取余数，在加减\n\n## 赋值运算符\n\n（针对的是变量，改变的也是变量）\n\n  简单赋值： ” = “\n\n  复合赋值运算符： “ += ”、“ -= ”、 “ *= ”、“ /= ”、” %= “\n\n\n## 关系运算符\n\n\n  比较大小：>、<、>=、<=\n\n  比较相等：\n\n  ​\t\t==、!= （相等）\n\n  ​\t\t===、!==（全等）\n\n  相等于全等的区别；相等运算符之比较数值大小；\n\n  全等运算符既比较数值大小也比较数值类型。\n\n\n## 逻辑运算符\n\n\n  && 与运算\n\n  两个条件都为真时，结果为真，其余都为假。 \n\n  || 或运算\n\n  两个条件只要有一个真，结果就是真，只有都为假时，结果为假。\n\n  ！ 非运算\n\n  取反 ，非假，既为真。非真，既为假。\n\n## &&和||运算符的短路问题\n\n- 对于&&运算符和||运算符的短路操作。最重要的一点是表达式的结果是由哪一个操作数决定的就返回这个操作数。\n- &&运算符（原则：都为真时表达式结果即为真，否则第一个为假结果就为假。也就是说整个表达式为真的情况是由最后一个为真的操作数决定的，则返回最后一个为真的操作数；为假的情况是由第一个出现假的操作数决定的，则返回第一个为假的操作数）。\n- ||运算符 （原则：有一个为真即为真，所有的都为假结果才为假。也就是说整个表达式为真的情况是由第一个出现真的操作数决定的，则返回第一个为真的操作数；为假的情况是由最后一个为假的操作数决定的，则返回最后一个为假的操作数）。\n\n\n## 一元运算符\n\n\n  操作数只有一个：！、+、-、++、--\n\n  N++：后自增：先运算，后自增。\n\n  ++N：前自增：先自增，后运算。\n\n  N-   ：后自减：先运算，后自减。\n\n  -N   ：前自减：先自减，后运算。\n\n\n## 优先级\n\n\n  1.小括号( );\n\n  2.一元运算符：\n\n  3.算术运算符：\n\n  4.关系运算符：（先比较大小、在比较相等）\n\n  5.逻辑运算符：\n\n  6.赋值运算符：\n\n## 补充弱类型：强类型和弱类型。\n\n   强类型：在创建变量时，就必须确定其数据类型。\n\n   弱类型：在创建变量时，变量内部可以保存的数类型是不定的。\n\n   ","tags":["JS"]},{"title":"03-数据类型","url":"%2F2017%2F02%2F18%2FJS%2F03-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F","content":"\n# 数据类型\n\n- 数据类型的分类\n\n  - 数据类型分为 **基本数据类型** 和 **引用数据类型**\n\n## 基本数据类型\n\n  - 1.Number类型：\n\n    意义：表示生活中的数值、价格、年龄、大小等...\n\n    Number类型的数值：\n\n    ①正数、负数、0（用十进制、八进制用0开头、十六进制用0x开头都可表示）；\n\n    ②小数既浮点数\n\n    ③无穷大和无穷小（infinity、-infinity）\n\n    ④Number.MAM_VALUE和Number.MIN_VALUE\n\n    ⑤NaN（not a number）（不是数值类型的数）\n\n    ​\t检测；IsNaN（数据）；返回布尔类型\n    进制\n\n\n## 十进制 【常用】\n\n  - 序列范围  \t0-9\n  - 十进制数字： 0;1;2;3;4;5;6;7;8;9;10;11;12;13;100;200;-100等\n\n## 八进制 【了解】\n\n  - 序列范围 \t0-7\n  - 八进制数字：\n    八进制数字表示必须以0为前缀表示\n    如：01; 02; 03; 04; 05; 06; 07; 等\n  - 注意：在参与运算或使用时，八进制会自动转成十进制来运算。\n\n## 十六进制 【了解】\n\n  - 序列范围：0-9及a-f\n  - 十六进制数字:\n    十六进制数字表示必须以0x为前缀表示\n    如：0x0; 0x1; 0x2; 0x3 0x4; 0x5; 0xa;等\n  - 注意：在参与运算或使用时，十六进制会自动转成十进制来运算。\n\n\n  - 2.String类型\n\n  - 意义：描述一段内容。\n\n  - 特点：用电影好或双引号包裹起来的字符。（单双引号嵌套使用）；\n\n  - 转义符： \\'       将单引号转化成普通字符\n\n    ​\t\t\\\" \t  将双引号转化成普通字符\n\n    ​\t\t\\n\t  换行\n\n    ​\t\t\\t \t  制表符\n\n    ​\t\t拼接符：+    ，    和字符串相加\n\n    3.Boolean 类型\n\n    ​\t取值：true 和 false 两种值。\n\n    ​\t意义：用程序来表示肯定或者否定。\n\n    4.Undefined 类型\n\n    ​\t意义：声明的变量没有赋值时，默认变量值是undefined。\n\n    ​\t该类型只有一个值，undefined。\n\n    5.Null 类型\n\n    意义：在垃圾回收机制中，没有用的数据会被清除掉（没有被变量引用的）。所以如果一个变量不在使用\t\t原先赋的值时Null赋给该变量，内存中的垃圾回收机制就可以清除数据。\n\n    Null的作用就是断开变量与内存  中数据的联系。\t\t\t\t  \t\t \t\n\n    Null只有一个值，null\n\n    类型被称为Null，但是用 typeof 检测 出 Object\n\n","tags":["JS"]},{"title":"02-变量","url":"%2F2017%2F02%2F18%2FJS%2F02-%E5%8F%98%E9%87%8F%2F","content":"\n# 变量\n\n## 语法\n\n- var 变量名 = 数据；（意思是；把内存中的空间地址赋值给变量）\n\n- **字面量**\n\n  - 直接被使用的数据（直接量）\n\n- **关于数据**\n\n  + 1.计算机要进行运输，计算的就是数据\n\n  + 2.程序运行时，数据会临时存在内存中并占据移动空间和大小\n\n  + 3.数据的定义：从输出角度点讲，能够正常输出的内容就是数据。\n\n    ​\t\t\t  数据类型角度讲，数据是有类型的。\n\n\n## 使用方式\n\n- **1.先声明，再赋值**\n\n    var a；\n\n    a = 2；\n\n  - **2.批量声明，后赋值**\n\n  - var a,b,c,d,;\n\n    a = 1,b = 2, c = 3, d = 4;\n\n  - **3.声明时赋值（既初始化）**\n\n    var a = 1,\n\n    ​       b = 2;\n\n  - **4.重复赋值**\n\n    var a = 1;\n\n    ​      a = 2;（但是不推荐使用，会破坏程序功能）\n\n  - **5.把一个变量赋值给另一个变量**\n\n     var a = 1;\n\n     var b = a;\t（当把a赋值给b时，内存中是两个1；并不是同一个1）\n\n\n\n## 规则和规范\n\n  **规则：** 使用字母、数字、下划线、$组成，不能以数字开头；\n\n  ​\t     不能使用关键字和保留字当做变量名（变量名就是一个标识符）；\n\n  ​\t      严格区分大小写；\n\n  **规范：** 驼峰命名法（几个单词连着的变量名第一个单词小写后的首字母大写）\n\n  ​\t\t例：var userName = “小张”；（顾名思义）\n\n\n\n\n\n","tags":["JS"]},{"title":"01-Js组成、输出、书写方式、调试循序与规范","url":"%2F2017%2F02%2F18%2FJS%2F01-Js%E7%BB%84%E6%88%90%E3%80%81%E8%BE%93%E5%87%BA%E3%80%81%E4%B9%A6%E5%86%99%E6%96%B9%E5%BC%8F%E3%80%81%E8%B0%83%E8%AF%95%E5%BE%AA%E5%BA%8F%E4%B8%8E%E8%A7%84%E8%8C%83%2F","content":"\n# \tJavascript的三大组成部分\n\n- **1.ECMAScript（标准语法）**\n\n- **2.DOM（文档模型）**\n\n- **3.BOM（浏览器模型）**\n\n\n\n\n\n##    Jacascript四种输出内容方式\n\n\n- **1.alert(\"内容\")**；                         警示框\n\n- **2.documen.write(\"内容\")；**     网页里面输出内容\n\n- **3.console.log(\"内容\") ；**           在控制台输出\n\n- **4.prompt(\"内容\")；**                    提示用户信息\n\n\n## Javascript的三种书写方式\n\n\n- **1.行内式**：（不推荐）\n\n- **2.内部**：      使用script标签，标签属性type当使用html。\n\n- **3.外联式**：   使用script标签，标签中属性src中属性值为js文件的路径。\n\n\n## Javascript的执行和调试循序\n\n\n- **1.js的循序是代码自上而下执行。**\n\n- **2.代码调试：**在网页中检查→选择sources→点击文件→设置断点→刷新页面→控制断点向下移动。\n\n\n## Javascript的代码规范\n\n- **1.缩进两个空格**\n\n- **2.每条语句后加分号    ；** （分号代表每一句代码结束，由于代码最后要压缩合并空格，所以必须由分号隔开）\n\n- **3.语句独占一行**\n\n\n\n","tags":["JS"]},{"title":"11-伸缩布局【弹性布局】(display:flex;)","url":"%2F2017%2F01%2F16%2FHTML%2F13-%E4%BC%B8%E7%BC%A9%E5%B8%83%E5%B1%80%2F","content":"\n# 伸缩布局【弹性布局】(display:flex;)\n\n- 首先给子元素的直接父元素设置为伸缩盒子.\n  - display:flex;\n\n    - 当父元素为伸缩盒子的时候，默认子元素在一行上显示。\n    - 伸缩盒子特点：\n         - 如果一个盒子变为伸缩盒子，那么该盒子就具有了两条轴，一条是主轴，一条是侧轴。主轴的默认方向是水平从左向右，侧轴始终要垂直于主轴。\n           - 子元素是按照主轴的方向显示的。\n\n## 设置主轴的方向\n\n```javascript\n            // 设置主轴的方向\n            flex-direction:row;\n            flex-direction:row-reverse;\n            flex-direction:column;\n            flex-direction:column-reverse;\n```\n- 总结：\n  - 由于在伸缩和中子元素是按照主轴的方向显示的，所以当我们调整主轴的方向的时候，子元素随着发生位置的改变。\n  - 主轴方向发生了改变后，侧轴的方向也会发生改变。\n\n\n## 设置子元素在主轴的对齐方式\n\n```javascript\n            // 设置子元素在主轴的对齐方式\n            justify-content:flex-start;\n            justify-content:flex-end;\n            justify-content:center;\n            justify-content:space-between;\n            justify-content:space-around;\n```\n- 总结：\n  - 通过设置该属性，只是改变了子元素在主轴方向的对齐显示位置，而元素自己本身的位置并没有改变。\n\n## 设置子元素在侧轴的对齐方式\n\n```javascript\n            // 设置子元素在侧轴的对齐方式\n            align-items:flex-start;\n            align-items:flex-end;\n            align-items:center;\n            align-items:streth;\n```\n- 总结：\n  - 在伸缩盒子中，子元素可以不用设置高度，如果不设置，那么该子元素的高度等于其父元素的高度，由于子元素是在侧轴的对齐方式是拉伸的效果。\n\n\n## 设置伸缩盒子是否允许子元素换行\n\n- 在伸缩盒子中，如果子元素的宽度超出父元素的宽度，那么子元素不会换行显示。\n\n## 设置子元素是否换行显示\n\n```javascript\n            // 设置子元素是否换行显示 默认不换行 nowrap\n            flex-wrap:nowrap;\n            // 子元素可以换行显示\n            flex-wrap:wrap;\n\n```\n\n## 设置子元素换行后的对齐方式\n\n```javascript\n            // 设置子元素换行后的对齐方式 默认的对齐方式:stretch\n            align-content:flex-start;\n            align-content:flex-end;\n            align-content:center;\n            align-content:space-around;\n            align-content:space-between;\n            align-content:stretch;\n```\n- 总结：\n  - 该属性设置的前提必须要保证元素是换行后的元素。\n\n## 伸缩盒子中子元素的相关属性\n\n- flex: 设置子元素占父元素剩余宽度的比例\n  - order: 排序 \n      - 不需要改变html结构中的位置，就可以实现在页面中调换元素的显示位置。\n      - order的取值越大，那么该元素在页面中的显示位置越靠后。","tags":["CSS"]},{"title":"10-动画(animation)","url":"%2F2017%2F01%2F15%2FHTML%2F12-%E5%8A%A8%E7%94%BB%2F","content":"\n# 动画(animation)\n\n## animation复合属性\n\n```javascript\n            .box {\n                width: 200px;\n                height: 200px;\n                background-color: red;\n                /* 要执行动画，要调用 */\n                \n                /* 动画名称 */\n                animation-name: box_move;\n                /* 动画执行的时间 */\n                animation-duration: 1s;\n                /* 动画执行次数： 默认执行1次   infinite:无限循环*/\n                animation-iteration-count: infinite;\n                /* 设置动画逆波 */\n                animation-direction: alternate;\n                /* 设置动画的速度类型 */\n                animation-timing-function: linear;\n                /* 设置动画延时执行 */\n                animation-delay: 2s;\n                /* 设置动画时间之外的状态 */\n                animation-fill-mode: forwards;\n            }\n            .box:hover {\n                /* 动画暂停 */\n                animation-play-state: paused;\n            }\n```\n- 定义动画\n  - 通过@keyframes + 自定义动画名称 {}\n  - 在动画集中通过from 和 to 设置动画的开始状态和结束状态。\n\n```javascript\n            /* 第一步：先定义一个动画集（序列） */\n            @keyframes  box_move {\n                \n                /* 第二步：定义动画的开始状态 */\n                from {\n                    transform: translate(0px);\n                }\n                /* 第三步：定义动画的结束状态 */\n                to {\n                    \n                    /* 2d的方式移动 */\n                    transform: translate(400px);\n                }\n            }\n\n\n        // 注意：\n\t\t// 动画集要单独定义，不能放到类样式中。\n```\n\n### 动画联写方式\n\n```javascript\n        animation: move 1s  linear infinite  alternate;\n```\n\n### 或者可以同时调用多个动画集\n\n```javascript\n        .box {\n                    width: 200px;\n                    height: 200px;\n                    background-color: red;\n                    \n                    animation: move 1s  linear infinite  alternate,\n                            chage1 1s 1s linear; \n                }\n```\n\n### 可以通过设置百分比的形式设置动画集中的不同状态\n\n```javascript\n        @keyframes  change {\n                    /*动画的开始状态*/\n                0% {\n\n                }\n                    /*动画的结束状态*/\n                100% {\n\n                    }\n                }\n\n    //百分比是相对动画执行时间。\n```\n","tags":["CSS"]},{"title":"09-3D转换(transform)【变形】","url":"%2F2017%2F01%2F14%2FHTML%2F11-3D%E8%BD%AC%E6%8D%A2%2F","content":"\n# 3D转换(transform)【变形】\n\n## 位移    \n\n```javascript\n    // 位移\n            transform: translateX(-400px) translateY(-400px) translateZ(-400px);\n\n```\n- 总结:\n  - 如果设置的是正数，那么就沿着对应坐标轴的正方向移动，反之沿着反方向移动\n\n\n## 旋转\n\n```javascript\n    // 旋转\n            transform:rotateX(-90deg);\n            transform:rotateY(-90deg);\n            transform:rotateZ(90deg);\n```\n-  备注:\n  - 通过左手法则判断元素的旋转方向\n  - 左手法则： 用左手握住坐标轴，大拇指指向坐标轴的方向，四个手指弯曲的方向就是旋转的方向\n\n\n## 缩放\n\n`transform:scaleX(2) scaleY(2);`\n\n## 透视\n- perspective: 1000px;\n  - 总结：\n    - 该属性要设置给变形元素的父元素\n    - 该属性不是一个必须要设置的属性\n    - 该属性的取值不是唯一的，但是我们一般情况下将该属性的取值设置了800-1000之间。","tags":["CSS"]},{"title":"08-2D转换(transform)【变形】","url":"%2F2017%2F01%2F14%2FHTML%2F10-2D%E8%BD%AC%E6%8D%A2%2F","content":"\n# 2D转换(transform)【变形】\n\n## 位移\n\n- transform: translate(400px,200px);\n- 总结：\n  - 如果在translate()中设置一个值，那么代表当前元素是沿着水平方向移动，如果是正数则向右移动，反之向左移动。\n  - 如果在translate()中设置两个值，第一个值代表水平方向移动，第二个值代表垂直方向移动。\n  - translate()中可以设置百分比，百分比是相对元素自己的宽度或者高度\n\n\n## 旋转\n\n- transform: rotate(360deg);\n- 总结：\n  - 如果设置的是一个正数，那么代表当前元素是按照顺时针方向旋转，反之逆时针\n  - 如果我们希望一个元素既旋转又位移，推荐先写位移然后设置旋转\n    `transform: translate(400px) rotate(360deg);`\n\n\n## 缩放（让元素放大或缩小）\n\n- transform: scale(0.5,1)；\n  - 总结：\n      - 如果sacle()中设置的是一个值，那么代表该元素在水平方向和垂直方向同时放大或者缩小。\n          - 如果设置两个值，那么第一个值代表的是水平方向的放大或缩小。第二个值代表的是垂直方向的放大或者缩小\n          - 如果要实现放大的效果，那么我们设置大于1的数字就可以了\n          - 如果要实现缩小的效果，那么我们设置大于0小于1之间的小数就可以了。\n          - 不能设置负数\n\n## 倾斜\n\n- transform: skew(30deg);\n    - 总结：\n      - 如果skew设的是一个值，那么代表该元素是沿着水平方向让元素发生倾斜，如果设置两个值，第一个代表水平方向，第二值代表垂直方向\n\n## transform属性联写：\n\n `transform:translate() rotate(angle) scale()skew(30deg,40deg);`\n\n## 旋转圆心位置改变（设置）\n\n- transform-origin设置旋转圆心位置\n  - 可以通过关键字设置 left | right | top | bottom | center\n  - 可以设置具体值设置\n\n\n## 定位盒子居中显示 \n\n```javascript\n        // 2d转化实现绝对定位的盒子居中：\n            .box {\n                    width: 123px;\n                    height: 123px;\n                    background-color: pink;\n                    position:absolute;\n                    left:50%;\n                    transform: translate(-50%);\n                    }\n        // 3d转化的方式实现绝对定位的盒子水平居中：\n                    .one {\n                        width: 123px;\n                        height: 123px;\n                        background-color: pink;\n                        position:absolute;\n                        left:50%;\n                        transform: translateX(-50%);\n                    }\n```\n","tags":["CSS"]},{"title":"07-过渡（transition）","url":"%2F2017%2F01%2F13%2FHTML%2F09-%E8%BF%87%E6%B8%A1%2F","content":"\n# 过渡（transition）\n\n- 过渡属于一种特殊的动画\n  - 通过一种状态向另外一种状态的改变\n    - transition 复合属性：\n\n```javascript\n            /* 设置参与过渡的属性 */\n\t\t\ttransition-property: width,height,background-color;\n\t\t\ttransition-property: all; \n\n\t\t\t/* 设置过渡完成的时间 */\n\t\t\ttransition-duration: 1s; \n\n\t\t\t/* 设置过渡延时执行的时间 */\n\t\t\ttransition-delay: 1s; \n\n\t\t\t/* 设置过渡的类型（速度类型） */\n\t\t\ttransition-timing-function: ease;\n\t\t\ttransition-timing-function: ease-in;\n\t\t\ttransition-timing-function: ease-out;\n\t\t\ttransition-timing-function: ease-in-out; \n\n\t\t\t/* 代表当前过渡的速度是匀速完成的。 */\n\t\t\ttransition-timing-function: linear; \n\n            // 属性联写:\n\t\t\ttransition: all  1s  linear; \n\n            //或者单独为每一个属性设置过渡的效果：\n            transition: width 1s linear,\n                        height 1s  1s linear,\n                        background-color 1s 2s linear;\n```\n\n## 常用网\n\n过渡调试网站：[DiagramDesigner](http://cubic-bezier.com/)\n\n","tags":["CSS"]},{"title":"06-Web字体","url":"%2F2017%2F01%2F12%2FHTML%2F08-Web%E5%AD%97%E4%BD%93%2F","content":"\n# Web字体\n\n- 开发人员可以为自已的网页指定特殊的字体，无需考虑用户电脑上是否安装了此特殊字体，从此把特殊字体处理成图片的时代便成为了过去。支持程度比较好，甚至IE低版本浏览器也能支持。\n\n  [在线字体](http://www.iconfont.cn/)\n\n    - 引用在线字体。（了解）\n    - 下载到本地使用（推荐）\n\n- **字体格式**\n    - 不同浏览器所支持的字体格式是不一样的，我们有必要了解一下有关字体格式的知识。\n\n        - 1、TureType(.ttf)格式\n            - .ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；\n\n        - 2、OpenType(.otf)格式\n            - .otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；\n\n        - 3、Web Open Font Format(.woff)格式\n            - woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；\n\n        - 4、Embedded Open Type(.eot)格式\n            - .eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；\n\n        - 5、SVG(.svg)格式\n            - .svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+；\n\n","tags":["CSS"]},{"title":"05-Logo内容移除","url":"%2F2017%2F01%2F12%2FHTML%2F07-Logo%E5%86%85%E5%AE%B9%E7%A7%BB%E9%99%A4%2F","content":"\n# Logo内容移除\n\n- 推荐将logo作为a标签的背景图片使用\n  - 推荐在logo中要设置文字，但是还要将该文字移除（用户体验）\n  - 推荐使用text-indent 设置一个负值来移除logo中的内容\n        - 或者：\n```javascript\n            font-size:0px;\n            color:transparent;\n```\n# 盒子阴影\n\n```javascript\n            box-shadow: 5px 5px 10px green,\n                       -5px -5px 10px red;\n```\n## 设置盒子内阴影\n\n```javascript\n            box-shadow:inset 5px 5px 10px green;\n```\n- 注意：\n  - 盒子阴影不会改变盒子大小。\n\n\n## 滑动门\n\n- 制作导航（使用背景图片制作）\n- 核心：\n  - 使用背景图片\n  - 导航的内容区域不能设置固定宽度，一定要使用内容讲导航撑开\n\n","tags":["CSS"]},{"title":"04-定位","url":"%2F2017%2F01%2F12%2FHTML%2F06-%E5%AE%9A%E4%BD%8D%2F","content":"\n# 定位（与元素位置有关）\n\n- 定位的作用：\n  - 通过定位可以在网页布局中实现改变元素位置。\n- 分类：\n  - 静态定位（了解）\n  - 绝对定位（重点）\n  - 相对定位（重点）\n  - 固定定位\n\n## 静态定位\n\n```javascript\n            /*静态定位*/\n            position:static;\n            left:200px;\n            top:200px;\n```\n- 特点：\n  - 静态定位无法改变元素位置（认为静态定位的元素就是我们网页中标准流下的元素）\n  - 一般我们需要将固定定位或者绝对定位及其他定位转化为标准流下的元素，我们需要将该元素设置为静态定位即可。\n\n## 绝对定位\n\n```javascript\n            /*绝对定位*/\n            position:absolute;\n            left:100px;\n```\n- 特点：\n  - 通过给元素设置绝对定位可以改变元素位置\n\n  - 如果一个子元素的父元素没有设置定位或者设置了静态定位，那么该绝对定位的子元素是相对浏览器（body）左上角为参照进行位置移动的。\n\n  - 如果一个绝对定位的元素，其父元素如果设置了除静态定位以外的其他定位（绝对 | 相对定位 | 固定定位），那么该绝对定位的元素是相对父元素左上角为参照进行位置改变。\n\n  - 绝对定位的元素也是脱标的元素（不占位置）\n\n  - 绝对定位也可以让元素进行模式转换（脱标引起的）\n\n        - 概括：\n        - 一般如果页面网页布局中出现一个容器（盒子）压着另外一个盒子，那么我们考虑使用绝对定位\n\n\n## 相对定位\n\n```javascript\n            /*相对定位*/\n            position:relative;\n            left:20px;\n```\n- 特点：\n  - 相对定位的元素是相对元素自己原来的位置发生的改变。（相对定位的元素与父元素是哪种定位无关）\n  - 相对定位的元素没有脱标（占位置），不能实现模式转换\n\n        - 使用场景：\n          - 如果子元素设置了绝对定位，那么推荐直接给其父元素设置相对定位**（子绝父相）**\n\n\n## 绝对定位（脱标）的元素居中显示\n\n    - margin: 0 auto; 只能让标准流的盒子居中\n        - 推荐的方式1\n```javascript\n            position:absolute;\n            /*相对父元素的宽度分一半*/\n            left:50%;\n            margin-left: -100px;\n```\n- left: 50%;  相对父元素的宽度移动一半\n- margin-left: -100px； 相对元素自己宽度一半\n\n### 居中的方法\n\n- 方式2\n```javascript\n    //这种垂直居中的方法需要设置宽和高；    \n\tdiv{\n            width: 500px;\n            height: 500px;\n            position: absolute;\n            left: 0;\n            right: 0;\n            top: 0;\n            bottom: 0;\n            margin: auto;\n        }\n```\n\n\n\n## 固定定位\n\n```javascript\n            /*固定定位*/\n            position:fixed;\n            left:20px;\n            top:20px;\n```\n- 特点：\n  - 固定定位的元素始终参照浏览器（body）标签左上角为参照进行位置改变（与父元素有无定位无关）\n  - 固定定位的元素也是脱标的元素（不占位置）\n  - 可以进行模式转换\n\n### 定位层级关系\n\n- 只有定位（静态定位除外）的元素才有层级关系\n\n    - 通过z-index属性去设置（改变）元素的层级关系\n        - 默认的z-index: auto\n\n    - 层级特点：\n      - 如果z-index值相同，那么后面的定位元素会压着前面的定位元素（后来居上）\n      - 如果z-index值不相同，那么z-index的值越大，该元素的层级越高。\n      - 如果子元素的父元素设置了定位（绝对定位或者相对定位或者固定定位），父元素层级（z-index越大）该元素的层级越高。\n\n    - 注意：\n      - 通过z-index改变元素的层级关系的时候，一定要保证当前元素属于定位元素。\n      - z-index的取值可以是负数。\n\n\n- **标签包含规范**\n\n    - 推荐行内元素包含行内元素\n    - 最好段落标签中不能出现标题\n    - 段落中最好不要出现div\n\n\n- **网页布局规避脱标流**\n    - 优先考虑标准流进行网页布局\n    - 然后考虑使用浮动（块级元素在一行上显示）\n    - 最后考虑使用定位（元素压着另外一个元素）\n    - 如果要实现模式转换，必须使用dispaly\n\n- **图片垂直对齐方式**\n\n    - vertical-align：baseline; 默认值（基线对齐）\n      \t\t\t top| middel | bottom;\n\n    - 总结：\n      - vertical-align属性只能用在行内块元素或者table标签中\n      - 如果其他非行内块元素或者table标签要使用该属性，那么请将元素转为行内块元素或者table标签display: table;\n\n    - 使用：\n      - 解决插入图片底部3像素的空白（给插入图片设置vertical-align：top | bottom | middle）\n\n- 实现图片垂直居中(一种方式而已)\n```javascript\n            .box{\n                width:300px;\n                height:300px;\n                border:1xp solid red;\n                line-height:300px;\n            }\n            img{\n                vertical-align:midle;\n            }\n```\n- ✔ 第一步先设置行高等于容器的高度\n- ✔ 第二步给图片设置vertical-align:middle;\n\n- **元素隐藏方式**\n```javascript\n            overflow:hidden;\n            display: none;        元素隐藏后不占位置\n            display:block;        显示元素\n            visibility：hidden;   元素隐藏占位置\n```\n\n## 精灵图\n\n- **精灵图使用**\n    - 首先精灵图是一张普通的图片\n    - 这张图片上包含了若干张背景图片\n\n    - 作用：\n        - 设置元素的背景图片\n\n    - 为了减少网络请求图片的次数\n\n    - 使用：\n      - 先将精灵图作为盒子的背景图片\n      - 通过background-position 在水平方向和垂直方向移动背景图片\n      - 水平方向移动的距离=要显示的图片在精灵图中的横坐标\n      - 垂直方向移动的距离=要显示的图片在精灵图中的纵坐标","tags":["CSS"]},{"title":"03-浮动","url":"%2F2017%2F01%2F11%2FHTML%2F05-%E6%B5%AE%E5%8A%A8%2F","content":"\n# 浮动（float）\n\n\n- 网页标准流\n  - 元素在浏览器中的默认显示方式（独占一行，在一行，占元素位置）\n    - 浮动：\n      - float: left | right;\n    - 特点：\n      - 浮动的元素不占位置（脱离标准流）\n        - 块级元素在一行上显示的时候就使用浮动（脱标）\t  \n        - 浮动可以实现模式转换（脱标）\n\n          - 总结：\n            - 在网页布局中，块级元素在一行显示就使用浮动\n            - 如果只是希望一个行内元素有宽度或者高度（进行模式转换），就使用display\n\n\n    - 使用：\n        - 为了实现图片和文字环绕效果，而设计了浮动该属性。【文字不会受浮动的影响，文字不会被浮动的元素压着】\n    \t    - 网页布局块级元素一行显示\n    \t    - 在网页布局中制作导航\n\n## 清除浮动\n\n- 消除浮动元素对后面元素的影响\n- 使用clear属性 :  left | right | both\n    - 使用伪元素清除浮动（推荐的方式）\n```javascript\n                .cleafix:after{\n                    content:\"\";\n                    height:0px;\n                    lin-height:0px;\n                    display:block;\n                    clear:both;\n                    /*隐藏*/\n                    visibility:hidden;\n                }\n                .cleafix{\n                    /*兼容IE*/\n                    *zoom:1;\n}\n```\n- 给父元素设置overflow：hidden;\n  - 如果父元素中有定位的元素，并且该定位的元素超出了父元素，那么不推荐使用该方式清除浮动。\n\n\n## CSS初始化\n\n- 先将页面中标签默认的样式（内外边距，文字大小，文字颜色，文字字体。。。）恢复到原始的状态\n- 将页面中标签的样式设置为统一的样式\n\n## Overflow\n\n```javascript\n                /*默认超出父元素的内容也是可见*/\n                overflow:visible;\n                /*将超出父元素的内容部分进行隐藏*/\n                overflow:hidden;\n                /*如果内容超出父元素，会给父元素添加一个滚动条*/\n                overflow:scroll;\n                /*如果内容超出父元素那么就添加滚动条，否则不添加*/\n                overflow:auto;\n```","tags":["CSS"]},{"title":"02-渐变与盒模型","url":"%2F2017%2F01%2F11%2FHTML%2F04-%E6%B8%90%E5%8F%98%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F","content":"\n# 渐变\n\n- 线性渐变（背景颜色由一种颜色向另外一种颜色渐变）\n- 径向渐变\n- 线性渐变\n- 开始的背景颜色和结束的背景颜色\n- 渐变的方向\n  - 水平或者垂直\n  - 通过角度表示渐变的方向\n  - 渐变的范围（可以不用设置）\n  - 线性渐变：\n\n```javascript\n            background-image:linear-gradient(\n                /*渐变的反向从左向右*/\n                to right,\n                /*渐变的开始颜色*/\n                red,\n                /*渐变的结束颜色*/\n                pink\n            );\n```\n\n## 通过角度表示渐变的方向\n\n```javascript\n            .box{\n                width:400px;\n                height:400px;\n                background-image:linear-gradient(90deg,red,pink)\n            };\n```\n-  注意：\n  - 0deg  代表渐变的方向是从下向上渐变\n  - 90deg  代表渐变的方向是从左向右渐变\n\n## 通过百分比可以表示渐变的范围\n\n- 如果不设置 background-size属性的时候，百分比是相对父元素宽度，如果设置了 background-size，百分比是相对 background-size设置的值。\n\n## 径向渐变\n\n    - 组成：\n    \t- 开始颜色和结束颜色\n    \t- 圆心的位置和半径\n    - 语法：\n\n```javascript\n        /*径向渐变*/\n        background-image:radial-gradient(\n                        100px at center,\n                        red,\n                        blue\n        );\n```\n- 总结：\n  - 通过  at +  center  top  left right bottom设置圆心位置\n\n\n## 通过设置具体值也可以设置圆心位置\n\n```javascript\n        background-image:radial-gradient(\n                        100px at 20px 30px,\n                        red,\n                        blue\n        );\n```\n- 如果在径向渐变中，只设置一个半径值，那么默认水平半径和垂直半径一样\n- 如果要实现一个椭圆的径向渐变效果，那么我们需要设置水平半径和垂直半径\n\n```javascript\n        /*径向渐变*/\n        background-image:radial-gradient(\n                        100px 50px at center,\n                        red,\n                        blue\n        );\n```\n\n## 行高（line-height）\n\n- 浏览器中默认文字大小为16px\n- 浏览器中的默认文字行高=18px;\n\n- 行高=文字大小+上间距+下间距\n  - 通过设置文字的行高，改变的就是文字的上下间距\n  - 如果不设置行高，文字大小可以影响行高值\n  - 文字字体也可以影响行高值\n- 作用：\n  - 通过设置行高，改变文字之间的间距\n  - 一般我们可以通过设置文字行高，实现文字在容器中垂直居中（只要将行高值设置等于容器的高度【实际高度】）\n\n- **行高单位问题**\n- px   em   %  不带单位\n\n- 如果给单独一个标签设置文字行高。\n  - px：\n        - 该标签中的文字行高与文字大小无关，设置行高等于多少，最后文字的行高实际大小就是多少。\n  - em：\n        - 该标签的文字行高=文字大小*设置的行高值\n  - %：\n    - 该标签的文字行高=文字大小*设置的行高值\n    - 不带单位：\n       该标签的文字行高=文字大小*设置的行高值\n\n- 如果给父元素设置行高，子元素中的文字行高。\n    - 父元素行高em：\n        - 子元素的行高=父元素文字大小*父元素设置的行高（与子元素的文字大小无关）\n    - 父元素行高px：\n        - 子元素的行高=父元素的行高（与文字大小无关，体现了继承性）\n    - 父元素行高%：\n        - 子元素的行高=父元素文字大小*父元素设置的行高（与子元素的文字大小无关）\n    - 父元素行高不带单位：\n        - 子元素的行高=子元素文字大小*父元素设置的行高值（先继承后计算）\n\n\n# 盒子模型\n\n\n- 作用：\n  - 网页布局【画盒子】\n- 组成：\n  - 内容区域\n  - 边框\n  - 内边距：内容区域与边框之间的距离\n  - 外边距：盒子与盒子之间的距离\n\n## 边框(border)\n\n- border-width: 设置边框宽度\n- border-color: 设置边框的颜色\n- border-style： 设置边框的样式\n    - none |solid(实线) | dashed (虚线) | dotted(点线)\n- 边框的属性联写：\n\n    > `border-top:1px solid red;`\n\n    >  或者单独设置某一条边框的样式\n\n    > `border-top:5px dotted green;`\n\n    >  或者单独指定每一个边框的样式\n\n    > `border-top-width:5px;`\n    >\n    > `border-top-style:dotted;`\n    >\n    > `border-top-color:green;`\n    >\n\n## 去掉边框\n\n\n- 去掉边框\n    - border-style: none;\n        - 或者\n    - border: none;\n        - 或者：\n    - border-top: none;\n\n\n## 去掉边框轮廓线\n\n\t- outline-style: none;\n- 点击文字设置控件光标：\n\n    ` <label for=\"uname\">用户名：</label><input type=\"text\" name=\"\" class=\"uname\" id=\"uname\"\">`\n- 补充：\n  - ✔边框合并 （只能用在表格中）\n      - border-collapse: collapse;\n  - ✔边框圆角\n    - border-radius: 10px;\n    - border-radius如果该属性只设置一组参数，那么代表另外的垂直半径与前面设置的水平半径相同（正圆）\n\n    - 如果要设置一个椭圆效果，那么需要同时设置水平半径和垂直半径。\n\n     ` border-radius:10px/1px;`\n\n\n\n## 内边距（padding）\n\n- 内容区域与边框之间的距离\n    - 总结：\n        - 我们平时设置盒子的宽度和高度，并不是盒子在浏览器中的实际大小，而是指的该盒子的内容区域的大小。\n        - padding不能改变元素的位置，只能改变元素中内容区域的位置\n```javascript\n            /*上 右 下 左 内边距为10px*/\n            padding:10px;\n            /*上 下 10px 左 右 20px*/\n            padding:10px 20px;\n            /*上 10px 右 20px 下 30px*/\n            padding:10px 20px 30px;\n            /*上 右 左 内 边距为*/\n            padding:10px 20px 30px 40px;\n```\n\n## 盒子的实际大小\n\n- 盒子实际（在浏览器中）大小=内容区域大小+边框+内边距\n    - 总结：\n        - 如果一个盒子没有设置边框和内边距，那么该盒子在浏览器中的实际大小就是其内容区域的大小。\n        - 如果一个容器设置了宽度和高度，同时又设置了内边距或者边框，要保证当前盒子大小不变，在要内容区域做减法操作。\n\n## 外边距（margin）\n\n- **设置盒子与盒子之间的距离**\n  - margin:\n      - 改变盒子的位置。\n  - margin不会改变元素的大小\n        - 设置盒子与盒子之间的距离\n  - margin:\n    - 改变盒子的位置。\n    - margin不会改变元素的大小\n  - margin特点：\n    - **垂直外边距合并**（在垂直方向，外边距以最大值为准，不会进行叠加运算）\n\n    - **外边距垂直塌陷**： 如果给子元素设置margin-top值的时候，发现父元素也向下移动了\n        - 给父元素设置边框\n        - 给父元素设置overflow：hidden;\n        - 让子元素或者父元素脱标（浮动，绝对定位，固定位定位）\n\n- **Padding灵活使用**  \n\n- Padding灵活使用\n    - 总结：\n      - 如果一个元素没有设置宽度或者高度，那么给该元素设置padding值的时候，不需要考虑盒子大小的改变。\n      - 不能给行内元素设置上下内外边距     \n\n- **Box-sizing**    \n    - 总结：\n      - 如果一个容器没有设置box-sizing或者设置了box-sizing:content-box; 那么该容器的实际大小=内容+边框+内边距 \n        - 如果一个容器设置了box-sizing:border-box;那么该容器的实际大小就是我们设置的width和height的实际大小","tags":["CSS"]},{"title":"01-CSS 基础","url":"%2F2017%2F01%2F11%2FHTML%2F03-css%E5%9F%BA%E7%A1%80%2F","content":"\n# CSS基础\n\n## CSS概念\n\n- 作用：\n    - 美化网页（通过css控制标签的样式）\n       - 网页布局（通过css控制标签的位置）\n\n- 概念：层叠样式表 (Cascading Style Sheets)或者级联样式表\n    - 层叠：css的特性。\n\n- 注意：\n   - css是以html为基础\n\n- 书写方式：\n  - 内嵌式写法\n    - 先准备一个html页面\n      - 在html页面中，head标签中添加一个style标签\n      - 在style标签中写css代码\n\n        - 外联式写法\n      - 首先新建一个单独的css文件（在该文件中不需要写style标签，直接写css代码就可以）\n      - 通过link标签将该css文件引入到当前html页面中\n\n    - 注意：\n    - 一个页面中可以同时引用多个css文件\n    - 行内式写法：将css代码写入到html标签内部\n\n## CSS语法 \n\n## 选择器\n\n - 选择器 {属性: 值; ......}\n    - 选择器分类\t\n      - 基础选择器\n      - 复合选择器\n      - 标签选择器\n\n### 基础选择器\n\n- ✔标签选择器（掌握）\n- ✔类选择器（掌握）\n- ✔ID选择器\n- ✔通配符选择器\n\n### 复合选择器（交集选择器）\n\n- ✔标签指定式选择器\n- ✔后代选择器     \n- ✔子代选择器\n- ✔并集选择器\n- ✔属性选择器\n- ✔伪类选择器\n\n#### 标签选择器\n\n- html标签名 {属性: 值;}\n    - 作用：\n      - 通过html标签名选中需要设置样式的标签\n    - 注意：\n      - 代码中遇到特殊符号，都必须是英文输入法下的符号。\n\n\n#### 类选择器(使用最多)\n\n- .自定义类名 {属性: 值; ....}    定义\n  -  类样式的调用：\n    -  标签通过class属性去调用定义好的类样式\n\n  -  例如：\n       `.test {color: red;}`\n          `<p  class=”test”>文字</p>`\n    -  类样式的特点：\n    -  一个标签可以同时调用多个类样式\n      - 一个类样式可以被多个标签同时调用\n\n- **类命名规范**\n\n    - 自定义类名不能使用纯数字或以数字开头\n\n    - 不推荐使用汉字定义类名\n\n    - 不能使用特殊字符或者以特殊字符开头（$,#,@,%...）\n\n    - 建议不推荐使用标签名作为类名\n\n    - 一般我们用具有一定语义的单词或者汉语拼音去定义一个类名\n\n\n#### ID选择器\n\n- 定义：\n    -  #自定义id名称 {属性: 值;  ....}\n    - 调用：\n        - 标签通过id属性调用id样式\n        - `#test {color: red;}`\n        - `<p   id=”test”></p>`\n\n    - ID选择器与类选择器的区别：\n      - ◆语法定义有区别  ( .   #)\n        - ◆在id选择器中，一个标签只能调用一个id样式。\n        - ◆一个类样式可以被多个标签调用，但是一个id样式最好只能被一个标签调用（否则，不符合编程规则）\n\n\n#### 通配符选择器\n\n- 语法：\n  - `* {属性: 值;...}`\n  - 特点：\n    - 将页面中所有的标签都选中\n\n\n### 复合选择器\n\n#### 标签指定式选择器\n\n- 标签名.类名 {属性: 值;}\n  - 总结：\n     - 标签指定式选择器符合 ：既。。。。又。。。的关系\n\n#### 后代选择器\n\n- 选择器  选择器 {属性: 值;}\n  - 总结：\n    - 后代选择器标签之间的结构关系必须是嵌套结构\n    - 后代选择器中只能选中所有的后代元素（直接子元素和间接子元素）\n    - 后代选择器中，选择器与选择器之间必须使用空格隔开\n\n#### 子代选择器\n\n- 选择器>选择器 {属性: 值；}\n    `div>span{color:red;}`\n- 总结：\n  - ◆子代选择器只能选中直接子元素\n  - ◆子代选择器不能选中父元素\n  - ◆子代选择器标签的结构必须是嵌套结构\n\n\n#### 并集选择器\n\n- 选择器,选择器 {属性: 值;}\n  - 注意：\n    - 首先并集选择器可以选中所有符合条件的标签\n    - 并集选择器与标签的结构无关.\n            `div,p,li,span{color:red;}`\n        - 并集选择器一般在css样式初始化的时候会使用。\n\n\n#### 结构伪类选择器\n\n- :first-child {属性: 值；}  选中父元素中的第一个子元素\n- :last-child {属性: 值;} 选中父元素中最后一个子元素\n  - :nth-child(n) {属性: 值; }  选中父元素中第n个子元素\n  - n 可以取一个正整数 （取值可以去到数字0）\n  - n可以设置一个关键字  odd(奇数个数) | even（偶数个数）\n  - n可以是一个表达式    an+b   a和b可以设置正数和负数 \n\n- :nth-last-child(n){属性: 值;} 选中倒数第n个子元素\n\n\n#### 属性选择器\n\n- [属性] {属性: 值;}\n\n#### 伪元素选择器\n\n- **选中标签中第一行文字。**::first-line { }\n\n    `box::first-line {color:red};`\n\n- **选中标签中第一个字母或者汉字** ::first-letter {} { }\n    ::first-letter { }\n\n    `.box::first-letter {color:red};`\n\n- **设置鼠标选中区域的样式**::selection {}\n\n    `.box::selection {color:red;background-color:pink;}`\n\n\n    - 注意：\n        - 该选择器中只能设置与颜色相关的属性。\n\n\n\n- **补充属性**     \n    - 单位\n        - px: 像素\n        - em： 1em  ===1个文字的大小\n\n    - 颜色的表示方式：\n      - ◆ red,  green....\n      - ◆ 使用十六进制表示颜色（#000-fff）\n      - ◆ rgb (三原色)   \n            - r  red   (0-255)\n        - g  green (0-255)\n        - b  blue  (0-255)\n\n         `background-color:rgb(100,255,20);`\n\n    - rgba:可以实现颜色半透明效果a ==> alpha  (0-1)\n       `background-color:rgb(0,0,0,0.5);`\n    - opacity ==> 实现半透明的效果\n      \t   取值： 0 -1之间\n      ` background-color:#000;`\n      `opacity: .5;`\n\n## 文本修饰 \n\n### text-shadow: 设置文字阴影。\n\n\n` text-shadow: 0px 0px 10px red;`\n\n- ◆第一个值可以设置正数或者负数，设置文字阴影在水平方向的一个偏移量\n - ◆第二个值可以设置正数或者负数，设置文字阴影在垂直方向的偏移量\n- ◆第三个值代表的是文字阴影的模糊度， 不能设置负数\n- ◆第四个值代表文字阴影的颜色。\n\n- 设置文字多个阴影.\n    `text-shadow: 0px 0px 10px red,1px 1px 5px green;`\n\n- 总结：\n    - 文字阴影使用text-shadow\n    - 如果设置多个阴影，用逗号隔开\n\n## font属性介绍\n- font-size:\"50px\";\n    - 设置文字大小\n\n- font-family:\"微软雅黑\"；\n    - 设置文字字体\n\n- 文字字体的表示方式:\n  - 使用具体的汉字（宋体，微软雅黑, 黑体。。。）\n    - 也可以使用字体对应的单词表示\n    - 也可以使用编码的方式表示字体\n\n    - 总结：\n      - ◆通过font-family可以设置若干个字体\n\n        ` font-family:\"微软雅黑\",\"等等\",\"等等\",\"等等\"`\n\n        - ◆以后在设置字体的时候，我们要选择常用的字体设置\n\n- font-weight： 设置文字是否加粗显示\n\n  - normal==400   | bold(加粗)==700 不带单位\n    - font-style: 设置文字是否斜体显示\n  - normal |  italic \n\n    - line-height: 设置文字行高（暂时理解文字的高度）\n    - 通过该属性可以改变文字的上下间距\n\n\n### font属性联写\n\n`font:700 italic 30px/20px \"微软雅黑\";`\n- 总结：\n  * 在font属性联写中 必须设置font-size 和 font-family\n  - 在font属性联写中，font-size 必须 设置在font-family之前\n  - 如果要设置行高，那么行高必须设置到font-size之后\n\n\n## 标签的显示方式\n\n- 块级元素\n- 行内元素\n- 行内块元素\n\n\n### 块级元素\n\n    - 代表：\n    \t- h1-h6,p，div,li,ul,ol,dd,dt....\n    - 特点：\n    \t- 如果块级元素不设置宽度，那么该元素的宽度等于其父元素的宽度。\n    \t- 所有的块级元素都独占一行显示\n    \t- 可以为块级元素设置宽度和高度\n\n\n### 行内元素\n\n    - 代表：\n    \t- span  a  b  font  strong.....\n    - 特点：\n    \t- 所有的行内元素都在一行上显示\n    \t- 行内元素不能设置宽度和高度\n\n\n### 行内块元素\n\n    - 代表标签：\n        - input,  img\n    - 特点：\n    \t- 元素可以设置宽度和高度\n    \t- 元素在一行上显示。\n\n\n### 元素模式转换\n\n- 转换块级元素\n  - display: block;\n- 转行内块元素\n  - display: inline-block;\n- 转行内元素\n  - display: inline;\n\n    - 总结：\n      - 一般情况下，如果我们希望页面中的行内元素设置宽度和高度，那么我考虑将行内元素转化为块级元素或行内块元素。\t\n    - 不需要将行内块元素转化为行内元素或者块级元素\n\n## 伪元素\n\n- ::before\n- ::after\n\n```javascript\n        body::before{\n            content:\"\";\n            background-color:red;\n            width:200px;\n            height:200px;\n            display:inline-block;\n         \n        body::after{\n            content:\"\";\n            background-color:green;\n            width:200px;\n            height:200px;\n            display:inline-block;\n}\n```\n- 总结：\n      - 伪元素必须设置content属性\n    - 伪元素属于行内元素\n    - 伪元素中不能再创建伪元素\n    - 一般是将伪元素要依附于某一个标签\n\n\n## CSS特性\n\n### 层叠性\n\n- 在同一个标签中，如果优先级相同，如果定义的样式发生冲突，那么最后一次定义的样式会将前面定义的样式（冲突的那部分）覆盖掉。\n\n### 继承性\n\n- 首先只有在嵌套关系的标签中才会出现继承性。\n  - 如果子元素默认没有样式，同时该元素又受父元素的样式影响\n    - color ， font属性 ，text-align...都可以被子元素继承\n    - 注意： \n    - ✔width 和 height 不能被继承\n    - ✔a标签在默认情况下，不能受父元素的文字颜色影响\n    - ✔标题标签在默认情况下，不能直接等于父元素设置的文字大小\n\n### 优先级\n\n- 标签选择器<类选择器<ID选择器<行内样式<!important\n    - 10       100       1000      10000   10000以上\n\n      - 继承的权重为0\n      - 权重可以叠加\n\n    - 总结：\n    - 一般我们通过css设置样式的时候，不要把选择器的优先级设置的太高或者太低。\n\n\n### 伪类(也是一种选择器)\n\n- a:link {属性: 值;}  与 a {属性： 值；}\n    或者a:-webkit-any-link\n       - 设置a标签的默认样式\n       - 推荐直接通过a标签设置样式\n\n    - a:visited {属性: 值;}  设置a标签被访问过后的样式\n       - 该选择器会让浏览器有缓存的问题\n       - 该选择器中只能设置与颜色相关的属性\n\n    - a:hover {属性: 值;} 设置当鼠标悬停到a标签上的样式\n    - a:active {属性: 值;} 当a标签被激活的时候的样式\n    - input:focus {属性: 值;}  当input标签获取光标焦点的时候的样式\n\n## 背景(background)\n\n- background-color: 设置背景颜色\n     默认值： transparent (透明色)\n- background-image: 设置背景图片\n- background-repeat: 设置背景图片的平铺方式\n  - repeat | no-repeat | repeat-x| repeat-y\n- background-position: 设置背景图片位置\n\n    `background-position:left bottom;`\n    - 或者\n      `background-position:100px 30px;`\n\n - 注意：\n  - 如果该属性设置一个值，那么另一个默认值代表center\n  - 如果设置具体数字，那么第一个值代表水平方向，第二值代表垂直方向\n    - 可以设置负数，正数代表沿着坐标轴正方向移动，负数沿着反方向移动\n\n### Background属性联写\n\n `background:red url(\"2_1.png) no-repeat\"`\n\n- 总结：\n  - 该属性联写没有个数的限制\n  - 没有顺序的限制\n  - 一般情况下 在网页中设置小图标的时候，考虑使用背景图片（装饰的效果）\n  - 一般情况下，在网页中如果是对某一件商品的展示，或者描述（插入图片）\n\n\n### 目标伪类\n\n- ：target{属性: 值；}\n        `div:target{background-color:red};`   \n\n- 注意：\n  - 目标伪类与锚链接配合使用\n  - 只有当被锚链接指向该标签的时候才会执行目标伪类中的css代码。\n\n### background-size(C3)\n\n- 通过该属性可以改变背景图片的显示大小。\n```javascript\n\t\t.box{\n\t\t\twidth:300px;\n\t\t\theight:300px;\n\t\t\tborder:1px solid red;\n\t\t\tbackground: url(\"2.jpg\") no-repeat;\n\t\t\tbackground-size:300px 300px;\n\t\t}\n```\n- background-size的取值：\n  - 设置具体值\n  - cover\n    - 将背景图片按照自己原来的缩放比，始终沾满整个父元素\n  - contain\n    - 将背景图片按照自己原来的缩放比，始终要将自己完整的显示到父容器中\n\n\n### 多背景\n\n\t- 可以给一个容器同时设置多张背景图片\n```javascript\n\t\t.img{\n\t\t\twidth:300px;\n\t\t\theight:300px;\n\t\t\t/*让容器（标签）整体居中*/\n\t\t\tmargin:0 auto;\n\t\t\tbackground: url(\"img/bg1.png\") no-repeat left top,\n\t\t\t\t    url(\"img/bg2.png\") no-repeat right top,\n\t\t\t\t    url(\"img/bg3.png\") no-repeat left bottom,\n\t\t\t\t    url(\"img/bg4.png\") no-repeat right bottom,\n\t\t\t\t    #fff url(\"img/bg5.png\")no-repeat center;\n\t\t}\n```","tags":["CSS"]},{"title":"02-列表","url":"%2F2017%2F01%2F11%2FHTML%2F02-%E5%88%97%E8%A1%A8%2F","content":"\n# 列表\n\n```javascript\n// 有序列表\n        <ol>\n        <li>列表项</li>\n        </ol>\n// 无序列表\n        <ul>\n        <li>列表项</li>\n        </ul>\n// 自定义列表\n        <dl>\n            <dt>列表项的标题</dt>\n            <dd>列表项</dd>\n        </dl>\n```\n\n## 多媒体\n\n- 视频标签\n   `<video></video>`\n    - 属性：\n        - src: 设置视频的路径\n        - controls： 显示控制栏\n        - loop： 设置视频循环播放\n        - autoplay：自动播放\n\n```javascript\n    <video src = \"其他/ds.mp4\" controls loop  autoplay></video>\n\n// 或者：\n    <video>\n        <source src = \"其他/1.itcast\">\n        <source src = \"其他/1.avi\">\n        <source src = \"其他/ds.mp4\">\n    </video>\n```\n\n## 音频标签\n\n\n```javascript\n<audio src = \"其他/See You Again.mp3\" control loop autoplay </audio>  \n```\n- 总结：\n    - 音频标签的用法及属性与视频标签一样\n\n## Meta\n\n```javascript\n        <meta charset=\"UTF-8\">\n\n        charset 字符集\n\n        UTF-8 属于字符集中的一种编码\n        \n        格式\n        unicode\n        gb2312\n        gbk\n        big5\n\n   作用： 设置网页编码 -->防止网页乱码\n\n\n    设置网页关键字\n        <meta name=\"keywords\" content=\"日用百货,葫芦娃,男装,女装\">\n```\n          \t  .\n- 总结：\n  - 设置网页关键字属于网页优化的一部分\n  - 网页关键字是为搜索引擎提供服务的\n\n## 实现网页重定向\n\n`<meta http-equiv = \"\"refresh\" content = \"1;http://t.com\">`  \n\n\n## Link标签\n\n- 设置网页图标\n  `<link rel=\"icon\" href=\"favicon.ico\">`\n   - 注意：\n        一般将网页图标放置到网站的根目录下\n- 引用样式表\n  `<link rel=\"stylesheet\" href=\"样式表地址\">`\n\n## 表格（table）\n\n```javascript  \n        组成：\n            行           <tr></tr>\n            列（单元格）  <td></td>\n            容器 \t\t\t\t<table></table>\n        作用：\n            数据展示\n            网页布局\n        属性：\n            border: 设置边框  默认为0 \n            height: 设置高度\n            width：设置宽度\n            cellspacing：设置td与td之间的距离  默认距离是2\n            align: 设置对齐方式\n            left | center | right\n            bgcolor: 设置背景颜色\n    总结：\n        如果将align属性设置给table标签，那么只能改变table标签的对齐方式，不能改变其内容的对齐方式\n\n        如果希望设置表格中的内容对齐方式，那么该属性要设置给tr或者td\n\n    cellpadding: 设置内容与边框之间的距离\n\n    其他标签:\n\n    <th></th>  设置表格标题，用法与td一样\n    <caption></caption>: 设置表格表头\n\n```\n\n- **表格基本的结构**\n\n```javascript\n                <table>\n                <thead>\n                    <tr>\n                    <th></th>\n                    </tr>\n                </thead>\n                <tbody>\n                <tr>\n                    <td></td>\n                </tr>\n                </tbody>\n                <tfoot>\n                   <tr>\n                    <td></td>\n                </tr>\n                </tfoot>\n                </table>\n```\n\n\n### 合并单元格\n\n\n- 横向合并\n     colspan=“数字\"\n     - 注意：\n       \t\t  合并完单元格后要记得将多出的列删掉\n- 纵向合并\n     rowspan=“数字\"\n     - 注意：\n         合并完单元格后要记得将多出的列删掉\n\n## 表单         \n\n- 搜集数据\n- 组成\n    - 表单控件（搜集信息）（重点）\n    - 提示信息\n    - 表单域\n- 表单域中的属性：\n  - action: 设置一个用来接收数据的一个后台程序\n  - method： 设置如何将数据交给后台程序的一种方式get  |  post\n\n\n### 表单控件\n\n\n```javascript \n\n输入框：\n    <input type=\"text\">\n    属性：\n        maxlength： 设置控件中最多能输入多少个字符\n        readonly： 设置控件为只读模式（不能输入）\n        disabled： 设置控件为未激活（不能输入）\n        name： 为控件设置名称\n        id:  设置控件唯一标识（身份证号）\n        value： 设置控件默认值\n\tplaceholder： 设置控件的提示信息\n\n\n 密码输入框：\n\n    <input  type=\"password\">\n\n    注意：\n        密码输入框的属性与输入框的属性一样\n\n复选框：\n    <input type=\"checkbox\">\n\n    属性：\n        checked： 设置复选框中默认选中项\n\t\n单选框：\n    <input  type=\"radio\" name=\"\">\n\n    注意：\n        如果要实现单选效果，那么需要将该控件设置相同的name属性值\n        如果要实现默认选中项，那么设置checked属性\n```\n\n\n### 下拉列表\n\n\n```javascript\n        <select>\n            <option>北京</option>\n            <option>上海</option>\n            <option>广州</option>\n        </select>\n\n    属性：\n        multiple： 让下拉列表实现多选效果\n\nselected： 设置下拉列表中默认选中项\n\n        <select>\n            <option>北京</option>\n            <option selected:>上海</option>\n            <option>广州</option>\n        </select>\n\n或者如下写法：\n\n        <select>\n            <optgroup lable = \"河北省\">\n                <option>邯郸</option>\n                <option>保定</option>\n                <option>石家庄</option>\n            </optgroup>\n        </select>\n```\n\n\n### 滑块\n\n\n```javascript\n        滑块\n            <input type=\"range\">（了解）\n        上传控件\n            <input type=\"file\" name=\"\">\n        多行文本域\n            <textarea></textarea>\n        按钮\n            提交按钮： 提交表单信息\n            <input type=\"submit\" name=\"\">\n            <input type=\"image\" src=\"按钮.jpg\">\n        普通按钮\n            <input type=\"button\" name=\"\" value=\"注册\">\n    注意：\n        ✔该按钮不能直接在表单域中提交数据\n        ✔该按钮一般配合js使用\n\n            <input type=\"reset\"> 将控件中的值恢复到默认值\n```\n\n\n### 智能表单控件\n\n\n`<input  type=\"email\" name=\"em\"> 验证邮箱格式控件`\n- `<input  type=\"url`>网址\n- `<input  type=\"number`>数字\n    - 电话.滑块.时间.日期.周.月 等等.\n\n\n### 新增表单属性\n\n\n- autofocus： 设置控件自动获取焦点\n- required：  设置控件为必须填写\n- placeholder： 占位符（提示信息）\n\n\n\n### 新增的表单元素\n\n\n```javascript\n<input  type=\"text\" name=\"\" list=\"date\">\n    <datalisi id=\"date\">\n         <option value = \"bj\">北京</option>\n         <option value = \"sh\">上海</option>\n         <option value = \"gz\">广州</option>\n    </datalisi>    \n\n```\n\n\n## 更多语法：\n\n- **请翻阅**\n  Emmet语法: \n  http://www.cnblogs.com/cnjava/archive/2013/07/30/3225174.html","tags":["HTML"]},{"title":"01-HTML基础","url":"%2F2017%2F01%2F11%2FHTML%2F01-HTML%E5%9F%BA%E7%A1%80%2F","content":"\n# 基础\n\n- **认识网页**\n   -  组成：文字，图片，按钮，搜索框，视频。。。元素（html标签）组成的。\n     总结：\n   -  网页其实就是由html标签组成的。\n\n- **网页标准**\n\n  - 结构标准：（骨骼）\n\n  - html ->搭建网页结构\n\n  - 表现标准：\n\n    - ss->美化网页\n\n  - 行为标准：\n\n  - javascript\n\n- **浏览器**\n    - 作用： 浏览网页\n\n    - 浏览器(以及内核)\n        - ie \n            - trdent\n        - 谷歌\n            - blink    \n        - 火狐 \n            - gecko\n        - 苹果\n            - webkit\n        - 欧鹏\n            - Presto \n        - 360 \n        - qq\n        - 猎豹\n        - uc\n          。。。。。。\n\n    - 内核（渲染引擎）： 将网页中的标签信息转化为我们人眼能够识别的图文信息。\n\n## 服务器\n\n- 1.浏览器向服务器发送请求（通过htto协议）\n- 2.http协议：超文本传输协议，也就是浏览器和服务器的网页传输数据的约束和规范\n- 3.url协议平时我们写的网站就是url地址。\n    - url协议：规定url地址的格式\n    - 协议规定格式： scheme://host.domain:port/path/filename\n\n    - scheme:定义因特网服务的类型.常见的就是http\n    - host:定义域主机（http的默认主机是www）\n    - domain:定义因特网域名。比如：w3shool.com.cn\n    - :port 定义端口号（网页默认端口:80）\n    - path:网页所在服务器上的路径\n    - filename:文件名称\n\n## HTML\n\n - HTML : Hyper  Text  Markup  Language\n    - 超文本：在网页中能够实现页面跳转的文字（超链接）\n    - 标记： 指的是在网页中的html标签\n\n```javascript\n        // html结构介绍：\n        // 目前我们是按照html5结构去设计网页的\n        // 之前： html4  xhtml（扩展）\n        <!Doctype html>\n        <html>\n        <head>\n        <title>网页标题</title>\n        </head>\n        <body></body>\n        </html>\n```\n\n - 详细介绍结构中的标签\n- ✔Doctype标签：告诉浏览器当前文档的类型。\n  - 如果不设置Doctype那么浏览器在显示过程中可能会出现一种怪异模式。\n- ✔html标签：结构中的根标签\n- ✔head标签： 可以设置网页样式;可以设置网页标题；设置网页关键字，网页描述信息，js代码编写。。。。\n- ✔title标签： 设置网页标题\n- ✔body标签： 指的是网页的主体（我们看到的所有信息）\n\n- **html版本介绍**\n\n - .strict.dtd : 严格模式（标准模式）\n\n - .transitional.dtd: 过渡模式\n\n - .loose.dtd: 过渡模式（松散模式）\n\n\n## Html标签\n  - 标签写法分类\n  - ✔双标签： 有开始和结束标签\n      - 例如： head  body  title\n  - ✔单标签： 只有开始没有结束\n    - 例如： meta , hr,br...\n  - 标签与标签之间关系的分类\n  - ✔并列关系：（兄弟）\n  - ✔包含关系（嵌套关系）：（父子）\n\n- **单标签**\n```javascript\n    ✔横线标签\n         <hr>\n    ✔设置网页编码\n\t <meta charset=\"UTF-8\">\n    ✔换行标签\n         <br>\n    ✔注释标签\n\t <!-- 内容 -->    或者   ctrl+/\n```\n\n - **双标签**\n\n ```javascript\n            <h1></h1>\n            <h2></h2>\n            <h3></h3>\n            <h4></h4>\n            <h5></h5>\n            <h6></h6>\n    // 注意：\n    //     标题标签只有从h1-h6\n    //     在当前网页中最好一号标题出现一次\n\n    // 段落标签\n            <p></p>\n\n    // 格式化标签（突出显示信息）\n\n    // 文字加粗\n        <strong></strong>  或者  <b></b>\n\n    // 文字斜体\n        <em></em> 或者  <i></i>\n\n    // 文字下划线\n        <ins></ins> 或者  <u></u>\n\n    // 删除线标签\n        <del> </del>  或者  <s></s>\n    \n    // 设置文字颜色或者大小\n        <font color=\"red\" size=\"5\">红色文字</font>\n    \n    // 总结：\n\t\t\t//   color属性： 设置文字颜色\n\t\t\t//   size 属性： 设置文字大小，不需要带单位\n\n\n    // 其他双标签\n        <div></div> \n        <span></span>\n\t\t//  总结：\n\t\t// \t  ◆使用场景是在网页布局过程中使用该标签\n\t\t// \t  ◆该标签属于没有语义的标签\n ```\n\n - **图片标签**\n\n > `<img>`\n- 相关属性：\n  - src=””: 通过该属性设置图片的相对路径或绝对路径，用来向浏览器展示所要显示的图片\n\n  - title=“”：设置鼠标悬停到图片上的文字提示\n\n  - alt=””: 设置图片描述信息（注意：该属性并不是给用户展示的，为搜索引擎提供服务）\n\n    - width: 设置宽度\n  - height:设置高度\n    总结：\n    - 图片标签也属于多媒体标签的一部分\n    - 多媒体标签有自己的缩放比例关系\n\n## 路径\n\n### 绝对路径：\n  - 凡是带有磁盘目录或者网站地址的路径\n### 相对路径：\n\t- 相对路径必须保证在同一个根目录下\n\t- 没有磁盘目录或者网站地址的路径\n\t\n\t   - 如果当前页面（html）和要访问的资源（图片），在同一个文件夹中， src=”直接设置图片名称即可”\n\n- 如果当前页面（html）和要访问的资源（图片），不在同一个文件夹中，如果页面在图片的上一级目录中，src=”文件夹名称/+图片名称”;\n\n- 如果当前页面（html）和要访问的资源（图片），不在同一个文件夹中，如果页面在图片的下一级目录中，src=”../\n\n- **超链接**\n\n- 作用： 实现页面跳转\n    - <a href=”目标页面的路径”>文字</a>\n- 属性介绍：\n    - target=\"_blank\"  在新窗口中打开页面\n    - “_self” 默认值在当前窗口中打开页面\n\n- 在head标签中添加base标签，在base标签中设置target属性为_blank;\n    - title: 设置鼠标悬停到超链接上的文字提示\n\n- 超链接在本页面内部跳转\n    - 直接设置href的值为=”#”\n\n- **锚链接**\n```javascript\n    <p id=\"text\">\n        <font color = \"red\">文字</font>    \n        这里有一段红色的文字\n    </p>\n    <a href=\"#text\">找到红色的文字</a>\n```\n\n- **特殊字符** \n\n```javascript\n    &nbsp;  空格\n    &lt;   <\n    &gt;   >\n```\n- 等等...还有很多特殊字符,用到去查。\n\n\n## 标签语义化\n\n- 概念：根据内容的结构化（内容语义化），选择合适的标签（代码语义化）\n- 作用： \n    - 网页的语义性更明确（搜索引擎）\n    - 网页结构更合理\n      实现：\n    - 选择有语义的标签\n    - 在语义不明确的时候，要选择有语义的标签\n    - 如果要设置样式，推荐使用css。\n\n- **语义标签**\n\n - `<nav></nav>`  表示的就是导航区域\n- `<header></header>` 在网页布局中的头部\n- `<footer></footer>` 在网页布局中的结尾部分\n- `<article></article>`\n- `<aside></aside> `在网页布局中侧边栏部分\n- `<section></section>` 网页布局中的区域\n    - 总结:\n      - 该标签的用法与div用法一样\n      - 该标签有语义，div没有语义","tags":["HTML"]}]